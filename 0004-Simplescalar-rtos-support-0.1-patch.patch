From 8e98cc05b6d424cd55a24fc103faed62dff1401d Mon Sep 17 00:00:00 2001
From: Christoph Gerum <christoph@gerum.de>
Date: Sun, 28 Nov 2010 14:53:26 +0100
Subject: [PATCH] Simplescalar rtos-support 0.1 patch

From: http://www.jwhitham.org.uk/simplescalar/
---
 Makefile       |    5 +-
 cache.c        |    3 +-
 machine.c      |   25 +-
 machine.def    | 7867 +++++++++++++++++++++++++++++++++++++++++++++++++++++++-
 machine.h      |  877 +++++++-
 sim-outorder.c |  270 ++-
 syscall.c      | 4232 ++++++++++++++++++++++++++++++-
 7 files changed, 13261 insertions(+), 18 deletions(-)
 mode change 120000 => 100644 machine.def
 mode change 120000 => 100644 machine.h
 mode change 120000 => 100644 syscall.c

diff --git a/Makefile b/Makefile
index 0b71339..282bbfa 100644
--- a/Makefile
+++ b/Makefile
@@ -411,7 +411,7 @@ PROGS = sim-fast$(EEXT) sim-safe$(EEXT) sim-uop$(EEXT) im-eio$(EEXT) \
 #
 # all targets, NOTE: library ordering is important...
 #
-all: sim-safe sim-uop sim-profile sim-cache sim-cheetah sim-bpred sim-outorder # sim-armulator sim-dis sim-depchk $(PROGS)
+all: sim-outorder # sim-armulator sim-dis sim-depchk $(PROGS)
 	@echo "my work is done here..."
 
 config-pisa:
@@ -519,6 +519,9 @@ sim-cheetah$(EEXT):	sysprobe$(EEXT) sim-cheetah.$(OEXT) $(OBJS) libcheetah/libch
 sim-cache$(EEXT):	sysprobe$(EEXT) sim-cache.$(OEXT) cache.$(OEXT) $(OBJS) libexo/libexo.$(LEXT)
 	$(CC) -o sim-cache$(EEXT) $(CFLAGS) sim-cache.$(OEXT) cache.$(OEXT) $(OBJS) libexo/libexo.$(LEXT) $(MLIBS)
 
+sim-outorder.dump:
+	$(CC) -E -o sim-outorder.dump $(CFLAGS) sim-outorder.c
+
 sim-outorder$(EEXT):	sysprobe$(EEXT) sim-outorder.$(OEXT) cache.$(OEXT) bpred.$(OEXT) resource.$(OEXT) ptrace.$(OEXT) $(OBJS) libexo/libexo.$(LEXT)
 	$(CC) -o sim-outorder$(EEXT) $(CFLAGS) sim-outorder.$(OEXT) cache.$(OEXT) bpred.$(OEXT) resource.$(OEXT) ptrace.$(OEXT) $(OBJS) libexo/libexo.$(LEXT) $(MLIBS)
 
diff --git a/cache.c b/cache.c
index f2f0c00..57211ec 100644
--- a/cache.c
+++ b/cache.c
@@ -585,7 +585,8 @@ cache_access(struct cache_t *cp,	/* cache to access */
   /* permissions are checked on cache misses */
 
   /* check for a fast hit: access to same block */
-  if (CACHE_TAGSET(cp, addr) == cp->last_tagset)
+  if ((CACHE_TAGSET(cp, addr) == cp->last_tagset)
+  && ( cp -> last_tagset != 0 ))
     {
       /* hit in the same block */
       blk = cp->last_blk;
diff --git a/machine.c b/machine.c
index 2263fbb..8ee500e 100644
--- a/machine.c
+++ b/machine.c
@@ -165,6 +165,7 @@
 
 #include <stdio.h>
 #include <stdlib.h>
+#include <assert.h>
 
 #include "host.h"
 #include "misc.h"
@@ -513,7 +514,7 @@ md_print_creg(md_ctrl_t regs, int reg, FILE *stream)
       break;
 
     case 1:
-      myfprintf(stream, "SPSR: 0x%08x", regs.spsr);
+      myfprintf(stream, "SPSR (svc): 0x%08x", regs.spsr[MD_SPSR_SVC]);
       break;
 
     case 2:
@@ -550,7 +551,8 @@ md_xor_regs(struct regs_t *regs)
   //    checksum ^= regs->regs_F.q[i];
 
   checksum ^= regs->regs_C.cpsr;
-  checksum ^= regs->regs_C.spsr;
+  checksum ^= regs->regs_C.spsr [MD_SPSR_SVC];
+  checksum ^= regs->regs_C.spsr [MD_SPSR_IRQ];
   checksum ^= regs->regs_C.fpsr;
   //  checksum ^= regs->regs_PC;
   //  checksum ^= regs->regs_NPC;
@@ -826,6 +828,25 @@ md_get_flow(enum md_opcode op, md_inst_t inst,
 
   switch (op)
     {
+    case STM_US:
+    case STM_S:
+    case STM_PS:
+    case STM_PUS:
+    case STM_USW:
+    case STM_SW:
+    case STM_PSW:
+    case STM_PUSW:
+    case LDM_USL:
+    case LDM_SL:
+    case LDM_PSL:
+    case LDM_PUSL:
+    case LDM_USWL:
+    case LDM_SWL:
+    case LDM_PSWL:
+    case LDM_PUSWL:
+      assert ( 0 ) ; /* !"Guess you will need to do this after all." */
+      break ;
+
     case STM:
       offset = nregs*4 - 4;
       sign = -1;
diff --git a/machine.def b/machine.def
deleted file mode 120000
index b61cb34..64c7717
--- a/machine.def
+++ /dev/null
@@ -1 +0,0 @@
-target-arm/arm.def
\ No newline at end of file
diff --git a/machine.def b/machine.def
new file mode 100644
index b61cb34..64c7717
--- /dev/null
+++ b/machine.def
@@ -0,0 +1,7866 @@
+/* This doesn't look like -*- C -*-, but it is!
+ *
+ * arm.def - ARM ISA machine definition
+ *
+ * This file is a part of the SimpleScalar tool suite written by
+ * Todd M. Austin as a part of the Multiscalar Research Project.
+ *  
+ * The tool suite is currently maintained by Doug Burger and Todd M. Austin.
+ * 
+ * Copyright (C) 1997, 1998 by Todd M. Austin
+ *
+ * This source file is distributed "as is" in the hope that it will be
+ * useful.  The tool set comes with no warranty, and no author or
+ * distributor accepts any responsibility for the consequences of its
+ * use. 
+ * 
+ * Everyone is granted permission to copy, modify and redistribute
+ * this tool set under the following conditions:
+ * 
+ *    This source code is distributed for non-commercial use only. 
+ *    Please contact the maintainer for restrictions applying to 
+ *    commercial use.
+ *
+ *    Permission is granted to anyone to make or distribute copies
+ *    of this source code, either as received or modified, in any
+ *    medium, provided that all copyright notices, permission and
+ *    nonwarranty notices are preserved, and that the distributor
+ *    grants the recipient permission for further redistribution as
+ *    permitted by this document.
+ *
+ *    Permission is granted to distribute this file in compiled
+ *    or executable form under the same conditions that apply for
+ *    source code, provided that either:
+ *
+ *    A. it is accompanied by the corresponding machine-readable
+ *       source code,
+ *    B. it is accompanied by a written offer, with no time limit,
+ *       to give anyone a machine-readable copy of the corresponding
+ *       source code in return for reimbursement of the cost of
+ *       distribution.  This written offer must permit verbatim
+ *       duplication by anyone, or
+ *    C. it is distributed by someone who received only the
+ *       executable form, and is accompanied by a copy of the
+ *       written offer of source code that they received concurrently.
+ *
+ * In other words, you are welcome to use, share and improve this
+ * source file.  You are forbidden to forbid anyone else to use, share
+ * and improve what you give them.
+ *
+ * INTERNET: dburger@cs.wisc.edu
+ * US Mail:  1210 W. Dayton Street, Madison, WI 53706
+ *
+ * $Id: arm.def,v 1.1.1.1 2000/11/29 14:53:54 cu-cs Exp $
+ * Revision 1.1.2.23  2000/08/25 18:40:13  taustin
+ * Started implementing funky PC semantics for ARM.
+ *
+ * Revision 1.1.2.22  2000/08/23 22:06:53  chriswea
+ * now supports all long multiples.. changed the decode order it now
+ * sees them right after ALUREG0 branch
+ *
+ * Revision 1.1.2.21  2000/08/23 20:33:04  chriswea
+ * fixed the umull bug (added a link from the add to umulladd)
+ *
+ * Revision 1.1.2.20  2000/08/23 15:24:56  chriswea
+ * Fixed the carry out flag for arm
+ *
+ * Revision 1.1.2.19  2000/08/22 18:38:52  taustin
+ * More progress on the SimpleScalar/ARM target.
+ *
+ * Revision 1.1.2.18  2000/07/28 21:37:22  taustin
+ * More debugging of the SimpleScalar/ARM target.
+ *
+ * Revision 1.1.2.17  2000/07/28 20:32:04  omutlu
+ * *** empty log message ***
+ *
+ * Revision 1.1.2.16  2000/07/28 04:53:43  omutlu
+ * fixed the post indexed ldr/strs
+ *
+ * Revision 1.1.2.15  2000/07/27 21:56:11  omutlu
+ * corrections to shifts
+ *
+ * Revision 1.1.2.14  2000/07/27 21:45:04  taustin
+ * Added umpteen half word and signed byte loads.
+ *
+ * Revision 1.1.2.13  2000/07/27 20:15:32  omutlu
+ * fixes to ldr and str
+ *
+ * Revision 1.1.2.12  2000/07/27 19:41:42  omutlu
+ * fixed bugs in tst,teq,cmn
+ *
+ * Revision 1.1.2.10  2000/07/27 17:51:26  omutlu
+ * fixed monadic CPDO instructions
+ *
+ * Revision 1.1.2.9  2000/07/26 12:21:55  taustin
+ * Fixed CPRT_LINK in ARM decode table.
+ *
+ * Revision 1.1.2.8  2000/07/26 06:32:18  omutlu
+ *
+ * More fixes to floating-point instructions
+ *
+ * Revision 1.1.2.7  2000/07/26 05:01:50  taustin
+ * More disassembler fixes...
+ *
+ * Revision 1.1.2.6  2000/07/25 18:29:03  omutlu
+ * Modified the branch offset calculation, cmp, ldm
+ *
+ * Revision 1.1.2.5  2000/07/21 18:30:59  taustin
+ * More progress on the SimpleScalar/ARM target.
+ *
+ * Revision 1.1.2.4  2000/07/13 03:09:55  taustin
+ * More progress on the SimpleScalar/ARM target.
+ *
+ * Revision 1.1.2.3  2000/07/01 13:35:37  taustin
+ * More progress on the ARM target support...
+ *
+ * Revision 1.1.2.2  2000/06/01 19:35:18  taustin
+ * ARM definition file, work in progress...
+ *
+ * Revision 1.1.2.1  2000/05/31 19:25:59  taustin
+ * ARM definition files
+ *
+ * Revision 1.1.1.1  2000/05/26 15:22:27  taustin
+ * SimpleScalar Tool Set
+ *
+ *
+ * Revision 1.5  1999/12/31 18:56:17  taustin
+ * quad_t naming conflicts removed
+ * Alpha instruction set extensions (MVI, BWX, AMASK, IMPLVER, etc...)
+ * 21-bit conditional branch offset fix
+ *
+ * Revision 1.4  1999/12/13 18:59:20  taustin
+ * debug printf's removed
+ *
+ * Revision 1.3  1999/03/08 06:39:41  taustin
+ * added Alpha BWX ISA extensions (byte and word loads)
+ *
+ * Revision 1.2  1998/08/31 17:14:07  taustin
+ * fixed MS VC++ shift-by-64bit problems in EXT* instructions
+ * fixed MS VC++ qword to double problem in FPCR instruction
+ *
+ * Revision 1.1  1998/08/27 16:53:47  taustin
+ * Initial revision
+ *
+ *
+ */
+
+/* FIXME: these comments are out-of-date */
+
+/* This file defines all aspects of the SimpleScalar instruction set
+ * architecture.  Each instruction set in the architecture has a DEFINST()
+ * macro call included below.  The contents of a instruction definition are
+ * as follows:
+ *
+ *   DEFINST(<enum>,			<opcode>,
+ *	     <opname>,			<operands>,
+ *	     <fu_req>,			<iflags>,
+ *	     <output deps...>,		<input deps...>,
+ *	     <expr>)
+ *
+ * Where:
+ *
+ *   <enum>	- is an enumerator that is returned when an instruction is
+ *		  decoded by SS_OP_ENUM()
+ *   <opcode>	- is the opcode of this instruction
+ *   <opname>   - name of this instruction as a string, used by disassembler
+ *   <operands>	- specified the instruction operand fields and their printed
+ * 		  order for disassembly, used by disassembler, the recognized
+ *		  operand field are (the instruction format is detailed in
+ *		  the header file ss.h):
+ *		    J - target field
+ *		    j - PC relative target (offset + PC)
+ *		    s - S register field
+ *		    b - S register field (base register)
+ *		    t - T register field
+ *		    d - D register field
+ *		    S - S register field (FP register)
+ *		    T - T register field (FP register)
+ *		    D - D register field (FP register)
+ *		    o - load address offset (offset)
+ *		    i - signed immediate field value
+ *		    u - unsigned immediate field value
+ *		    U - upper immediate field value
+ *		    H - shift amount immediate field value
+ *		    B - break code
+ *
+ *   <fu_req>	- functional unit requirements for this instruction
+ *   <iflags>	- instruction flags, accessible via the SS_OP_FLAGS()
+ *		  macro, flags are defined with F_* prefix in ss.h
+ *   <output deps...>
+ *		- a list of up to two output dependency designators, the
+ *		  following designators are recognized (place an DNA in any
+ *		  unused fields:
+ *		    DGPR(N)   - general purpose register N
+ *		    DGPR_D(N) - double word general purpose register N
+ *		    DCGPR(N)  - general purpose register conditional on
+ *			        pre/post- increment/decrement mode
+ *		    DFPR_L(N) - floating-point register N, as word
+ *		    DFPR_F(N) - floating-point reg N, as single-prec float
+ *		    DFPR_D(N) - floating-point reg N, as double-prec double
+ *		    DHI	      - HI result register
+ *		    DLO	      - LO result register
+ *		    DFCC      - floating point condition codes
+ *		    DCPC      - current PC
+ *		    DNPC      - next PC
+ *		    DNA	      - no dependence
+ *
+ *   <input deps...>
+ *		- a list of up to three input dependency designators, the
+ *		  designators are defined above (place an DNA in any unused
+ *		  fields.
+ *
+ *   <expr>	- a C expression that implements the instruction being
+ * 		  defined, the expression must modify all architected state
+ *		  affected by the instruction's execution, by default, the
+ *		  next PC (NPC) value defaults to the current PC (CPC) plus
+ *		  SS_INST_SIZE, as a result, only taken branches need to set
+ *		  NPC
+ *
+ *		  The following predefined macros are available for use in
+ *		  DEFINST() instruction expressions to access the value of
+ *		  instruction operand/opcode field values:
+ *
+ *		    RS	    - RS register field value
+ *		    RT	    - RT register field value
+ *		    RD	    - RD register field value
+ *		    FS	    - RS register field value
+ *		    FT	    - RT register field value
+ *		    FD	    - RD register field value
+ *		    BS	    - RS register field value
+ *		    TARG    - jump target field value
+ *		    OFS	    - signed offset field value
+ *		    IMM	    - signed offset field value
+ *		    UIMM    - unsigned offset field value
+ *		    SHAMT   - shift amount field value
+ *		    BCODE   - break code field value
+ *
+ *		  To facilitate the construction of performance simulators
+ *		  (which may want to specialize their architected state
+ *		  storage format), all architected register and memory state
+ *		  is accessed through the following macros:
+ *
+ *		    GPR(N)         - read general purpose register N
+ *		    SET_GPR(N,E)   - write general purpose register N with E
+ *		    GPR_D(N)       - read double word general purpose reg N
+ *		    SET_GPR_D(N,E) - write double word gen purpose reg N w/ E
+ *		    FPR_L(N)       - read floating-point register N, as word
+ *		    SET_FPR_L(N,E) - floating-point reg N, as word, with E
+ *		    FPR_F(N)       - read FP reg N, as single-prec float
+ *		    SET_FPR_F(N,E) - write FP reg N, as single-prec float w/ E
+ *		    FPR_D(N)       - read FP reg N, as double-prec double
+ *		    SET_FPR_D(N,E) - write FP reg N, as double-prec double w/E
+ *		    HI	           - read HI result register
+ *		    SET_HI(E)      - write HI result register with E
+ *		    LO	           - read LO result register
+ *		    SET_LO(E)      - write LO result register with E
+ *		    FCC	           - read floating point condition codes
+ *		    SET_FCC(E)     - write floating point condition codes w/ E
+ *		    CPC	           - read current PC register
+ *		    NPC	           - read next PC register
+ *		    SET_NPC(E)     - write next PC register with E
+ *		    TPC	           - read target PC register
+ *		    SET_TPC(E)     - write target PC register with E
+ *
+ *		    READ_SIGNED_BYTE(A)   - read signed byte from address A
+ *		    READ_UNSIGNED_BYTE(A) - read unsigned byte from address A
+ *		    READ_SIGNED_HALF(A)   - read signed half from address A
+ *		    READ_UNSIGNED_HALF(A) - read unsigned half from address A
+ *		    READ_WORD(A)          - read word from address A
+ *		    WRITE_BYTE(E,A)       - write byte value E to address A
+ *		    WRITE_HALF(E,A)       - write half value E to address A
+ *		    WRITE_WORD(E,A)       - write word value E to address A
+ *
+ *		  Finally, the following helper functions are available to
+ *		  assist in the construction of instruction expressions:
+ *
+ *		    INC_DEC(E,N,S) - execute E and update N as per pre/post-
+ *				     incr/decr addressing sementics for an
+ *				     access of S bytes
+ *		    OVER(X,Y)      - check for overflow for X+Y, both signed
+ *		    UNDER(X,Y)	   - check for umderflow for X-Y, both signed
+ *		    DIV0(N)	   - check for divide by zero, N is denom
+ *		    INTALIGN(N)    - check double word int reg N alignment
+ *		    FPALIGN(N)	   - check double word FP reg N alignment
+ *		    TALIGN(T)	   - check jump target T alignment
+ */
+
+#if 0
+/* TOP LEVEL decode table */
+DEFLINK(TOPLEV, 0x00, "toplev", 24, 0x0f)
+CONNECT(TOPLEV)
+#endif
+
+/* most simulators ignore the UOP definitions */
+#ifndef DEFUOP
+#define DEFUOP(OP,NAME,OPFORM,RES,FLAGS,O1,O2,O3,I1,I2,I3,I4)
+#endif /* !DEFUOP */
+     
+/* funky PC semantics macros */
+#define GPR_SH(N)	(((N) != 15) ? GPR(N) : (GPR(15)+(SHIFT_REG ? 12 : 8)))
+#define GPR_EX(N)	(((N) != 15) ? GPR(N) : (GPR(15)+8))
+#define GPR_MEM(N)	(((N) != 15) ? GPR(N) : (GPR(15)+12))
+#define GPR_BASE(N)	(((N) != 15)					\
+			 ? (((N) == (RN) && !_first) ? _wbaddr : GPR(N))\
+			 : (GPR(15)+12))
+#define GPR_RES(N)	(((N) == (RD)) ? _result : GPR(N))
+
+/* dependence helper macros */
+#define DCOND		(((COND) == COND_AL) ? DNA : DPSR)
+#define DCONDSH		(((COND) == COND_AL)				\
+			 ? (((SHIFT_BITS) == 0) ? DNA : DPSR)		\
+			 : DPSR)
+#define DSHRS(RS)	(((SHIFT_BITS) == 0) ? DNA : DGPR(RS))
+
+
+DEFLINK(ALUREG0_LINK, 0x00, "alureg0_link", 4, 0x0f)
+
+DEFLINK(ALUREG1_LINK, 0x01, "alureg1_link", 4, 0x0f)
+
+DEFLINK(ALUIMM0_LINK, 0x02, "aluimm0_link", 20, 0x0f)
+
+DEFLINK(ALUIMM1_LINK, 0x03, "aluimm1_link", 20, 0x0f)
+
+DEFLINK(MEMIMMPOST_LINK, 0x04, "memimmpost_link", 20, 0x0f)
+
+DEFLINK(MEMIMMPRE_LINK, 0x05, "memimmpre_link", 20, 0x0f)
+
+DEFLINK(MEMREGPOST_LINK, 0x06, "memregpost_link", 20, 0x0f)
+
+DEFLINK(MEMREGPRE_LINK, 0x07, "memregpre_link", 20, 0x0f)
+
+DEFLINK(BLKPOST_LINK, 0x08, "blkpost_link", 20, 0x0f)
+
+DEFLINK(BLKPRE_LINK, 0x09, "blkpre_link", 20, 0x0f)
+
+#define BR_IMPL								\
+  {									\
+    SET_TPC(CPC + BOFS + 8);						\
+									\
+    if (COND_VALID(PSR))						\
+      {									\
+	SET_NPC(CPC + BOFS + 8);					\
+      }									\
+  }
+DEFINST(BR,			0x0a,
+	"b%c",			"%j",
+	IntALU,			F_CTRL|F_DIRJMP,
+	DNA, DNA, DNA,		DCOND, DNA, DNA, DNA)
+
+#define BRL_IMPL							\
+  {									\
+    SET_TPC(CPC + BOFS + 8);						\
+									\
+    if (COND_VALID(PSR))						\
+      {									\
+	SET_NPC(CPC + BOFS  + 8);					\
+	SET_GPR(14, CPC + 4);						\
+      }									\
+  }
+DEFINST(BRL,			0x0b,
+	"bl%c",			"%j",
+	IntALU,			F_CTRL|F_DIRJMP,
+	DGPR(14), DNA, DNA,	DCOND, DNA, DNA, DNA)
+
+DEFLINK(CDXPOST_LINK, 0x0c, "cdxpost_link", 8, 0x0f)
+
+DEFLINK(CDXPRE_LINK, 0x0d, "cdxpre_link", 8, 0x0f)
+
+DEFLINK(CPROC_LINK, 0x0e, "cproc_link", 8, 0x0f)
+
+#define SWI_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	SYSCALL(inst);							\
+      }									\
+  }
+DEFINST(SWI,			0x0f,
+	"swi%c",		"%S",
+	NA,			F_TRAP,
+	DNA, DNA, DNA,		DCOND, DNA, DNA, DNA)
+
+
+CONNECT(ALUREG0_LINK)
+
+DEFLINK(ALUREG0a_LINK, 0x0f00, "alureg0a_link", 20, 0x0f)
+
+/* FIXME: 0x00 is SWP */
+DEFLINK(MUL_LINK, 0x09, "mul_link", 20, 0x0f)
+
+DEFLINK(LDRHSTRH_LINK, 0x0b, "ldrhstrh_link", 20, 0x0f)
+
+DEFLINK(LDRSBSTRSB_LINK, 0x0d, "ldrsbstrsb_link", 20, 0x0f)
+
+DEFLINK(LDRSHSTRSH_LINK, 0x0f, "ldrshstrsh_link", 20, 0x0f)
+
+
+CONNECT(ALUREG1_LINK)
+
+DEFLINK(ALUREG1a_LINK, 0x0f00, "alureg1a_link", 20, 0x0f)
+
+/* FIXME: 0x00 is SWP */
+
+
+DEFLINK(LDRH_PSTRH_P_LINK, 0x0b, "ldrh_pstrh_p_link", 20, 0x0f)
+
+DEFLINK(LDRSB_PSTRSB_P_LINK, 0x0d, "ldrsb_pstrsb_p_link", 20, 0x0f)
+
+DEFLINK(LDRSH_PSTRSH_P_LINK, 0x0f, "ldrsh_pstrsh_p_link", 20, 0x0f)
+
+
+CONNECT(ALUREG0a_LINK)
+
+#define AND_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	SET_GPR(RD, GPR_SH(RN) & SHIFTRM(GPR_SH(RM), GPR(RS), PSR_C));	\
+      }									\
+  }
+DEFINST(AND,			0x00,
+	"and%c",		"%d,%n,%m",
+	IntALU,			F_ICOMP,
+	DGPR(RD), DNA, DNA,	DCONDSH, DGPR(RN), DGPR(RM), DSHRS(RS))
+
+#define ANDS_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	word_t _result;							\
+									\
+	_result = GPR_SH(RN) & SHIFTRM(GPR_SH(RM), GPR(RS), PSR_C);	\
+	SET_PSR_C(SHIFTC(GPR_SH(RM), GPR(RS), PSR_C));			\
+	SET_PSR_N((sword_t)_result < 0);				\
+	SET_PSR_Z(_result == 0);					\
+        SET_GPR_RI(RD, _result);						\
+      }									\
+  }
+DEFINST(ANDS,			0x01,
+	"and%cs",		"%d,%n,%m",
+	IntALU,			F_ICOMP,
+	DGPR(RD), DPSR, DNA,	DPSR, DGPR(RN), DGPR(RM), DSHRS(RS))
+
+#define EOR_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	SET_GPR(RD, GPR_SH(RN) ^ SHIFTRM(GPR_SH(RM), GPR(RS), PSR_C));	\
+      }									\
+  }
+DEFINST(EOR,			0x02,
+	"eor%c",		"%d,%n,%m",
+	IntALU,			F_ICOMP,
+	DGPR(RD), DNA, DNA,	DCONDSH, DGPR(RN), DGPR(RM), DSHRS(RS))
+
+#define EORS_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	word_t _result;							\
+									\
+	_result = GPR_SH(RN) ^ SHIFTRM(GPR_SH(RM), GPR(RS), PSR_C);	\
+	SET_PSR_C(SHIFTC(GPR_SH(RM), GPR(RS), PSR_C));			\
+	SET_PSR_N((sword_t)_result < 0);				\
+	SET_PSR_Z(_result == 0);					\
+        SET_GPR_RI(RD, _result);						\
+      }									\
+  }
+DEFINST(EORS,			0x03,
+	"eor%cs",		"%d,%n,%m",
+	IntALU,			F_ICOMP,
+	DGPR(RD), DPSR, DNA,	DPSR, DGPR(RN), DGPR(RM), DSHRS(RS))
+
+#define SUB_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+        SET_GPR(RD, GPR_SH(RN) - SHIFTRM(GPR_SH(RM), GPR(RS), PSR_C));	\
+      }									\
+  }
+DEFINST(SUB,			0x04,
+	"sub%c",		"%d,%n,%m",
+	IntALU,			F_ICOMP,
+	DGPR(RD), DNA, DNA,	DCONDSH, DGPR(RN), DGPR(RM), DSHRS(RS))
+
+#define SUBS_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	/* FIXME: should this be GPR_SH? following the ARMulator */	\
+        word_t _lhs = GPR_EX(RN);					\
+	word_t _rhs = SHIFTRM(GPR_SH(RM), GPR(RS), PSR_C);		\
+        word_t _result = _lhs - _rhs;					\
+									\
+        SET_PSR_N((sword_t)_result < 0);				\
+        SET_PSR_Z(_result == 0);					\
+        SET_PSR_C(SUBC(_lhs, _rhs, _result));				\
+        SET_PSR_V(SUBV(_lhs, _rhs, _result));				\
+        SET_GPR_RI(RD, _result);						\
+      }									\
+  }
+DEFINST(SUBS,			0x05,
+	"sub%cs",		"%d,%n,%m",
+	IntALU,			F_ICOMP,
+	DGPR(RD), DPSR, DNA,	DCONDSH, DGPR(RN), DGPR(RM), DSHRS(RS))
+
+#define RSB_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+        SET_GPR(RD, SHIFTRM(GPR_SH(RM), GPR(RS), PSR_C) - GPR_SH(RN));	\
+      }									\
+  }
+DEFINST(RSB,			0x06,
+	"rsb%c",		"%d,%n,%m",
+	IntALU,			F_ICOMP,
+	DGPR(RD), DNA, DNA,	DCONDSH, DGPR(RN), DGPR(RM), DSHRS(RS))
+
+#define RSBS_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	/* FIXME: should this be GPR_SH? following the ARMulator */	\
+        word_t _lhs = GPR_EX(RN);					\
+	word_t _rhs = SHIFTRM(GPR_SH(RM), GPR(RS), PSR_C);		\
+        word_t _result = _rhs - _lhs;					\
+									\
+	SET_PSR_N((sword_t)_result < 0);				\
+	SET_PSR_Z(_result == 0);					\
+	SET_PSR_C(SUBC(_rhs, _lhs, _result));				\
+	SET_PSR_V(SUBV(_rhs, _lhs, _result));				\
+	SET_GPR_RI(RD, _result);						\
+      }									\
+  }
+DEFINST(RSBS,			0x07,
+	"rsb%cs",		"%d,%n,%m",
+	IntALU,			F_ICOMP,
+	DGPR(RD), DPSR, DNA,	DCONDSH, DGPR(RN), DGPR(RM), DSHRS(RS))
+
+#define ADD_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+        SET_GPR(RD, GPR_SH(RN) + SHIFTRM(GPR_SH(RM), GPR(RS), PSR_C));	\
+      }									\
+  }
+DEFINST(ADD,			0x08,
+	"add%c",		"%d,%n,%m",
+	IntALU,			F_ICOMP,
+	DGPR(RD), DNA, DNA,	DCONDSH, DGPR(RN), DGPR(RM), DSHRS(RS))
+
+#define ADDS_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	/* FIXME: should this be GPR_SH? following the ARMulator */	\
+	word_t _lhs = GPR_EX(RN);					\
+	word_t _rhs = SHIFTRM(GPR_SH(RM), GPR(RS), PSR_C);		\
+	word_t _result = _lhs + _rhs;					\
+									\
+	SET_PSR_N((sword_t)_result < 0);				\
+	SET_PSR_Z(_result == 0);					\
+	SET_PSR_C(ADDC(_lhs, _rhs, _result));				\
+	SET_PSR_V(ADDV(_lhs, _rhs, _result));				\
+	SET_GPR_RI(RD, _result);						\
+      }									\
+  }
+DEFINST(ADDS,			0x09,
+	"adds%c",		"%d,%n,%m",
+	IntALU,			F_ICOMP,
+	DGPR(RD), DPSR, DNA,	DCONDSH, DGPR(RN), DGPR(RM), DSHRS(RS))
+
+#define ADC_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+        SET_GPR(RD, GPR_SH(RN) + SHIFTRM(GPR_SH(RM), GPR(RS), PSR_C) + PSR_C);\
+      }									\
+  }
+DEFINST(ADC,			0x0a,
+	"adc%c",		"%d,%n,%m",
+	IntALU,			F_ICOMP,
+	DGPR(RD), DNA, DNA,	DPSR, DGPR(RN), DGPR(RM), DSHRS(RS))
+
+#define ADCS_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	/* FIXME: should this be GPR_SH? following the ARMulator */	\
+	word_t _lhs = GPR_EX(RN);					\
+	word_t _rhs = SHIFTRM(GPR_SH(RM), GPR(RS), PSR_C);		\
+	word_t _result = _lhs + _rhs + PSR_C;				\
+									\
+	SET_PSR_N((sword_t)_result < 0);				\
+	SET_PSR_Z(_result == 0);					\
+	SET_PSR_C(ADDC(_lhs, _rhs, _result));				\
+	SET_PSR_V(ADDV(_lhs, _rhs, _result));				\
+	SET_GPR_RI(RD, _result);						\
+      }									\
+  }
+DEFINST(ADCS,			0x0b,
+	"adc%cs",		"%d,%n,%m",
+	IntALU,			F_ICOMP,
+	DGPR(RD), DPSR, DNA,	DPSR, DGPR(RN), DGPR(RM), DSHRS(RS))
+
+#define SBC_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+        SET_GPR(RD, GPR_SH(RN) - SHIFTRM(GPR_SH(RM), GPR(RS), PSR_C)-!PSR_C);\
+      }									\
+  }
+DEFINST(SBC,			0x0c,
+	"sbc%c",		"%d,%n,%m",
+	IntALU,			F_ICOMP,
+	DGPR(RD), DNA, DNA,	DPSR, DGPR(RN), DGPR(RM), DSHRS(RS))
+
+#define SBCS_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	/* FIXME: should this be GPR_SH? following the ARMulator */	\
+	word_t _lhs = GPR_EX(RN);					\
+	word_t _rhs = SHIFTRM(GPR_SH(RM), GPR(RS), PSR_C);		\
+	word_t _result = _lhs - _rhs - !PSR_C;				\
+									\
+    SET_PSR_N((sword_t)_result < 0);				\
+    SET_PSR_Z(_result == 0);					\
+    SET_PSR_C(SUBC(_lhs, _rhs, _result));				\
+    SET_PSR_V(SUBV(_lhs, _rhs, _result));				\
+	SET_GPR_RI(RD, _result);						\
+      }									\
+  }
+DEFINST(SBCS,			0x0d,
+	"sbc%cs",		"%d,%n,%m",
+	IntALU,			F_ICOMP,
+	DGPR(RD), DPSR, DNA,	DPSR, DGPR(RN), DGPR(RM), DSHRS(RS))
+
+#define RSC_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+        SET_GPR(RD, SHIFTRM(GPR_SH(RM), GPR(RS), PSR_C) - GPR_SH(RN)-!PSR_C);\
+      }									\
+  }
+DEFINST(RSC,			0x0e,
+	"rsc%c",		"%d,%n,%m",
+	IntALU,			F_ICOMP,
+	DGPR(RD), DNA, DNA,	DPSR, DGPR(RN), DGPR(RM), DSHRS(RS))
+
+#define RSCS_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	/* FIXME: should this be GPR_SH? following the ARMulator */	\
+	word_t _lhs = GPR_EX(RN);					\
+	word_t _rhs = SHIFTRM(GPR_SH(RM), GPR(RS), PSR_C);		\
+	word_t _result = _rhs - _lhs - !PSR_C;				\
+									\
+        SET_PSR_N((sword_t)_result < 0);				\
+        SET_PSR_Z(_result == 0);					\
+        SET_PSR_C(SUBC(_rhs, _lhs, _result));				\
+        SET_PSR_V(SUBV(_rhs, _lhs, _result));				\
+	SET_GPR_RI(RD, _result);						\
+      }									\
+  }
+DEFINST(RSCS,			0x0f,
+	"rsc%cs",		"%d,%n,%m",
+	IntALU,			F_ICOMP,
+	DGPR(RD), DPSR, DNA,	DPSR, DGPR(RN), DGPR(RM), DSHRS(RS))
+
+
+CONNECT(ALUREG1a_LINK)
+
+DEFLINK(SWPMRS_LINK, 0x00, "swpmrs_link", 4, 0xff)
+
+#define TSTS_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	word_t _result = GPR_SH(RN) & SHIFTRM(GPR_SH(RM), GPR(RS), PSR_C);\
+						                        \
+	SET_PSR_C(SHIFTC(GPR_SH(RM), GPR(RS), PSR_C));			\
+	SET_PSR_N((sword_t)_result < 0);				\
+	SET_PSR_Z(_result == 0);					\
+      }									\
+  }
+DEFINST(TSTS,			0x01,
+	"tst%cs",		"%n,%m",
+	IntALU,			F_ICOMP,
+	DPSR, DPSR, DNA,	DPSR, DGPR(RN), DGPR(RM), DSHRS(RS))
+
+
+#define MSR_CPSR_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+        do_msr ( RM , CPC , GPR(RM) , inst ) ; \
+      }									\
+  }
+DEFINST(MSR_CPSR,		0x02,
+	"msr",			"cpsr,%d",
+	IntALU,			F_ICOMP,
+	DPSR, DGPR(13), DGPR(14),		DCOND, DGPR(13), DGPR(14), DGPR(RM) )
+
+#define TEQS_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	word_t _result = GPR_SH(RN) ^ SHIFTRM(GPR_SH(RM), GPR(RS), PSR_C);\
+									\
+	SET_PSR_C(SHIFTC(GPR_SH(RM), GPR(RS), PSR_C));			\
+	SET_PSR_N((sword_t)_result < 0);				\
+	SET_PSR_Z(_result == 0);					\
+      }									\
+  }
+DEFINST(TEQS,			0x03,
+	"teq%cs",		"%n,%m",
+	IntALU,			F_ICOMP,
+	DPSR, DPSR, DNA,	DPSR, DGPR(RN), DGPR(RM), DSHRS(RS))
+
+DEFLINK(MRSSWP_LINK, 0x04, "mrsswp_link", 4, 0xff)
+
+#define CMPS_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	/* FIXME: should this be GPR_SH? following the ARMulator */	\
+	word_t _lhs = GPR_EX(RN);					\
+	word_t _rhs = SHIFTRM(GPR_SH(RM), GPR(RS), PSR_C);		\
+	word_t _result = _lhs - _rhs;					\
+									\
+	SET_PSR_N((sword_t)_result < 0);				\
+	SET_PSR_Z(_result == 0);					\
+	SET_PSR_C(SUBC(_lhs, _rhs, _result));				\
+	SET_PSR_V(SUBV(_lhs, _rhs, _result));				\
+      }									\
+  }
+DEFINST(CMPS,			0x05,
+	"cmp%c",		"%n,%m",
+	IntALU,			F_ICOMP,
+	DPSR, DPSR, DNA,	DCONDSH, DGPR(RN), DGPR(RM), DSHRS(RS))
+
+#define MSR_SPSR_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+        do_msr ( RM , CPC , GPR(RM) , inst ) ; \
+      }									\
+  }
+DEFINST(MSR_SPSR,		0x06,
+	"msr",			"spsr,%m",
+	IntALU,			F_ICOMP,
+	DPSR, DGPR(13), DGPR(14),		DCOND, DGPR(RM), DGPR(13), DGPR(14))
+
+#define CMNS_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	/* FIXME: should this be GPR_SH? following the ARMulator */	\
+	word_t _lhs = GPR_EX(RN);					\
+	word_t _rhs = SHIFTRM(GPR_SH(RM), GPR(RS), PSR_C);		\
+	word_t _result = _lhs + _rhs;					\
+									\
+	SET_PSR_N((sword_t)_result < 0);				\
+	SET_PSR_Z(_result == 0);					\
+	SET_PSR_C(ADDC(_lhs, _rhs, _result));				\
+	SET_PSR_V(ADDV(_lhs, _rhs, _result));				\
+      }									\
+  }
+DEFINST(CMNS,			0x07,
+	"cmn%c",		"%n,%m",
+	IntALU,			F_ICOMP,
+	DPSR, DPSR, DNA,	DCONDSH, DGPR(RN), DGPR(RM), DSHRS(RS))
+
+#define ORR_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	SET_GPR(RD, GPR_SH(RN) | SHIFTRM(GPR_SH(RM), GPR(RS), PSR_C));	\
+      }									\
+  }
+DEFINST(ORR,			0x08,
+	"orr%c",		"%d,%n,%m",
+	IntALU,			F_ICOMP,
+	DGPR(RD), DNA, DNA,	DCONDSH, DGPR(RN), DGPR(RM), DSHRS(RS))
+
+#define ORRS_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	word_t _result;							\
+									\
+	_result = GPR_SH(RN) | SHIFTRM(GPR_SH(RM), GPR(RS), PSR_C);	\
+									\
+	SET_PSR_C(SHIFTC(GPR_SH(RM), GPR(RS), PSR_C));			\
+	SET_PSR_N((sword_t)_result < 0);				\
+	SET_PSR_Z(_result == 0);					\
+        SET_GPR_RI(RD, _result);						\
+      }									\
+  }
+DEFINST(ORRS,			0x09,
+	"orr%cs",		"%d,%n,%m",
+	IntALU,			F_ICOMP,
+	DGPR(RD), DPSR, DNA,	DPSR, DGPR(RN), DGPR(RM), DSHRS(RS))
+
+#define MOV_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	SET_GPR(RD, SHIFTRM(GPR_SH(RM), GPR(RS), PSR_C));		\
+      }									\
+  }
+DEFINST(MOV,			0x0a,
+	"mov%c",		"%d,%m",
+	IntALU,			F_ICOMP,
+	DGPR(RD), DNA, DNA,	DCONDSH, DGPR(RM), DSHRS(RS), DNA)
+
+#define MOVS_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	word_t _result;							\
+									\
+	_result = SHIFTRM(GPR_SH(RM), GPR(RS), PSR_C);			\
+									\
+	SET_PSR_C(SHIFTC(GPR_SH(RM), GPR(RS), PSR_C));			\
+	SET_PSR_N((sword_t)_result < 0);				\
+	SET_PSR_Z(_result == 0);					\
+        SET_GPR_RI(RD, _result);						\
+      }									\
+  }
+DEFINST(MOVS,			0x0b,
+	"mov%cs",		"%d,%m",
+	IntALU,			F_ICOMP,
+	DGPR(RD), DPSR, DNA,	DPSR, DGPR(RM), DSHRS(RS), DNA)
+
+#define BIC_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	SET_GPR(RD, GPR_SH(RN) & ~SHIFTRM(GPR_SH(RM), GPR(RS), PSR_C));	\
+      }									\
+  }
+DEFINST(BIC,			0x0c,
+	"bic%c",		"%d,%n,%m",
+	IntALU,			F_ICOMP,
+	DGPR(RD), DNA, DNA,	DCONDSH, DGPR(RN), DGPR(RM), DSHRS(RS))
+
+#define BICS_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	word_t _result;							\
+									\
+	_result = GPR_SH(RN) & ~SHIFTRM(GPR_SH(RM), GPR(RS), PSR_C);	\
+									\
+	SET_PSR_C(SHIFTC(GPR_SH(RM), GPR(RS), PSR_C));			\
+	SET_PSR_N((sword_t)_result < 0);				\
+	SET_PSR_Z(_result == 0);					\
+        SET_GPR_RI(RD, _result);						\
+      }									\
+  }
+DEFINST(BICS,			0x0d,
+	"bic%cs",		"%d,%n,%m",
+	IntALU,			F_ICOMP,
+	DGPR(RD), DPSR, DNA,	DPSR, DGPR(RN), DGPR(RM), DSHRS(RS))
+
+#define MVN_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	SET_GPR(RD, ~SHIFTRM(GPR_SH(RM), GPR(RS), PSR_C));		\
+      }									\
+  }
+DEFINST(MVN,			0x0e,
+	"mvn%c",		"%d,%m",
+	IntALU,			F_ICOMP,
+	DGPR(RD), DNA, DNA,	DCONDSH, DGPR(RM), DSHRS(RS), DNA)
+
+#define MVNS_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	word_t _result;							\
+									\
+	_result = ~SHIFTRM(GPR_SH(RM), GPR(RS), PSR_C);			\
+									\
+	SET_PSR_C(SHIFTC(GPR_SH(RM), GPR(RS), PSR_C));			\
+	SET_PSR_N((sword_t)_result < 0);				\
+	SET_PSR_Z(_result == 0);					\
+        SET_GPR_RI(RD, _result);						\
+      }									\
+  }
+DEFINST(MVNS,			0x0f,
+	"mvn%cs",		"%d,%m",
+	IntALU,			F_ICOMP,
+	DGPR(RD), DPSR, DNA,	DPSR, DGPR(RM), DSHRS(RS), DNA)
+
+
+CONNECT(SWPMRS_LINK)
+
+#define MRS_CPSR_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+              SET_GPR(RD,PSR); \
+      }									\
+  }
+
+DEFINST(MRS_CPSR, 0,
+	"mrs",			"%d, cpsr",
+	IntALU,			F_ICOMP,
+	DGPR(RD), DNA, DNA,	DCOND, DPSR, DNA, DNA) 
+
+#if 0
+#define TST_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	/* test but don't set flags, nada... */				\
+      }									\
+  }
+DEFINST(TST,			0xff00,
+	"tst%c",		"%n,%m",
+	IntALU,			F_ICOMP,
+	DNA, DNA, DNA,		DCOND, DNA, DNA, DNA)
+#endif
+
+#define SWP_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	/* FIXME: todo... */						\
+	DECLARE_FAULT(md_fault_unimpl);					\
+      }									\
+  }
+DEFINST(SWP,			0x09,
+	"swp%c",		"%d,%w,%s,%n",
+	IntMULT,		F_ICOMP,
+	DNA, DNA, DNA,		DCOND, DNA, DNA, DNA)
+
+
+
+
+CONNECT(MRSSWP_LINK)
+
+
+#define MRS_SPSR_IMPL							\
+    {    \
+        if (COND_VALID(PSR)) \
+        {									\
+              SET_GPR(RD,SPSR);             \
+        }									\
+    }
+DEFINST(MRS_SPSR,	0,
+  	"mrs",			"%d, spsr",
+  	IntALU,			F_ICOMP,
+  	DGPR(RD), DNA, DNA,	DCOND, DPSR, DNA, DNA)
+
+#if 0
+#define CMP_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	/* compare but don't set flags, nada... */			\
+      }									\
+  }
+DEFINST(CMP,			0xff00,
+	"cmp%c",		"%n,%m",
+	IntALU,			F_ICOMP,
+	DNA, DNA, DNA,		DCOND, DNA, DNA, DNA)
+#endif
+
+#define SWP1_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	/* FIXME: todo... */						\
+	DECLARE_FAULT(md_fault_unimpl);					\
+      }									\
+  }
+DEFINST(SWP1,			0x09,
+	"swp%c",		"%d,%w,%s,%n",
+	IntMULT,		F_ICOMP,
+	DNA, DNA, DNA,		DCOND, DNA, DNA, DNA)
+
+
+
+
+CONNECT(ALUIMM0_LINK)
+
+#define ANDI_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	SET_GPR(RD, GPR_EX(RN) & ROTR(ROTIMM,  ROTAMT << 1));		\
+      }									\
+  }
+DEFINST(ANDI,			0x00,
+	"and%c",		"%d,%n,#%i",
+	IntALU,			F_ICOMP,
+	DGPR(RD), DNA, DNA,	DCOND, DGPR(RN), DNA, DNA)
+
+#define ANDSI_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	word_t _result;							\
+        word_t _imm = ROTR(ROTIMM,  ROTAMT << 1);                       \
+									\
+	_result = GPR_EX(RN) & ROTR(ROTIMM,  ROTAMT << 1);		\
+        if (ROTAMT != 0)                                                \
+          SET_PSR_C((_imm >> 31) & 1);                                  \
+	SET_PSR_N((sword_t)_result < 0);				\
+	SET_PSR_Z(_result == 0);					\
+        SET_GPR_RI(RD, _result);						\
+      }									\
+  }
+DEFINST(ANDSI,			0x01,
+	"and%cs",		"%d,%n,#%i",
+	IntALU,			F_ICOMP,
+	DGPR(RD), DPSR, DNA,	DCOND, DGPR(RN), DNA, DNA)
+
+#define EORI_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	SET_GPR(RD, GPR_EX(RN) ^ ROTR(ROTIMM,  ROTAMT << 1));		\
+      }									\
+  }
+DEFINST(EORI,			0x02,
+	"eor%c",		"%d,%n,#%i",
+	IntALU,			F_ICOMP,
+	DGPR(RD), DNA, DNA,	DCOND, DGPR(RN), DNA, DNA)
+
+#define EORSI_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	word_t _result;							\
+        word_t _imm = ROTR(ROTIMM,  ROTAMT << 1);                       \
+									\
+	_result = GPR_EX(RN) ^ ROTR(ROTIMM,  ROTAMT << 1);		\
+        if (ROTAMT != 0)                                                \
+          SET_PSR_C((_imm >> 31) & 1);                                  \
+	SET_PSR_N((sword_t)_result < 0);				\
+	SET_PSR_Z(_result == 0);					\
+        SET_GPR_RI(RD, _result);						\
+      }									\
+  }
+DEFINST(EORSI,			0x03,
+	"eor%cs",		"%d,%n,#%i",
+	IntALU,			F_ICOMP,
+	DGPR(RD), DPSR, DNA,	DCOND, DGPR(RN), DNA, DNA)
+
+#define SUBI_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	SET_GPR(RD, GPR_EX(RN) - ROTR(ROTIMM,  ROTAMT << 1));		\
+      }									\
+  }
+DEFINST(SUBI,			0x04,
+	"sub%c",		"%d,%n,#%i",
+	IntALU,			F_ICOMP,
+	DGPR(RD), DNA, DNA,	DCOND, DGPR(RN), DNA, DNA)
+
+#define SUBSI_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+        word_t _lhs = GPR_EX(RN), _rhs = ROTR(ROTIMM,  ROTAMT << 1);	\
+        word_t _result = _lhs - _rhs;					\
+									\
+        SET_PSR_N((sword_t)_result < 0);				\
+        SET_PSR_Z(_result == 0);					\
+        SET_PSR_C(SUBC(_lhs, _rhs, _result));				\
+        SET_PSR_V(SUBV(_lhs, _rhs, _result));				\
+        SET_GPR_RI(RD, _result);						\
+      }									\
+  }
+DEFINST(SUBSI,			0x05,
+	"sub%cs",		"%d,%n,#%i",
+	IntALU,			F_ICOMP,
+	DGPR(RD), DPSR, DNA,	DCOND, DGPR(RN), DNA, DNA)
+
+#define RSBI_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	SET_GPR(RD, ROTR(ROTIMM,  ROTAMT << 1) - GPR_EX(RN));		\
+      }									\
+  }
+DEFINST(RSBI,			0x06,
+	"rsb%c",		"%d,%n,#%i",
+	IntALU,			F_ICOMP,
+	DGPR(RD), DNA, DNA,	DCOND, DGPR(RN), DNA, DNA)
+
+#define RSBSI_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+        word_t _lhs = GPR_EX(RN), _rhs = ROTR(ROTIMM,  ROTAMT << 1);	\
+        word_t _result = _rhs - _lhs;					\
+									\
+	SET_PSR_N((sword_t)_result < 0);				\
+	SET_PSR_Z(_result == 0);					\
+	SET_PSR_C(SUBC(_rhs, _lhs, _result));				\
+	SET_PSR_V(SUBV(_rhs, _lhs, _result));				\
+	SET_GPR_RI(RD, _result);						\
+      }									\
+  }
+DEFINST(RSBSI,			0x07,
+	"rsb%cs",		"%d,%n,#%i",
+	IntALU,			F_ICOMP,
+	DGPR(RD), DPSR, DNA,	DCOND, DGPR(RN), DNA, DNA)
+
+#define ADDI_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	SET_GPR(RD, GPR_EX(RN) + ROTR(ROTIMM,  ROTAMT << 1));		\
+      }									\
+  }
+DEFINST(ADDI,			0x08,
+	"add%c",		"%d,%n,#%i",
+	IntALU,			F_ICOMP,
+	DGPR(RD), DNA, DNA,	DCOND, DGPR(RN), DNA, DNA)
+
+#define ADDSI_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	word_t _lhs = GPR_EX(RN), _rhs = ROTR(ROTIMM,  ROTAMT << 1);	\
+	word_t _result = _lhs + _rhs;					\
+									\
+	SET_PSR_N((sword_t)_result < 0);				\
+	SET_PSR_Z(_result == 0);					\
+	SET_PSR_C(ADDC(_lhs, _rhs, _result));				\
+	SET_PSR_V(ADDV(_lhs, _rhs, _result));				\
+	SET_GPR_RI(RD, _result);						\
+      }									\
+  }
+DEFINST(ADDSI,			0x09,
+	"add%cs",		"%d,%n,#%i",
+	IntALU,			F_ICOMP,
+	DGPR(RD), DPSR, DNA,	DCOND, DGPR(RN), DNA, DNA)
+
+#define ADCI_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	SET_GPR(RD, GPR_EX(RN) + ROTR(ROTIMM,  ROTAMT << 1) + PSR_C);	\
+      }									\
+  }
+DEFINST(ADCI,			0x0a,
+	"adc%c",		"%d,%n,#%i",
+	IntALU,			F_ICOMP,
+	DGPR(RD), DNA, DNA,	DPSR, DGPR(RN), DNA, DNA)
+
+#define ADCSI_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	word_t _lhs = GPR_EX(RN), _rhs = ROTR(ROTIMM,  ROTAMT << 1);	\
+	word_t _result = _lhs + _rhs + PSR_C;				\
+									\
+	SET_PSR_N((sword_t)_result < 0);				\
+	SET_PSR_Z(_result == 0);					\
+	SET_PSR_C(ADDC(_lhs, _rhs, _result));				\
+	SET_PSR_V(ADDV(_lhs, _rhs, _result));				\
+	SET_GPR_RI(RD, _result);						\
+      }									\
+  }
+DEFINST(ADCSI,			0x0b,
+	"adc%cs",		"%d,%n,#%i",
+	IntALU,			F_ICOMP,
+	DGPR(RD), DPSR, DNA,	DPSR, DGPR(RN), DNA, DNA)
+
+#define SBCI_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	SET_GPR(RD, GPR_EX(RN) - ROTR(ROTIMM,  ROTAMT << 1) - !PSR_C);	\
+      }									\
+  }
+DEFINST(SBCI,			0x0c,
+	"sbc%c",		"%d,%n,#%i",
+	IntALU,			F_ICOMP,
+	DGPR(RD), DNA, DNA,	DPSR, DGPR(RN), DNA, DNA)
+
+#define SBCSI_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	word_t _lhs = GPR_EX(RN), _rhs = ROTR(ROTIMM,  ROTAMT << 1);	\
+	word_t _result = _lhs - _rhs - !PSR_C;				\
+									\
+	SET_PSR_N((sword_t)_result < 0);				\
+	SET_PSR_Z(_result == 0);					\
+	SET_PSR_C(SUBC(_lhs, _rhs, _result));				\
+	SET_PSR_V(SUBV(_lhs, _rhs, _result));				\
+	SET_GPR_RI(RD, _result);						\
+      }									\
+  }
+DEFINST(SBCSI,			0x0d,
+	"sbc%cs",		"%d,%n,#%i",
+	IntALU,			F_ICOMP,
+	DGPR(RD), DPSR, DNA,	DPSR, DGPR(RN), DNA, DNA)
+
+#define RSCI_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	SET_GPR(RD, ROTR(ROTIMM,  ROTAMT << 1) - GPR_EX(RN) - !PSR_C);	\
+      }									\
+  }
+DEFINST(RSCI,			0x0e,
+	"rsc%c",		"%d,%n,#%i",
+	IntALU,			F_ICOMP,
+	DGPR(RD), DNA, DNA,	DPSR, DGPR(RN), DNA, DNA)
+
+#define RSCSI_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	word_t _lhs = GPR_EX(RN), _rhs = ROTR(ROTIMM,  ROTAMT << 1);	\
+	word_t _result = _rhs - _lhs - !PSR_C;				\
+									\
+	SET_PSR_N((sword_t)_result < 0);				\
+	SET_PSR_Z(_result == 0);					\
+	SET_PSR_C(SUBC(_rhs, _lhs, _result));				\
+	SET_PSR_V(SUBV(_rhs, _lhs, _result));				\
+	SET_GPR_RI(RD, _result);						\
+      }									\
+  }
+DEFINST(RSCSI,			0x0f,
+	"rsc%cs",		"%d,%n,#%i",
+	IntALU,			F_ICOMP,
+	DGPR(RD), DPSR, DNA,	DPSR, DGPR(RN), DNA, DNA)
+
+
+CONNECT(ALUIMM1_LINK)
+
+#define TSTI_IMPL							\
+  {                                                                     \
+    if (COND_VALID(PSR))						\
+      {									\
+	/* test but don't set flags, nada... */				\
+      }									\
+  }
+DEFINST(TSTI,			0x00,
+	"tst%c",		"%n,#%i",
+	IntALU,			F_ICOMP,
+	DNA, DNA, DNA,		DCOND, DNA, DNA, DNA)
+
+#define TSTSI_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+        word_t _imm = ROTR(ROTIMM,  ROTAMT << 1);                       \
+	word_t _result = GPR_EX(RN) & _imm;                    		\
+									\
+        if (ROTAMT != 0)                                                \
+          SET_PSR_C((_imm >> 31) & 1);                                  \
+  	SET_PSR_N((sword_t)_result < 0);				\
+	SET_PSR_Z((sword_t)_result == 0);				\
+      }									\
+  }
+DEFINST(TSTSI,			0x01,
+	"tst%cs",		"%n,#%i",
+	IntALU,			F_ICOMP,
+	DPSR, DNA, DNA,		DCOND, DGPR(RN), DNA, DNA)
+
+#define MSRI_CPSR_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+        do_msr ( -1 , CPC , ROTR(ROTIMM,  ROTAMT << 1) , inst );		\
+      }									\
+  }
+DEFINST(MSRI_CPSR,		0x02,
+	"msr",			"cpsr,%d",
+	IntALU,			F_ICOMP,
+	DPSR, DGPR(13), DGPR(14),		DCOND, DGPR(13), DGPR(14), DNA )
+
+#define TEQSI_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {	                                                                \
+	word_t _imm = ROTR(ROTIMM,  ROTAMT << 1);                       \
+        word_t _result = GPR_EX(RN) ^ ROTR(ROTIMM,  ROTAMT << 1);	\
+                                                                        \
+	if (ROTAMT != 0)                                                \
+          SET_PSR_C((_imm >> 31) & 1);            			\
+	SET_PSR_N((sword_t)_result < 0);				\
+	SET_PSR_Z(_result == 0);					\
+      }									\
+  }
+DEFINST(TEQSI,			0x03,
+	"teq%cs",		"%n,#%i",
+	IntALU,			F_ICOMP,
+	DPSR, DNA, DNA,		DCOND, DGPR(RN), DNA, DNA)
+
+#define CMPI_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	/* compare but don't set flags, nada... */			\
+      }									\
+  }
+DEFINST(CMPI,			0x04,
+	"cmp%c",		"%n,#%i", 
+	IntALU,			F_ICOMP,
+	DNA, DNA, DNA,		DCOND, DNA, DNA, DNA)
+
+#define CMPSI_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	word_t _lhs = GPR_EX(RN), _rhs = ROTR(ROTIMM,  ROTAMT << 1);	\
+	word_t _result = _lhs - _rhs;					\
+									\
+	SET_PSR_N((sword_t)_result < 0);				\
+	SET_PSR_Z(_result == 0);					\
+	SET_PSR_C(SUBC(_lhs, _rhs, _result));				\
+	SET_PSR_V(SUBV(_lhs, _rhs, _result));				\
+      }									\
+  }
+DEFINST(CMPSI,			0x05,
+	"cmp%c",		"%n,#%i",
+	IntALU,			F_ICOMP,
+	DPSR, DNA, DNA,		DCOND, DGPR(RN), DNA, DNA)
+
+
+#define MSRI_SPSR_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+        do_msr ( -1 , CPC , ROTR(ROTIMM,  ROTAMT << 1) , inst );		\
+      }									\
+  }
+DEFINST(MSRI_SPSR,		0x06,
+	"msr",			"spsr,%d",
+	IntALU,			F_ICOMP,
+	DPSR, DGPR(13), DGPR(14),		DCOND, DGPR(13), DGPR(14), DNA )
+
+#define CMNSI_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	word_t _lhs = GPR_EX(RN), _rhs = ROTR(ROTIMM,  ROTAMT << 1);	\
+	word_t _result = _lhs + _rhs;					\
+									\
+	SET_PSR_N((sword_t)_result < 0);				\
+	SET_PSR_Z(_result == 0);					\
+	SET_PSR_C(ADDC(_lhs, _rhs, _result));				\
+	SET_PSR_V(ADDV(_lhs, _rhs, _result));				\
+      }									\
+  }
+DEFINST(CMNSI,			0x07,
+	"cmn%c",		"%n,#%i",
+	IntALU,			F_ICOMP,
+	DPSR, DNA, DNA,		DCOND, DGPR(RN), DNA, DNA)
+
+#define ORRI_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	SET_GPR(RD, GPR_EX(RN) | ROTR(ROTIMM,  ROTAMT << 1));		\
+      }									\
+  }
+DEFINST(ORRI,			0x08,
+	"orr%c",		"%d,%n,#%i",
+	IntALU,			F_ICOMP,
+	DGPR(RD), DNA, DNA,	DCOND, DGPR(RN), DNA, DNA)
+
+#define ORRSI_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	word_t _result;							\
+	word_t _imm = ROTR(ROTIMM,  ROTAMT << 1);                       \
+								        \
+	_result = GPR_EX(RN) | ROTR(ROTIMM,  ROTAMT << 1);		\
+        if (ROTAMT != 0)                                                \
+          SET_PSR_C((_imm >> 31) & 1);                                  \
+	SET_PSR_N((sword_t)_result < 0);				\
+	SET_PSR_Z(_result == 0);					\
+        SET_GPR_RI(RD, _result);						\
+      }									\
+  }
+DEFINST(ORRSI,			0x09,
+	"orr%cs",		"%d,%n,#%i",
+	IntALU,			F_ICOMP,
+	DGPR(RD), DPSR, DNA,	DCOND, DGPR(RN), DNA, DNA)
+
+#define MOVI_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	SET_GPR(RD, ROTR(ROTIMM,  ROTAMT << 1));			\
+      }									\
+  }
+DEFINST(MOVI,			0x0a,
+	"mov%c",		"%d,#%i",
+	IntALU,			F_ICOMP,
+	DGPR(RD), DNA, DNA,	DCOND, DNA, DNA, DNA)
+
+#define MOVSI_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	word_t _result;							\
+        word_t _imm = ROTR(ROTIMM,  ROTAMT << 1);                       \
+									\
+	_result = ROTR(ROTIMM,  ROTAMT << 1);				\
+        if (ROTAMT != 0)                                                \
+          SET_PSR_C((_imm >> 31) & 1);                                  \
+	SET_PSR_N((sword_t)_result < 0);				\
+	SET_PSR_Z(_result == 0);					\
+        SET_GPR_RI(RD, _result);						\
+      }									\
+  }
+DEFINST(MOVSI,			0x0b,
+	"mov%cs",		"%d,#%i",
+	IntALU,			F_ICOMP,
+	DGPR(RD), DPSR, DNA,	DCOND, DNA, DNA, DNA)
+
+#define BICI_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	SET_GPR(RD, GPR_EX(RN) & ~ROTR(ROTIMM,  ROTAMT << 1));		\
+      }									\
+  }
+DEFINST(BICI,			0x0c,
+	"bic%c",		"%d,%n,#%i",
+	IntALU,			F_ICOMP,
+	DGPR(RD), DNA, DNA,	DCOND, DGPR(RN), DNA, DNA)
+
+#define BICSI_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	word_t _result;							\
+        word_t _imm = ROTR(ROTIMM,  ROTAMT << 1);                       \
+									\
+	_result = GPR_EX(RN) & ~ROTR(ROTIMM,  ROTAMT << 1);		\
+        if (ROTAMT != 0)                                                \
+          SET_PSR_C((_imm >> 31) & 1);                                  \
+	SET_PSR_N((sword_t)_result < 0);				\
+	SET_PSR_Z(_result == 0);					\
+        SET_GPR_RI(RD, _result);						\
+      }									\
+  }
+DEFINST(BICSI,			0x0d,
+	"bic%cs",		"%d,%n,#%i",
+	IntALU,			F_ICOMP,
+	DGPR(RD), DPSR, DNA,	DCOND, DGPR(RN), DNA, DNA)
+
+#define MVNI_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	SET_GPR(RD, ~ROTR(ROTIMM,  ROTAMT << 1));			\
+      }									\
+  }
+DEFINST(MVNI,			0x0e,
+	"mvn%c",		"%d,#%i",
+	IntALU,			F_ICOMP,
+	DGPR(RD), DNA, DNA,	DCOND, DNA, DNA, DNA)
+
+#define MVNSI_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	word_t _result;							\
+        word_t _imm = ROTR(ROTIMM,  ROTAMT << 1);                       \
+									\
+	_result = ~ROTR(ROTIMM,  ROTAMT << 1);				\
+        if (ROTAMT != 0)                                                \
+          SET_PSR_C((_imm >> 31) & 1);                                  \
+	SET_PSR_N((sword_t)_result < 0);				\
+	SET_PSR_Z(_result == 0);					\
+        SET_GPR_RI(RD, _result);						\
+      }									\
+  }
+DEFINST(MVNSI,			0x0f,
+	"mvn%cs",		"%d,#%i",
+	IntALU,			F_ICOMP,
+	DGPR(RD), DPSR, DNA,	DCOND, DNA, DNA, DNA)
+
+
+
+
+
+
+     /* ALL OF THE MULL INSTRUCTIONS */
+CONNECT(MUL_LINK)
+
+#define MUL_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	if ((RM) == (RN))						\
+	  {								\
+	    SET_GPR(RN, 0);						\
+	    /* FIXME: should this be "md_fault_dsteqop1"? */		\
+	    DECLARE_FAULT(md_fault_invalid);				\
+	  }								\
+	if ((RN) == MD_REG_PC)						\
+	  {								\
+	    /* FIXME: should this be "md_fault_pcdst"? */		\
+	    DECLARE_FAULT(md_fault_invalid);				\
+	  }								\
+									\
+        SET_GPR(RN, GPR(RM) * GPR(RS));					\
+      }									\
+  }
+DEFINST(MUL,			0x00,
+	"mul%c",		"%n,%w,%s",
+	IntMULT,		F_ICOMP,
+	DGPR(RN), DNA, DNA,	DCOND, DGPR(RM), DGPR(RS), DNA)
+
+#define MULS_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	word_t _result;							\
+									\
+	if ((RM) == (RN))						\
+	  {								\
+	    SET_PSR_N(0);						\
+	    SET_PSR_Z(1);						\
+	    SET_GPR(RN, 0);						\
+	    /* FIXME: should this be "md_fault_dsteqop1"? */		\
+	    DECLARE_FAULT(md_fault_invalid);				\
+	  }								\
+	if ((RN) == MD_REG_PC)						\
+	  {								\
+	    /* FIXME: should this be "md_fault_pcdst"? */		\
+	    DECLARE_FAULT(md_fault_invalid);				\
+	  }								\
+									\
+        _result = GPR(RM) * GPR(RS);					\
+	SET_PSR_N((sword_t)_result < 0);				\
+	SET_PSR_Z(_result == 0);					\
+        SET_GPR(RN, _result);						\
+      }									\
+  }
+DEFINST(MULS,			0x01,
+	"mul%cs",		"%n,%w,%s",
+	IntMULT,		F_ICOMP,
+	DGPR(RN), DPSR,	DNA,	DCOND, DGPR(RM), DGPR(RS), DNA)
+
+#define MLA_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	if ((RM) == (RN))						\
+	  {								\
+	    SET_GPR(RN, GPR(RD));					\
+	    /* FIXME: should this be "md_fault_dsteqop1"? */		\
+	    DECLARE_FAULT(md_fault_invalid);				\
+	  }								\
+	if ((RN) == MD_REG_PC)						\
+	  {								\
+	    /* FIXME: should this be "md_fault_pcdst"? */		\
+	    DECLARE_FAULT(md_fault_invalid);				\
+	  }								\
+									\
+        SET_GPR(RN, GPR(RM) * GPR(RS) + GPR(RD));			\
+      }									\
+  }
+DEFINST(MLA,			0x02,
+	"mla%c",		"%n,%w,%s,%d",
+	IntMULT,		F_ICOMP,
+	DGPR(RN), DNA, DNA,	DCOND, DGPR(RM), DGPR(RS), DGPR(RD))
+
+#define MLAS_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	word_t _result;							\
+									\
+	if ((RM) == (RN))						\
+	  {								\
+	    SET_PSR_N((sword_t)GPR(RD) < 0);				\
+	    SET_PSR_Z(GPR(RD) == 0);					\
+	    SET_GPR(RN, GPR(RD));					\
+	    /* FIXME: should this be "md_fault_dsteqop1"? */		\
+	    DECLARE_FAULT(md_fault_invalid);				\
+	  }								\
+	if ((RN) == MD_REG_PC)						\
+	  {								\
+	    /* FIXME: should this be "md_fault_pcdst"? */		\
+	    DECLARE_FAULT(md_fault_invalid);				\
+	  }								\
+									\
+        _result = GPR(RM) * GPR(RS) + GPR(RD);				\
+	SET_PSR_N((sword_t)_result < 0);				\
+	SET_PSR_Z(_result == 0);					\
+        SET_GPR(RN, _result);						\
+      }									\
+  }
+DEFINST(MLAS,			0x03,
+	"mla%cs",		"%n,%w,%s,%d",
+	IntMULT,		F_ICOMP,
+	DGPR(RN), DPSR, DNA,	DCOND, DGPR(RM), DGPR(RS), DGPR(RD))
+
+#define UMULL_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+        qword_t _result;                                                \
+                                                                        \
+    if ((RM) == (RD) || (RM) == (RN) || (RN) == (RD))		        \
+	  {								\
+	    SET_GPR(RD, 0);						\
+	    /* FIXME: should this be "md_fault_dsteqop1"? */		\
+	    DECLARE_FAULT(md_fault_invalid);				\
+	  }								\
+	if ((RD) == MD_REG_PC || (RN) == MD_REG_PC)			\
+	  {								\
+	    /* FIXME: should this be "md_fault_pcdst"? */		\
+	    DECLARE_FAULT(md_fault_invalid);				\
+	  }								\
+									\
+        _result = ((qword_t)(word_t)GPR(RM))*((qword_t)(word_t)GPR(RS));\
+        SET_GPR(RN, (word_t)(_result >> 32));				\
+        SET_GPR(RD, (word_t)_result);    				\
+      }									\
+  }
+DEFINST(UMULL,			0x08,
+	"umull%c",		"%d,%n,%w,%s",
+	IntMULT,		F_ICOMP,
+	DGPR(RD),DGPR(RN),DNA,	DCOND, DGPR(RM), DGPR(RS), DNA)
+
+#define UMULLS_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+        qword_t _result;                                                \
+                                                                        \
+    if ((RM) == (RD) || (RM) == (RN) || (RN) == (RD))		        \
+	  {								\
+	    SET_GPR(RD, 0);						\
+	    /* FIXME: should this be "md_fault_dsteqop1"? */		\
+	    DECLARE_FAULT(md_fault_invalid);				\
+	  }								\
+	if ((RD) == MD_REG_PC || (RN) == MD_REG_PC)			\
+	  {								\
+	    /* FIXME: should this be "md_fault_pcdst"? */		\
+	    DECLARE_FAULT(md_fault_invalid);				\
+	  }								\
+									\
+        _result = ((qword_t)(word_t)GPR(RM))*((qword_t)(word_t)GPR(RS));\
+	SET_PSR_N((sword_t)(!!_result) < 0);				\
+	SET_PSR_Z((!!_result) == 0);					\
+        SET_GPR(RN, (word_t)(_result >> 32));				\
+        SET_GPR(RD, (word_t)_result);    				\
+      }									\
+  }
+DEFINST(UMULLS,			0x09,
+	"umulls%c",		"%d,%n,%w,%s",
+	IntMULT,		F_ICOMP,
+	DGPR(RD),DGPR(RN),DPSR,	DCOND, DGPR(RM), DGPR(RS), DNA)
+
+#define UMLAL_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+        qword_t _result;                                                \
+                                                                        \
+    if ((RM) == (RD) || (RM) == (RN) || (RN) == (RD))		        \
+	  {								\
+	    SET_GPR(RD, 0);						\
+	    /* FIXME: should this be "md_fault_dsteqop1"? */		\
+	    DECLARE_FAULT(md_fault_invalid);				\
+	  }								\
+	if ((RD) == MD_REG_PC || (RN) == MD_REG_PC)			\
+	  {								\
+	    /* FIXME: should this be "md_fault_pcdst"? */		\
+	    DECLARE_FAULT(md_fault_invalid);				\
+	  }								\
+									\
+        _result = ((qword_t)(word_t)GPR(RM))*((qword_t)(word_t)GPR(RS));\
+        _result = _result + ((qword_t)(GPR(RN)) << 32) + ((qword_t)(word_t)GPR(RD));         \
+        SET_GPR(RN, (word_t)(_result >> 32));				\
+        SET_GPR(RD, (word_t)_result);    				\
+      }									\
+  }
+DEFINST(UMLAL,			0x0a,
+	"umlal%c",		"%d,%n,%w,%s",
+	IntMULT,		F_ICOMP,
+	DGPR(RD),DGPR(RN),DNA,	DCOND, DGPR(RM), DGPR(RS), DNA)
+
+#define UMLALS_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+        qword_t _result;                                                \
+                                                                        \
+    if ((RM) == (RD) || (RM) == (RN) || (RN) == (RD))		        \
+	  {								\
+	    SET_GPR(RD, 0);						\
+	    /* FIXME: should this be "md_fault_dsteqop1"? */		\
+	    DECLARE_FAULT(md_fault_invalid);				\
+	  }								\
+	if ((RD) == MD_REG_PC || (RN) == MD_REG_PC)			\
+	  {								\
+	    /* FIXME: should this be "md_fault_pcdst"? */		\
+	    DECLARE_FAULT(md_fault_invalid);				\
+	  }								\
+									\
+        _result = ((qword_t)(word_t)GPR(RM))*((qword_t)(word_t)GPR(RS));\
+        _result = _result + (((qword_t)(word_t)(GPR(RN))<<32)) + ((qword_t)(word_t)GPR(RD));         \
+	SET_PSR_N((sword_t)(!!_result) < 0);				\
+	SET_PSR_Z((!!_result) == 0);					\
+        SET_GPR(RN, (word_t)(_result >> 32));				\
+        SET_GPR(RD, (word_t)_result);    				\
+      }									\
+  }
+DEFINST(UMLALS,			0x0b,
+	"umlals%c",		"%d,%n,%w,%s",
+	IntMULT,		F_ICOMP,
+	DGPR(RD),DGPR(RN),DPSR,	DCOND, DGPR(RM), DGPR(RS), DNA)
+
+#define SMULL_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+        sqword_t _result;                                                \
+                                                                        \
+    if ((RM) == (RD) || (RM) == (RN) || (RN) == (RD))		        \
+	  {								\
+	    SET_GPR(RD, 0);						\
+	    /* FIXME: should this be "md_fault_dsteqop1"? */		\
+	    DECLARE_FAULT(md_fault_invalid);				\
+	  }								\
+	if ((RD) == MD_REG_PC || (RN) == MD_REG_PC)			\
+	  {								\
+	    /* FIXME: should this be "md_fault_pcdst"? */		\
+	    DECLARE_FAULT(md_fault_invalid);				\
+	  }								\
+									\
+        _result = ((sqword_t)(sword_t)GPR(RM))*((sqword_t)(sword_t)GPR(RS));\
+        SET_GPR(RN, (word_t)(_result >> 32));				\
+        SET_GPR(RD, (word_t)_result);    				\
+      }									\
+  }
+DEFINST(SMULL,			0x0c,
+	"smull%c",		"%d,%n,%w,%s",
+	IntMULT,		F_ICOMP,
+	DGPR(RD),DGPR(RN),DNA,	DCOND, DGPR(RM), DGPR(RS), DNA)
+
+#define SMULLS_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+        sqword_t _result;                                                \
+                                                                        \
+    if ((RM) == (RD) || (RM) == (RN) || (RN) == (RD))		        \
+	  {								\
+	    SET_GPR(RD, 0);						\
+	    /* FIXME: should this be "md_fault_dsteqop1"? */		\
+	    DECLARE_FAULT(md_fault_invalid);				\
+	  }								\
+	if ((RD) == MD_REG_PC || (RN) == MD_REG_PC)			\
+	  {								\
+	    /* FIXME: should this be "md_fault_pcdst"? */		\
+	    DECLARE_FAULT(md_fault_invalid);				\
+	  }								\
+									\
+        _result = ((sqword_t)(sword_t)GPR(RM))*((sqword_t)(sword_t)GPR(RS));                  \
+	SET_PSR_N((sword_t)(!!_result) < 0);				\
+	SET_PSR_Z((!!_result) == 0);					\
+        SET_GPR(RN, (word_t)(_result >> 32));				\
+        SET_GPR(RD, (word_t)_result);    				\
+      }									\
+  }
+DEFINST(SMULLS,			0x0d,
+	"smulls%c",		"%d,%n,%w,%s",
+	IntMULT,		F_ICOMP,
+	DGPR(RD),DGPR(RN),DPSR,	DCOND, DGPR(RM), DGPR(RS), DNA)
+
+#define SMLAL_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+        sqword_t _result;                                                \
+                                                                        \
+    if ((RM) == (RD) || (RM) == (RN) || (RN) == (RD))		        \
+	  {								\
+	    SET_GPR(RD, 0);						\
+	    /* FIXME: should this be "md_fault_dsteqop1"? */		\
+	    DECLARE_FAULT(md_fault_invalid);				\
+	  }								\
+	if ((RD) == MD_REG_PC || (RN) == MD_REG_PC)			\
+	  {								\
+	    /* FIXME: should this be "md_fault_pcdst"? */		\
+	    DECLARE_FAULT(md_fault_invalid);				\
+	  }								\
+									\
+        _result = ((sqword_t)(word_t)GPR(RM))*((sqword_t)(word_t)GPR(RS));\
+        _result = _result + ((sqword_t)(GPR(RN)) << 32) + ((sqword_t)(word_t)GPR(RD));         \
+        SET_GPR(RN, (word_t)(_result >> 32));				\
+        SET_GPR(RD, (word_t)_result);    				\
+      }									\
+  }
+DEFINST(SMLAL,			0x0e,
+	"smlal%c",		"%d,%n,%w,%s",
+	IntMULT,		F_ICOMP,
+	DGPR(RD),DGPR(RN),DNA,	DCOND, DGPR(RM), DGPR(RS), DNA)
+
+#define SMLALS_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+        sqword_t _result;                                                \
+                                                                        \
+    if ((RM) == (RD) || (RM) == (RN) || (RN) == (RD))		        \
+	  {								\
+	    SET_GPR(RD, 0);						\
+	    /* FIXME: should this be "md_fault_dsteqop1"? */		\
+	    DECLARE_FAULT(md_fault_invalid);				\
+	  }								\
+	if ((RD) == MD_REG_PC || (RN) == MD_REG_PC)			\
+	  {								\
+	    /* FIXME: should this be "md_fault_pcdst"? */		\
+	    DECLARE_FAULT(md_fault_invalid);				\
+	  }								\
+									\
+        _result = ((sqword_t)(word_t)GPR(RM))*((sqword_t)(word_t)GPR(RS));\
+        _result = _result + (((sqword_t)(word_t)(GPR(RN))<<32)) + ((sqword_t)(word_t)GPR(RD));         \
+	SET_PSR_N((sword_t)(!!_result) < 0);				\
+	SET_PSR_Z((!!_result) == 0);					\
+        SET_GPR(RN, (word_t)(_result >> 32));				\
+        SET_GPR(RD, (word_t)_result);    				\
+      }									\
+  }
+DEFINST(SMLALS,			0x0f,
+	"smlals%c",		"%d,%n,%w,%s",
+	IntMULT,		F_ICOMP,
+	DGPR(RD),DGPR(RN),DPSR,	DCOND, DGPR(RM), DGPR(RS), DNA)
+
+
+CONNECT(LDRHSTRH_LINK)
+
+#define STRH_R_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	md_addr_t _addr;						\
+	enum md_fault_type _fault;					\
+									\
+	WRITE_HALF((half_t)GPR_MEM(RD), GPR_EX(RN), _fault);		\
+	if (_fault != md_fault_none)					\
+	  DECLARE_FAULT(_fault);					\
+	_addr = GPR_EX(RN) - GPR(RM);					\
+									\
+	SET_GPR(RN, _addr);						\
+      }									\
+  }
+DEFINST(STRH_R,			0x00,
+	"str%ch",		"%d,[%n],-%w",
+	WrPort,			F_MEM|F_STORE|F_DISP|F_CISC,
+	DGPR(RN), DNA, DNA,	DGPR(RD), /**/DCOND, DGPR(RN), DGPR(RM))
+
+#define LDRH_RL_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	word_t _result;							\
+	md_addr_t _addr;						\
+	enum md_fault_type _fault;					\
+									\
+	_result = (word_t)READ_HALF(GPR_EX(RN), _fault);		\
+	if (_fault != md_fault_none)					\
+	  DECLARE_FAULT(_fault);					\
+	_addr = GPR_EX(RN) - GPR_RES(RM);				\
+									\
+	SET_GPR(RN, _addr);						\
+	SET_GPR(RD, _result);						\
+      }									\
+  }
+DEFINST(LDRH_RL,		0x01,
+	"ldr%ch",		"%d,[%n],-%w",
+	RdPort,			F_MEM|F_LOAD|F_DISP|F_CISC,
+	DGPR(RD),DGPR(RN),DNA,	DNA, /**/DCOND, DGPR(RN), DGPR(RM))
+
+/* FIXME: 0x02: STRH_RW is invalid, W is implied... */
+
+/* FIXME: 0x03: LDRH_RWL is invalid, W is implied... */
+
+#define STRH_O_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	md_addr_t _addr;						\
+	enum md_fault_type _fault;					\
+									\
+	WRITE_HALF((half_t)GPR_MEM(RD), GPR_SH(RN), _fault);		\
+	if (_fault != md_fault_none)					\
+	  DECLARE_FAULT(_fault);					\
+        _addr = GPR_EX(RN) - HOFS;					\
+									\
+	SET_GPR(RN, _addr);						\
+      }									\
+  }
+DEFINST(STRH_O,			0x04,
+	"str%ch",		"%d,[%n],-#%h",
+	WrPort,			F_MEM|F_STORE|F_DISP|F_CISC,
+	DGPR(RN), DNA, DNA,	DGPR(RD), /**/DCOND, DGPR(RN), DNA)
+
+#define LDRH_OL_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	half_t _result;							\
+	md_addr_t _addr;						\
+	enum md_fault_type _fault;					\
+									\
+	_result = READ_HALF(GPR_EX(RN), _fault);			\
+	if (_fault != md_fault_none)					\
+	  DECLARE_FAULT(_fault);					\
+	_addr = GPR_EX(RN) - HOFS;					\
+									\
+	SET_GPR(RN, _addr); 					        \
+	SET_GPR(RD, (word_t)_result);					\
+      }									\
+  }
+DEFINST(LDRH_OL,		0x05,
+	"ldr%ch",		"%d,[%n],-#%h",
+	RdPort,			F_MEM|F_LOAD|F_DISP|F_CISC,
+	DGPR(RD),DGPR(RN),DNA,	DNA, /**/DCOND, DGPR(RN), DNA)
+
+/* FIXME: 0x06: STRH_OW is invalid, W is implied... */
+
+/* FIXME: 0x07: LDRH_OWL is invalid, W is implied... */
+
+#define STRH_RU_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	md_addr_t _addr;						\
+	enum md_fault_type _fault;					\
+									\
+	WRITE_HALF((half_t)GPR_MEM(RD), GPR_EX(RN), _fault);		\
+	if (_fault != md_fault_none)					\
+	  DECLARE_FAULT(_fault);					\
+	_addr = GPR_EX(RN) + GPR(RM);					\
+									\
+	SET_GPR(RN, _addr);						\
+      }									\
+  }
+DEFINST(STRH_RU,		0x08,
+	"str%ch",		"%d,[%n],%w",
+	WrPort,			F_MEM|F_STORE|F_DISP|F_CISC,
+	DGPR(RN), DNA, DNA,	DGPR(RD), /**/DCOND, DGPR(RN), DGPR(RM))
+
+#define LDRH_RUL_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	word_t _result;							\
+	md_addr_t _addr;						\
+	enum md_fault_type _fault;					\
+									\
+	_result = (word_t)READ_HALF(GPR_EX(RN), _fault);		\
+	if (_fault != md_fault_none)					\
+	  DECLARE_FAULT(_fault);					\
+	_addr = GPR_EX(RN) + GPR_RES(RM);				\
+									\
+	SET_GPR(RN, _addr);						\
+	SET_GPR(RD, _result);						\
+      }									\
+  }
+DEFINST(LDRH_RUL,		0x09,
+	"ldr%ch",		"%d,[%n],%w",
+	RdPort,			F_MEM|F_LOAD|F_DISP|F_CISC,
+	DGPR(RD),DGPR(RN),DNA,	DNA, /**/DCOND, DGPR(RN), DGPR(RM))
+
+/* FIXME: 0x0a: STRH_RUW is invalid, W is implied... */
+
+/* FIXME: 0x0b: LDRH_RUWL is invalid, W is implied... */
+
+#define STRH_OU_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	md_addr_t _addr;						\
+	enum md_fault_type _fault;					\
+									\
+	WRITE_HALF((half_t)GPR_MEM(RD), GPR_EX(RN), _fault);		\
+	if (_fault != md_fault_none)					\
+	  DECLARE_FAULT(_fault);					\
+        _addr = GPR_EX(RN) + HOFS;					\
+									\
+	SET_GPR(RN, _addr);						\
+      }									\
+  }
+DEFINST(STRH_OU,		0x0c,
+	"str%ch",		"%d,[%n],#%h",
+	WrPort,			F_MEM|F_STORE|F_DISP|F_CISC,
+	DGPR(RN), DNA, DNA,	DGPR(RD), /**/DCOND, DGPR(RN), DNA)
+
+#define LDRH_OUL_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	half_t _result;							\
+	md_addr_t _addr;						\
+	enum md_fault_type _fault;					\
+									\
+	_result = READ_HALF(GPR_EX(RN), _fault);			\
+	if (_fault != md_fault_none)					\
+	  DECLARE_FAULT(_fault);					\
+        _addr = GPR_EX(RN) + HOFS;					\
+        							        \
+	SET_GPR(RN, _addr); 					        \
+	SET_GPR(RD, (word_t)_result);					\
+      }									\
+  }
+DEFINST(LDRH_OUL,		0x0d,
+	"ldr%ch",		"%d,[%n],#%h",
+	RdPort,			F_MEM|F_LOAD|F_DISP|F_CISC,
+	DGPR(RD),DGPR(RN),DNA,	DNA, /**/DCOND, DGPR(RN), DNA)
+
+/* FIXME: 0x0e: STRH_OUW is invalid, W is implied... */
+
+/* FIXME: 0x0f: LDRH_OUWL is invalid, W is implied... */
+
+
+CONNECT(LDRSBSTRSB_LINK)
+
+/* FIXME: 0x00: STRSB_R is invalid... */
+
+#define LDRSB_RL_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	word_t _result;							\
+	md_addr_t _addr;						\
+	enum md_fault_type _fault;					\
+									\
+	_result = (word_t)(sword_t)(sbyte_t)READ_BYTE(GPR_EX(RN), _fault);\
+	if (_fault != md_fault_none)					\
+	  DECLARE_FAULT(_fault);					\
+	_addr = GPR_EX(RN) - GPR_RES(RM);				\
+									\
+	SET_GPR(RN, _addr);						\
+	SET_GPR(RD, _result);						\
+      }									\
+  }
+DEFINST(LDRSB_RL,		0x01,
+	"ldr%csb",		"%d,[%n],-%w",
+	RdPort,			F_MEM|F_LOAD|F_DISP|F_CISC,
+	DGPR(RD),DGPR(RN),DNA,	DNA, /**/DCOND, DGPR(RN), DGPR(RM))
+
+/* FIXME: 0x02: STRSB_RW is invalid, W is implied... */
+
+/* FIXME: 0x03: LDRSB_RWL is invalid, W is implied... */
+
+/* FIXME: 0x04: STRSB_O is invalid... */
+
+#define LDRSB_OL_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	byte_t _result;							\
+	md_addr_t _addr;						\
+	enum md_fault_type _fault;					\
+									\
+	_result = READ_BYTE(GPR_EX(RN), _fault);			\
+	if (_fault != md_fault_none)					\
+	  DECLARE_FAULT(_fault);					\
+	_addr = GPR_EX(RN) - HOFS;					\
+									\
+	SET_GPR(RN, _addr); 				                \
+	SET_GPR(RD, (word_t)(sword_t)(sbyte_t)_result);			\
+      }									\
+  }
+DEFINST(LDRSB_OL,		0x05,
+	"ldr%csb",		"%d,[%n],-#%h",
+	RdPort,			F_MEM|F_LOAD|F_DISP|F_CISC,
+	DGPR(RD),DGPR(RN),DNA,	DNA, /**/DCOND, DGPR(RN), DNA)
+
+/* FIXME: 0x06: STRSB_OW is invalid, W is implied... */
+
+/* FIXME: 0x07: LDRSB_OWL is invalid, W is implied... */
+
+/* FIXME: 0x08: STRSB_RU is invalid... */
+
+#define LDRSB_RUL_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	word_t _result;							\
+	md_addr_t _addr;						\
+	enum md_fault_type _fault;					\
+									\
+	_result = (word_t)(sword_t)(sbyte_t)READ_BYTE(GPR_EX(RN), _fault);\
+	if (_fault != md_fault_none)					\
+	  DECLARE_FAULT(_fault);					\
+	_addr = GPR_EX(RN) + GPR_RES(RM);				\
+									\
+	SET_GPR(RN, _addr);						\
+	SET_GPR(RD, _result);						\
+      }									\
+  }
+DEFINST(LDRSB_RUL,		0x09,
+	"ldr%csb",		"%d,[%n],%w",
+	RdPort,			F_MEM|F_LOAD|F_DISP|F_CISC,
+	DGPR(RD),DGPR(RN),DNA,	DNA, /**/DCOND, DGPR(RN), DGPR(RM))
+
+/* FIXME: 0x0a: STRSB_RUW is invalid, W is implied... */
+
+/* FIXME: 0x0b: LDRSB_RUWL is invalid, W is implied... */
+
+/* FIXME: 0x0c: STRSB_OU is invalid... */
+
+#define LDRSB_OUL_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	byte_t _result;							\
+	md_addr_t _addr;						\
+	enum md_fault_type _fault;					\
+									\
+	_result = READ_BYTE(GPR_EX(RN), _fault);			\
+	if (_fault != md_fault_none)					\
+	  DECLARE_FAULT(_fault);					\
+	_addr = GPR_EX(RN) + HOFS;					\
+									\
+	SET_GPR(RN, _addr);						\
+	SET_GPR(RD, (word_t)(sword_t)(sbyte_t)_result);			\
+      }									\
+  }
+DEFINST(LDRSB_OUL,		0x0d,
+	"ldr%csb",		"%d,[%n],#%h",
+	RdPort,			F_MEM|F_LOAD|F_DISP|F_CISC,
+	DGPR(RD),DGPR(RN),DNA,	DNA, /**/DCOND, DGPR(RN), DNA)
+
+/* FIXME: 0x0e: STRSB_OUW is invalid, W is implied... */
+
+/* FIXME: 0x0f: LDRSB_OUWL is invalid, W is implied... */
+
+
+CONNECT(LDRSHSTRSH_LINK)
+
+/* FIXME: 0x00: STRSH_R is invalid... */
+
+#define LDRSH_RL_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	word_t _result;							\
+	md_addr_t _addr;						\
+	enum md_fault_type _fault;					\
+									\
+	_result = (word_t)(sword_t)(shalf_t)READ_HALF(GPR_EX(RN), _fault);\
+	if (_fault != md_fault_none)					\
+	  DECLARE_FAULT(_fault);					\
+	_addr = GPR_EX(RN) - GPR_RES(RM);				\
+									\
+	SET_GPR(RN, _addr);						\
+	SET_GPR(RD, _result);						\
+      }									\
+  }
+DEFINST(LDRSH_RL,		0x01,
+	"ldr%csh",		"%d,[%n],-%w",
+	RdPort,			F_MEM|F_LOAD|F_DISP|F_CISC,
+	DGPR(RD),DGPR(RN),DNA,	DNA, /**/DCOND, DGPR(RN), DGPR(RM))
+
+/* FIXME: 0x02: STRSH_RW is invalid, W is implied... */
+
+/* FIXME: 0x03: LDRSH_RWL is invalid, W is implied... */
+
+/* FIXME: 0x04: STRSH_O is invalid... */
+
+#define LDRSH_OL_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	half_t _result;							\
+	md_addr_t _addr;						\
+	enum md_fault_type _fault;					\
+									\
+	_result = READ_HALF(GPR_EX(RN), _fault);			\
+	if (_fault != md_fault_none)					\
+	  DECLARE_FAULT(_fault);					\
+        _addr = GPR_EX(RN) - HOFS;					\
+									\
+	SET_GPR(RN, _addr);						\
+	SET_GPR(RD, (word_t)(sword_t)(shalf_t)_result);			\
+      }									\
+  }
+DEFINST(LDRSH_OL,		0x05,
+	"ldr%csh",		"%d,[%n],-#%h",
+	RdPort,			F_MEM|F_LOAD|F_DISP|F_CISC,
+	DGPR(RD),DGPR(RN),DNA,	DNA, /**/DCOND, DGPR(RN), DNA)
+
+/* FIXME: 0x06: STRSH_OW is invalid, W is implied... */
+
+/* FIXME: 0x07: LDRSH_OWL is invalid, W is implied... */
+
+/* FIXME: 0x08: STRSH_RU is invalid... */
+
+#define LDRSH_RUL_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	word_t _result;							\
+	md_addr_t _addr;						\
+	enum md_fault_type _fault;					\
+									\
+	_result = (word_t)(sword_t)(shalf_t)READ_HALF(GPR_EX(RN), _fault);\
+	if (_fault != md_fault_none)					\
+	  DECLARE_FAULT(_fault);					\
+	_addr = GPR_EX(RN) + GPR_RES(RM);				\
+									\
+	SET_GPR(RN, _addr);						\
+	SET_GPR(RD, _result);						\
+      }									\
+  }
+DEFINST(LDRSH_RUL,		0x09,
+	"ldr%csh",		"%d,[%n],%w",
+	RdPort,			F_MEM|F_LOAD|F_DISP|F_CISC,
+	DGPR(RD),DGPR(RN),DNA,	DNA, /**/DCOND, DGPR(RN), DGPR(RM))
+
+/* FIXME: 0x0a: STRSH_RUW is invalid, W is implied... */
+
+/* FIXME: 0x0b: LDRSH_RUWL is invalid, W is implied... */
+
+/* FIXME: 0x0c: STRSH_OU is invalid... */
+
+#define LDRSH_OUL_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	half_t _result;							\
+	md_addr_t _addr;						\
+	enum md_fault_type _fault;					\
+									\
+	_result = READ_HALF(GPR_EX(RN), _fault);			\
+	if (_fault != md_fault_none)					\
+	  DECLARE_FAULT(_fault);					\
+        _addr = GPR_EX(RN) + HOFS;					\
+									\
+	SET_GPR(RN, _addr);						\
+	SET_GPR(RD, (word_t)(sword_t)(shalf_t)_result);			\
+      }									\
+  }
+DEFINST(LDRSH_OUL,		0x0d,
+	"ldr%csh",		"%d,[%n],#%h",
+	RdPort,			F_MEM|F_LOAD|F_DISP|F_CISC,
+	DGPR(RD),DGPR(RN),DNA,	DNA, /**/DCOND, DGPR(RN), DNA)
+
+/* FIXME: 0x0e: STRSH_OUW is invalid, W is implied... */
+
+/* FIXME: 0x0f: LDRSH_OUWL is invalid, W is implied... */
+
+
+CONNECT(LDRH_PSTRH_P_LINK)
+
+#define STRH_PR_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	md_addr_t _addr;						\
+	enum md_fault_type _fault;					\
+                                                                        \
+	_addr = GPR_EX(RN) - GPR(RM);					\
+	WRITE_HALF((half_t)GPR_MEM(RD), _addr, _fault);			\
+	if (_fault != md_fault_none)					\
+	  DECLARE_FAULT(_fault);					\
+      }									\
+  }
+DEFINST(STRH_PR,		0x00,
+	"str%ch",		"%d,[%n,%w]",
+	WrPort,			F_MEM|F_STORE|F_DISP|F_CISC,
+	DNA, DNA, DNA,		DGPR(RD), /**/DCOND, DGPR(RN), DGPR(RM))
+
+#define LDRH_PRL_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	half_t _result;							\
+	enum md_fault_type _fault;					\
+									\
+	_result = READ_HALF(GPR_EX(RN) - GPR(RM), _fault);		\
+	if (_fault != md_fault_none)					\
+	  DECLARE_FAULT(_fault);					\
+									\
+	SET_GPR(RD, (word_t)_result);					\
+      }									\
+  }
+DEFINST(LDRH_PRL,		0x01,
+	"ldr%ch",		"%d,[%n,%w]",
+	RdPort,			F_MEM|F_LOAD|F_DISP|F_CISC,
+	DGPR(RD), DNA, DNA,	DNA, /**/DCOND, DGPR(RN), DGPR(RM))
+
+#define STRH_PRW_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	md_addr_t _addr;						\
+	enum md_fault_type _fault;					\
+									\
+	_addr = GPR_EX(RN) - GPR(RM);					\
+	WRITE_HALF((half_t)GPR_MEM(RD), _addr, _fault);			\
+	if (_fault != md_fault_none)					\
+	  DECLARE_FAULT(_fault);					\
+									\
+	SET_GPR(RN, _addr);						\
+      }									\
+  }
+DEFINST(STRH_PRW,		0x02,
+	"str%ch",		"%d,[%n,%w]!",
+	WrPort,			F_MEM|F_STORE|F_DISP|F_CISC,
+	DGPR(RN), DNA, DNA,	DGPR(RD), /**/DCOND, DGPR(RN), DGPR(RM))
+
+#define LDRH_PRWL_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	half_t _result;							\
+	md_addr_t _addr;						\
+	enum md_fault_type _fault;					\
+									\
+        _addr = GPR_EX(RN) - GPR(RM);					\
+	_result = READ_HALF(_addr, _fault);				\
+	if (_fault != md_fault_none)					\
+	  DECLARE_FAULT(_fault);					\
+									\
+	SET_GPR(RN, _addr);						\
+	SET_GPR(RD, (word_t)_result);					\
+      }									\
+  }
+DEFINST(LDRH_PRWL,		0x03,
+	"ldr%ch",		"%d,[%n,%w]!",
+	RdPort,			F_MEM|F_LOAD|F_DISP|F_CISC,
+	DGPR(RD),DGPR(RN),DNA,	DNA, /**/DCOND, DGPR(RN), DGPR(RM))
+
+#define STRH_PO_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	enum md_fault_type _fault;					\
+                                                                        \
+	WRITE_HALF((half_t)GPR_MEM(RD), GPR_EX(RN) - HOFS, _fault);	\
+	if (_fault != md_fault_none)					\
+	  DECLARE_FAULT(_fault);					\
+      }									\
+  }
+DEFINST(STRH_PO,		0x04,
+	"str%ch",		"%d,[%n,-#%h]",
+	WrPort,			F_MEM|F_STORE|F_DISP|F_CISC,
+	DNA, DNA, DNA,		DGPR(RD), /**/DCOND, DGPR(RN), DNA)
+
+#define LDRH_POL_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	half_t _result;							\
+	enum md_fault_type _fault;					\
+									\
+	_result = READ_HALF(GPR_EX(RN) - HOFS, _fault);			\
+	if (_fault != md_fault_none)					\
+	  DECLARE_FAULT(_fault);					\
+									\
+	SET_GPR(RD, (word_t)_result);					\
+      }									\
+  }
+DEFINST(LDRH_POL,		0x05,
+	"ldr%ch",		"%d,[%n,-#%h]",
+	RdPort,			F_MEM|F_LOAD|F_DISP|F_CISC,
+	DGPR(RD), DNA, DNA,	DNA, /**/DCOND, DGPR(RN), DNA)
+
+#define STRH_POW_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	md_addr_t _addr;						\
+	enum md_fault_type _fault;					\
+									\
+        _addr = GPR_EX(RN) - HOFS;					\
+	WRITE_HALF((half_t)GPR_MEM(RD), _addr, _fault);			\
+	if (_fault != md_fault_none)					\
+	  DECLARE_FAULT(_fault);					\
+									\
+	SET_GPR(RN, _addr);						\
+      }									\
+  }
+DEFINST(STRH_POW,		0x06,
+	"str%ch",		"%d,[%n,-#%h]!",
+	WrPort,			F_MEM|F_STORE|F_DISP|F_CISC,
+	DGPR(RN), DNA, DNA,	DGPR(RD), /**/DCOND, DGPR(RN), DNA)
+
+#define LDRH_POWL_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	half_t _result;							\
+	md_addr_t _addr;						\
+	enum md_fault_type _fault;					\
+									\
+        _addr = GPR_EX(RN) - HOFS;					\
+	_result = READ_HALF(_addr, _fault);				\
+	if (_fault != md_fault_none)					\
+	  DECLARE_FAULT(_fault);					\
+									\
+	SET_GPR(RN, _addr);						\
+	SET_GPR(RD, (word_t)_result);					\
+      }									\
+  }
+DEFINST(LDRH_POWL,		0x07,
+	"ldr%ch",		"%d,[%n,-#%h]!",
+	RdPort,			F_MEM|F_LOAD|F_DISP|F_CISC,
+	DGPR(RD),DGPR(RN),DNA,	DNA, /**/DCOND, DGPR(RN), DNA)
+
+#define STRH_PRU_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	md_addr_t _addr;						\
+	enum md_fault_type _fault;					\
+									\
+	_addr = GPR_EX(RN) + GPR(RM);					\
+	WRITE_HALF((half_t)GPR_MEM(RD), _addr, _fault);			\
+	if (_fault != md_fault_none)					\
+	  DECLARE_FAULT(_fault);					\
+      }									\
+  }
+DEFINST(STRH_PRU,		0x08,
+	"str%ch",		"%d,[%n,%w]",
+	WrPort,			F_MEM|F_STORE|F_DISP|F_CISC,
+	DNA, DNA, DNA,		DGPR(RD), /**/DCOND, DGPR(RN), DGPR(RM))
+
+#define LDRH_PRUL_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	half_t _result;							\
+	enum md_fault_type _fault;					\
+									\
+	_result = READ_HALF(GPR_EX(RN) + GPR(RM), _fault);		\
+	if (_fault != md_fault_none)					\
+	  DECLARE_FAULT(_fault);					\
+									\
+	SET_GPR(RD, (word_t)_result);					\
+      }									\
+  }
+DEFINST(LDRH_PRUL,		0x09,
+	"ldr%ch",		"%d,[%n,%w]",
+	RdPort,			F_MEM|F_LOAD|F_DISP|F_CISC,
+	DGPR(RD), DNA, DNA,	DNA, /**/DCOND, DGPR(RN), DGPR(RM))
+
+#define STRH_PRUW_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	md_addr_t _addr;						\
+	enum md_fault_type _fault;					\
+									\
+	_addr = GPR_EX(RN) + GPR(RM);					\
+	WRITE_HALF((half_t)GPR_MEM(RD), _addr, _fault);			\
+	if (_fault != md_fault_none)					\
+	  DECLARE_FAULT(_fault);					\
+									\
+	SET_GPR(RN, _addr);						\
+      }									\
+  }
+DEFINST(STRH_PRUW,		0x0a,
+	"str%ch",		"%d,[%n,%w]!",
+	WrPort,			F_MEM|F_STORE|F_DISP|F_CISC,
+	DGPR(RN), DNA, DNA,	DGPR(RD), /**/DCOND, DGPR(RN), DGPR(RM))
+
+#define LDRH_PRUWL_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	half_t _result;							\
+	md_addr_t _addr;						\
+	enum md_fault_type _fault;					\
+									\
+	_addr = GPR_EX(RN) + GPR(RM);				        \
+	_result = READ_HALF(_addr, _fault);				\
+	if (_fault != md_fault_none)					\
+	  DECLARE_FAULT(_fault);					\
+									\
+	SET_GPR(RN, _addr);						\
+	SET_GPR(RD, (word_t)_result);					\
+      }									\
+  }
+DEFINST(LDRH_PRUWL,		0x0b,
+	"ldr%ch",		"%d,[%n,%w]!",
+	RdPort,			F_MEM|F_LOAD|F_DISP|F_CISC,
+	DGPR(RD),DGPR(RN),DNA,	DNA, /**/DCOND, DGPR(RN), DGPR(RM))
+
+#define STRH_POU_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	enum md_fault_type _fault;					\
+									\
+	WRITE_HALF((half_t)GPR_MEM(RD), GPR_EX(RN) + HOFS, _fault);	\
+	if (_fault != md_fault_none)					\
+	  DECLARE_FAULT(_fault);					\
+      }									\
+  }
+DEFINST(STRH_POU,		0x0c,
+	"str%ch",		"%d,[%n,#%h]",
+	WrPort,			F_MEM|F_STORE|F_DISP|F_CISC,
+	DNA, DNA, DNA,		DGPR(RD), /**/DCOND, DGPR(RN), DNA)
+
+#define LDRH_POUL_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	half_t _result;							\
+	enum md_fault_type _fault;					\
+									\
+	_result = READ_HALF(GPR_EX(RN) + HOFS, _fault);			\
+	if (_fault != md_fault_none)					\
+	  DECLARE_FAULT(_fault);					\
+									\
+	SET_GPR(RD, (word_t)_result);					\
+      }									\
+  }
+DEFINST(LDRH_POUL,		0x0d,
+	"ldr%ch",		"%d,[%n,#%h]",
+	RdPort,			F_MEM|F_LOAD|F_DISP|F_CISC,
+	DGPR(RD), DNA, DNA,	DNA, /**/DCOND, DGPR(RN), DNA)
+
+#define STRH_POUW_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	md_addr_t _addr;						\
+	enum md_fault_type _fault;					\
+									\
+	_addr = GPR_EX(RN) + HOFS;					\
+	WRITE_HALF((half_t)GPR_MEM(RD), _addr, _fault);			\
+	if (_fault != md_fault_none)					\
+	  DECLARE_FAULT(_fault);					\
+									\
+	SET_GPR(RN, _addr);						\
+      }									\
+  }
+DEFINST(STRH_POUW,		0x0e,
+	"str%ch",		"%d,[%n,#%h]!",
+	WrPort,			F_MEM|F_STORE|F_DISP|F_CISC,
+	DGPR(RN), DNA, DNA,	DGPR(RD), /**/DCOND, DGPR(RN), DNA)
+
+#define LDRH_POUWL_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	half_t _result;							\
+	md_addr_t _addr;						\
+	enum md_fault_type _fault;					\
+									\
+	_addr = GPR_EX(RN) + HOFS;					\
+	_result = READ_HALF(_addr, _fault);				\
+	if (_fault != md_fault_none)					\
+	  DECLARE_FAULT(_fault);					\
+									\
+	SET_GPR(RN, _addr);						\
+	SET_GPR(RD, (word_t)_result);					\
+      }									\
+  }
+DEFINST(LDRH_POUWL,		0x0f,
+	"ldr%ch",		"%d,[%n,#%h]!",
+	RdPort,			F_MEM|F_LOAD|F_DISP|F_CISC,
+	DGPR(RD),DGPR(RN),DNA,	DNA, /**/DCOND, DGPR(RN), DNA)
+
+
+CONNECT(LDRSB_PSTRSB_P_LINK)
+
+/* FIXME: 0x00: STRSB_PR is invalid... */
+
+#define LDRSB_PRL_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	byte_t _result;							\
+	enum md_fault_type _fault;					\
+									\
+	_result = READ_BYTE(GPR_EX(RN) - GPR(RM), _fault);		\
+	if (_fault != md_fault_none)					\
+	  DECLARE_FAULT(_fault);					\
+									\
+	SET_GPR(RD, (word_t)(sword_t)(sbyte_t)_result);			\
+      }									\
+  }
+DEFINST(LDRSB_PRL,		0x01,
+	"ldr%csb",		"%d,[%n,-%w]",
+	RdPort,			F_MEM|F_LOAD|F_DISP|F_CISC,
+	DGPR(RD), DNA, DNA,	DNA, /**/DCOND, DGPR(RN), DGPR(RM))
+
+/* FIXME: 0x02: STRSB_PRW is invalid, W is implied... */
+
+#define LDRSB_PRWL_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	byte_t _result;							\
+	md_addr_t _addr;						\
+	enum md_fault_type _fault;					\
+									\
+	_addr = GPR_EX(RN) - GPR(RM);					\
+	_result = READ_BYTE(_addr, _fault);				\
+	if (_fault != md_fault_none)					\
+	  DECLARE_FAULT(_fault);					\
+									\
+	SET_GPR(RN, _addr);						\
+	SET_GPR(RD, (word_t)(sword_t)(sbyte_t)_result);			\
+      }									\
+  }
+DEFINST(LDRSB_PRWL,		0x03,
+	"ldr%csb",		"%d,[%n,-%w]!",
+	RdPort,			F_MEM|F_LOAD|F_DISP|F_CISC,
+	DGPR(RD),DGPR(RN),DNA,	DNA, /**/DCOND, DGPR(RN), DGPR(RM))
+
+/* FIXME: 0x04: STRSB_PO is invalid... */
+
+#define LDRSB_POL_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	byte_t _result;							\
+	enum md_fault_type _fault;					\
+									\
+	_result = READ_BYTE(GPR_EX(RN) - HOFS, _fault);			\
+	if (_fault != md_fault_none)					\
+	  DECLARE_FAULT(_fault);					\
+									\
+        SET_GPR(RD, (word_t)(sword_t)(sbyte_t)_result);			\
+      }									\
+  }
+DEFINST(LDRSB_POL,		0x05,
+	"ldr%csb",		"%d,[%n,-#%h]",
+	RdPort,			F_MEM|F_LOAD|F_DISP|F_CISC,
+	DGPR(RD), DNA, DNA,	DNA, /**/DCOND, DGPR(RN), DNA)
+
+/* FIXME: 0x06: STRSB_POW is invalid, W is implied... */
+
+#define LDRSB_POWL_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	byte_t _result;							\
+	md_addr_t _addr;						\
+	enum md_fault_type _fault;					\
+									\
+        _addr = GPR_EX(RN) - HOFS;					\
+	_result = READ_BYTE(_addr, _fault);				\
+	if (_fault != md_fault_none)					\
+	  DECLARE_FAULT(_fault);					\
+									\
+	SET_GPR(RN, _addr);						\
+	SET_GPR(RD, (word_t)(sword_t)(sbyte_t)_result);			\
+      }									\
+  }
+DEFINST(LDRSB_POWL,		0x07,
+	"ldr%csb",		"%d,[%n,-#%h]!",
+	RdPort,			F_MEM|F_LOAD|F_DISP|F_CISC,
+	DGPR(RD),DGPR(RN),DNA,	DNA, /**/DCOND, DGPR(RN), DNA)
+
+/* FIXME: 0x08: STRSB_PRU is invalid... */
+
+#define LDRSB_PRUL_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	byte_t _result;							\
+	enum md_fault_type _fault;					\
+									\
+	_result = READ_BYTE(GPR_EX(RN) + GPR(RM), _fault);		\
+	if (_fault != md_fault_none)					\
+	  DECLARE_FAULT(_fault);					\
+									\
+	SET_GPR(RD, (word_t)(sword_t)(sbyte_t)_result);			\
+      }									\
+  }
+DEFINST(LDRSB_PRUL,		0x09,
+	"ldr%csb",		"%d,[%n,%w]",
+	RdPort,			F_MEM|F_LOAD|F_DISP|F_CISC,
+	DGPR(RD), DNA, DNA,	DNA, /**/DCOND, DGPR(RN), DGPR(RM))
+
+/* FIXME: 0x0a: STRSB_PRUW is invalid, W is implied... */
+
+#define LDRSB_PRUWL_IMPL						\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	byte_t _result;							\
+	md_addr_t _addr;						\
+	enum md_fault_type _fault;					\
+									\
+	_addr = GPR_EX(RN) + GPR(RM);					\
+	_result = READ_BYTE(_addr, _fault);				\
+	if (_fault != md_fault_none)					\
+	  DECLARE_FAULT(_fault);					\
+									\
+	SET_GPR(RN, _addr);						\
+	SET_GPR(RD, (word_t)(sword_t)(sbyte_t)_result);			\
+      }									\
+  }
+DEFINST(LDRSB_PRUWL,		0x0b,
+	"ldr%csb",		"%d,[%n,%w]!",
+	RdPort,			F_MEM|F_LOAD|F_DISP|F_CISC,
+	DGPR(RD),DGPR(RN),DNA,	DNA, /**/DCOND, DGPR(RN), DGPR(RM))
+
+/* FIXME: 0x0c: STRSB_POU is invalid... */
+
+#define LDRSB_POUL_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	byte_t _result;							\
+	enum md_fault_type _fault;					\
+									\
+	_result = READ_BYTE(GPR_EX(RN) + HOFS, _fault);			\
+	if (_fault != md_fault_none)					\
+	  DECLARE_FAULT(_fault);					\
+									\
+	SET_GPR(RD, (word_t)(sword_t)(sbyte_t)_result);			\
+      }									\
+  }
+DEFINST(LDRSB_POUL,		0x0d,
+	"ldr%csb",		"%d,[%n,#%h]",
+	RdPort,			F_MEM|F_LOAD|F_DISP|F_CISC,
+	DGPR(RD), DNA, DNA,	DNA, /**/DCOND, DGPR(RN), DNA)
+
+/* FIXME: 0x0e: STRSB_POUW is invalid, W is implied... */
+
+#define LDRSB_POUWL_IMPL						\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	byte_t _result;							\
+	md_addr_t _addr;						\
+	enum md_fault_type _fault;					\
+									\
+	_addr = GPR_EX(RN) + HOFS; 				        \
+	_result = READ_BYTE(_addr, _fault);				\
+	if (_fault != md_fault_none)					\
+	  DECLARE_FAULT(_fault);					\
+									\
+	SET_GPR(RN, _addr);						\
+	SET_GPR(RD, (word_t)(sword_t)(sbyte_t)_result);			\
+      }									\
+  }
+DEFINST(LDRSB_POUWL,		0x0f,
+	"ldr%csb",		"%d,[%n,#%h]!",
+	RdPort,			F_MEM|F_LOAD|F_DISP|F_CISC,
+	DGPR(RD),DGPR(RN),DNA,	DNA, /**/DCOND, DGPR(RN), DNA)
+
+
+CONNECT(LDRSH_PSTRSH_P_LINK)
+
+/* FIXME: 0x00: STRSH_PR is invalid... */
+
+#define LDRSH_PRL_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	half_t _result;							\
+	enum md_fault_type _fault;					\
+									\
+	_result = READ_HALF(GPR_EX(RN) - GPR(RM), _fault);		\
+	if (_fault != md_fault_none)					\
+	  DECLARE_FAULT(_fault);					\
+									\
+	SET_GPR(RD, (word_t)(sword_t)(shalf_t)_result);			\
+      }									\
+  }
+DEFINST(LDRSH_PRL,		0x01,
+	"ldr%csh",		"%d,[%n,-%w]",
+	RdPort,			F_MEM|F_LOAD|F_DISP|F_CISC,
+	DGPR(RD), DNA, DNA,	DNA, /**/DCOND, DGPR(RN), DGPR(RM))
+
+/* FIXME: 0x02: STRSH_PRW is invalid, W is implied... */
+
+#define LDRSH_PRWL_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	half_t _result;							\
+	md_addr_t _addr;						\
+	enum md_fault_type _fault;					\
+									\
+	_addr = GPR_EX(RN) - GPR(RM);					\
+	_result = READ_HALF(_addr, _fault);				\
+	if (_fault != md_fault_none)					\
+	  DECLARE_FAULT(_fault);					\
+									\
+	SET_GPR(RN, _addr);						\
+	SET_GPR(RD, (word_t)(sword_t)(shalf_t)_result);			\
+      }									\
+  }
+DEFINST(LDRSH_PRWL,		0x03,
+	"ldr%csh",		"%d,[%n,-%w]!",
+	RdPort,			F_MEM|F_LOAD|F_DISP|F_CISC,
+	DGPR(RD),DGPR(RN),DNA,	DNA, /**/DCOND, DGPR(RN), DGPR(RM))
+
+/* FIXME: 0x04: STRSH_PO is invalid... */
+
+#define LDRSH_POL_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	half_t _result;							\
+	enum md_fault_type _fault;					\
+									\
+	_result = READ_HALF(GPR_EX(RN) - HOFS, _fault);			\
+	if (_fault != md_fault_none)					\
+	  DECLARE_FAULT(_fault);					\
+									\
+	SET_GPR(RD, (word_t)(sword_t)(shalf_t)_result);			\
+      }									\
+  }
+DEFINST(LDRSH_POL,		0x05,
+	"ldr%csh",		"%d,[%n,-#%h]",
+	RdPort,			F_MEM|F_LOAD|F_DISP|F_CISC,
+	DGPR(RD), DNA, DNA,	DNA, /**/DCOND, DGPR(RN), DNA)
+
+/* FIXME: 0x06: STRSH_POW is invalid, W is implied... */
+
+#define LDRSH_POWL_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	half_t _result;							\
+	md_addr_t _addr;						\
+	enum md_fault_type _fault;					\
+									\
+	_addr = GPR_EX(RN) - HOFS;					\
+	_result = READ_HALF(_addr, _fault);				\
+	if (_fault != md_fault_none)					\
+	  DECLARE_FAULT(_fault);					\
+									\
+	SET_GPR(RN, _addr);						\
+	SET_GPR(RD, (word_t)(sword_t)(shalf_t)_result);			\
+      }									\
+  }
+DEFINST(LDRSH_POWL,		0x07,
+	"ldr%csh",		"%d,[%n,-#%h]!",
+	RdPort,			F_MEM|F_LOAD|F_DISP|F_CISC,
+	DGPR(RD),DGPR(RN),DNA,	DNA, /**/DCOND, DGPR(RN), DNA)
+
+/* FIXME: 0x08: STRSH_PRU is invalid... */
+
+#define LDRSH_PRUL_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	half_t _result;							\
+	enum md_fault_type _fault;					\
+									\
+	_result = READ_HALF(GPR_EX(RN) + GPR(RM), _fault);		\
+	if (_fault != md_fault_none)					\
+	  DECLARE_FAULT(_fault);					\
+									\
+	SET_GPR(RD, (word_t)(sword_t)(shalf_t)_result);			\
+      }									\
+  }
+DEFINST(LDRSH_PRUL,		0x09,
+	"ldr%csh",		"%d,[%n,%w]",
+	RdPort,			F_MEM|F_LOAD|F_DISP|F_CISC,
+	DGPR(RD), DNA, DNA,	DNA, /**/DCOND, DGPR(RN), DGPR(RM))
+
+/* FIXME: 0x0a: STRSH_PRUW is invalid, W is implied... */
+
+#define LDRSH_PRUWL_IMPL						\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	half_t _result;							\
+	md_addr_t _addr;						\
+	enum md_fault_type _fault;					\
+									\
+	_addr = GPR_EX(RN) + GPR(RM);					\
+	_result = READ_HALF(_addr, _fault);				\
+	if (_fault != md_fault_none)					\
+	  DECLARE_FAULT(_fault);					\
+									\
+	SET_GPR(RN, _addr);						\
+	SET_GPR(RD, (word_t)(sword_t)(shalf_t)_result);			\
+      }									\
+  }
+DEFINST(LDRSH_PRUWL,		0x0b,
+	"ldr%csh",		"%d,[%n,%w]!",
+	RdPort,			F_MEM|F_LOAD|F_DISP|F_CISC,
+	DGPR(RD),DGPR(RN),DNA,	DNA, /**/DCOND, DGPR(RN), DGPR(RM))
+
+/* FIXME: 0x0c: STRSH_POU is invalid... */
+
+#define LDRSH_POUL_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	half_t _result;							\
+	enum md_fault_type _fault;					\
+									\
+	_result = READ_HALF(GPR_EX(RN) + HOFS, _fault);			\
+	if (_fault != md_fault_none)					\
+	  DECLARE_FAULT(_fault);					\
+									\
+	SET_GPR(RD, (word_t)(sword_t)(shalf_t)_result);			\
+      }									\
+  }
+DEFINST(LDRSH_POUL,		0x0d,
+	"ldr%csh",		"%d,[%n,#%h]!",
+	RdPort,			F_MEM|F_LOAD|F_DISP|F_CISC,
+	DGPR(RD), DNA, DNA,	DNA, /**/DCOND, DGPR(RN), DNA)
+
+/* FIXME: 0x0e: STRSH_POUW is invalid, W is implied... */
+
+#define LDRSH_POUWL_IMPL						\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	half_t _result;							\
+	md_addr_t _addr;						\
+	enum md_fault_type _fault;					\
+									\
+	_addr = GPR_EX(RN) + HOFS;					\
+	_result = READ_HALF(_addr, _fault);				\
+	if (_fault != md_fault_none)					\
+	  DECLARE_FAULT(_fault);					\
+									\
+	SET_GPR(RN, _addr);						\
+	SET_GPR(RD, (word_t)(sword_t)(shalf_t)_result);			\
+      }									\
+  }
+DEFINST(LDRSH_POUWL,		0x0f,
+	"ldr%csh",		"%d,[%n,#%h]!",
+	RdPort,			F_MEM|F_LOAD|F_DISP|F_CISC,
+	DGPR(RD),DGPR(RN),DNA,	DNA, /**/DCOND, DGPR(RN), DNA)
+
+
+CONNECT(MEMIMMPOST_LINK)
+
+#define STR_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	md_addr_t _addr;						\
+	enum md_fault_type _fault;					\
+									\
+	WRITE_WORD(GPR_MEM(RD), GPR_EX(RN), _fault);			\
+	if (_fault != md_fault_none)					\
+	  DECLARE_FAULT(_fault);					\
+	_addr = GPR_EX(RN) - OFS;					\
+									\
+	SET_GPR(RN, _addr);						\
+      }									\
+  }
+DEFINST(STR,			0x00,
+	"str%c",		"%d,[%n],-#%o",
+	WrPort,			F_MEM|F_STORE|F_DISP|F_CISC,
+	DGPR(RN), DNA, DNA,	DGPR(RD), /**/DCOND, DGPR(RN), DNA)
+
+#define LDR_L_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	word_t _result;							\
+	md_addr_t _addr;						\
+	enum md_fault_type _fault;					\
+									\
+	_result = READ_WORD(GPR_EX(RN), _fault);			\
+	if (_fault != md_fault_none)					\
+	  DECLARE_FAULT(_fault);					\
+	_addr = GPR_EX(RN) - OFS;					\
+									\
+	SET_GPR(RN, _addr);						\
+	SET_GPR(RD, _result);						\
+      }									\
+  }
+DEFINST(LDR_L,			0x01,
+	"ldr%c",		"%d,[%n],-#%o",
+	RdPort,			F_MEM|F_LOAD|F_DISP|F_CISC,
+	DGPR(RD),DGPR(RN),DNA,	DNA, /**/DCOND, DGPR(RN), DNA)
+
+/* FIXME: 0x02: STR_W non-privileged... */
+
+/* FIXME: 0x03: LDR_WL non-privileged... */
+
+#define STR_B_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	md_addr_t _addr;						\
+	enum md_fault_type _fault;					\
+									\
+	WRITE_BYTE((byte_t)GPR_MEM(RD), GPR_EX(RN), _fault);		\
+	if (_fault != md_fault_none)					\
+	  DECLARE_FAULT(_fault);					\
+	_addr = GPR_EX(RN) - OFS;					\
+									\
+	SET_GPR(RN, _addr);						\
+      }									\
+  }
+DEFINST(STR_B,			0x04,
+	"str%cb",		"%d,[%n],-#%o",
+	WrPort,			F_MEM|F_STORE|F_DISP|F_CISC,
+	DGPR(RN), DNA, DNA,	DGPR(RD), /**/DCOND, DGPR(RN), DNA)
+
+#define LDR_BL_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	byte_t _result;							\
+	md_addr_t _addr;						\
+	enum md_fault_type _fault;					\
+									\
+	_result = READ_BYTE(GPR_EX(RN), _fault);			\
+	if (_fault != md_fault_none)					\
+	  DECLARE_FAULT(_fault);					\
+	_addr = GPR_EX(RN) - OFS;					\
+									\
+	SET_GPR(RN, _addr);						\
+	SET_GPR(RD, (word_t)_result);					\
+      }									\
+  }
+DEFINST(LDR_BL,			0x05,
+	"ldr%cb",		"%d,[%n],-#%o",
+	RdPort,			F_MEM|F_LOAD|F_DISP|F_CISC,
+	DGPR(RD),DGPR(RN),DNA,	DNA, /**/DCOND, DGPR(RN), DNA)
+
+/* FIXME: 0x06: STR_BW non-privileged... */
+
+/* FIXME: 0x07: LDR_BWL non-privileged... */
+
+#define STR_U_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	md_addr_t _addr;						\
+	enum md_fault_type _fault;					\
+									\
+	WRITE_WORD(GPR_MEM(RD), GPR_EX(RN), _fault);			\
+	if (_fault != md_fault_none)					\
+	  DECLARE_FAULT(_fault);					\
+	_addr = GPR_EX(RN) + OFS;					\
+									\
+	SET_GPR(RN, _addr);						\
+      }									\
+  }
+DEFINST(STR_U,			0x08,
+	"str%c",		"%d,[%n],#%o",
+	WrPort,			F_MEM|F_STORE|F_DISP|F_CISC,
+	DGPR(RN), DNA, DNA,	DGPR(RD), /**/DCOND, DGPR(RN), DNA)
+
+#define LDR_UL_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	word_t _result;							\
+	md_addr_t _addr;						\
+	enum md_fault_type _fault;					\
+									\
+	_result = READ_WORD(GPR_EX(RN), _fault);			\
+	if (_fault != md_fault_none)					\
+	  DECLARE_FAULT(_fault);					\
+	_addr = GPR_EX(RN) + OFS;					\
+									\
+	SET_GPR(RN, _addr);						\
+	SET_GPR(RD, _result);						\
+      }									\
+  }
+DEFINST(LDR_UL,			0x09,
+	"ldr%c",		"%d,[%n],#%o",
+	RdPort,			F_MEM|F_LOAD|F_DISP|F_CISC,
+	DGPR(RD),DGPR(RN),DNA,	DNA, /**/DCOND, DGPR(RN), DNA)
+
+/* FIXME: 0x0a: STR_UW non-privileged... */
+
+/* FIXME: 0x0b: LDR_UWL non-privileged... */
+
+#define STR_UB_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	md_addr_t _addr;						\
+	enum md_fault_type _fault;					\
+									\
+	WRITE_BYTE((byte_t)GPR_MEM(RD), GPR_EX(RN), _fault);		\
+	if (_fault != md_fault_none)					\
+	  DECLARE_FAULT(_fault);					\
+	_addr = GPR_EX(RN) + OFS;					\
+									\
+	SET_GPR(RN, _addr);						\
+      }									\
+  }
+DEFINST(STR_UB,			0x0c,
+	"str%cb",		"%d,[%n],#%o",
+	WrPort,			F_MEM|F_STORE|F_DISP|F_CISC,
+	DGPR(RN), DNA, DNA,	DGPR(RD), /**/DCOND, DGPR(RN), DNA)
+
+#define LDR_UBL_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	byte_t _result;							\
+	md_addr_t _addr;						\
+	enum md_fault_type _fault;					\
+									\
+	_result = READ_BYTE(GPR_EX(RN), _fault);			\
+	if (_fault != md_fault_none)					\
+	  DECLARE_FAULT(_fault);					\
+	_addr = GPR_EX(RN) + OFS;					\
+									\
+	SET_GPR(RN, _addr);						\
+	SET_GPR(RD, (word_t)_result);					\
+      }									\
+  }
+DEFINST(LDR_UBL,		0x0d,
+	"ldr%cb",		"%d,[%n],#%o",
+	RdPort,			F_MEM|F_LOAD|F_DISP|F_CISC,
+	DGPR(RD),DGPR(RN),DNA,	DNA, /**/DCOND, DGPR(RN), DNA)
+
+/* FIXME: 0x0e: STR_UBW non-privileged... */
+
+/* FIXME: 0x0f: LDR_UBWL non-privileged... */
+
+
+CONNECT(MEMIMMPRE_LINK)
+
+#define STR_P_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	enum md_fault_type _fault;					\
+									\
+	WRITE_WORD(GPR_MEM(RD), GPR_EX(RN) - OFS, _fault);		\
+	if (_fault != md_fault_none)					\
+	  DECLARE_FAULT(_fault);					\
+      }									\
+  }
+DEFINST(STR_P,			0x00,
+	"str%c",		"%d,[%n,-#%o]",
+	WrPort,			F_MEM|F_STORE|F_DISP|F_CISC,
+	DNA, DNA, DNA,		DGPR(RD), /**/DCOND, DGPR(RN), DNA)
+
+#define LDR_PL_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	word_t _result;							\
+	enum md_fault_type _fault;					\
+									\
+	_result = READ_WORD(GPR_EX(RN) - OFS, _fault);			\
+	if (_fault != md_fault_none)					\
+	  DECLARE_FAULT(_fault);					\
+									\
+	SET_GPR(RD, _result);						\
+      }									\
+  }
+DEFINST(LDR_PL,			0x01,
+	"ldr%c",		"%d,[%n,-#%o]",
+	RdPort,			F_MEM|F_LOAD|F_DISP|F_CISC,
+	DGPR(RD), DNA, DNA,	DNA, /**/DCOND, DGPR(RN), DNA)
+
+#define STR_PW_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	enum md_fault_type _fault;					\
+	md_addr_t _addr;						\
+									\
+	_addr = GPR_EX(RN) - OFS;					\
+	WRITE_WORD(GPR_MEM(RD), _addr, _fault);				\
+	if (_fault != md_fault_none)					\
+	  DECLARE_FAULT(_fault);					\
+									\
+	SET_GPR(RN, _addr);						\
+      }									\
+  }
+DEFINST(STR_PW,			0x02,
+	"str%c",		"%d,[%n,-#%o]!",
+	WrPort,			F_MEM|F_STORE|F_DISP|F_CISC,
+	DGPR(RN), DNA, DNA,	DGPR(RD), /**/DCOND, DGPR(RN), DNA)
+
+#define LDR_PWL_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	word_t _result;							\
+	md_addr_t _addr;						\
+	enum md_fault_type _fault;					\
+									\
+	_addr = GPR_EX(RN) - OFS;					\
+	_result = READ_WORD(_addr, _fault);				\
+	if (_fault != md_fault_none)					\
+	  DECLARE_FAULT(_fault);					\
+									\
+	SET_GPR(RN, _addr);						\
+	SET_GPR(RD, _result);						\
+      }									\
+  }
+DEFINST(LDR_PWL,		0x03,
+	"ldr%c",		"%d,[%n,-#%o]!",
+	RdPort,			F_MEM|F_LOAD|F_DISP|F_CISC,
+	DGPR(RD),DGPR(RN),DNA,	DNA, /**/DCOND, DGPR(RN), DNA)
+
+#define STR_PB_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	enum md_fault_type _fault;					\
+									\
+	WRITE_BYTE((byte_t)GPR_MEM(RD), GPR_EX(RN) - OFS, _fault);	\
+	if (_fault != md_fault_none)					\
+	  DECLARE_FAULT(_fault);					\
+      }									\
+  }
+DEFINST(STR_PB,			0x04,
+	"str%cb",		"%d,[%n,-#%o]",
+	WrPort,			F_MEM|F_STORE|F_DISP|F_CISC,
+	DNA, DNA, DNA,		DGPR(RD), /**/DCOND, DGPR(RN), DNA)
+
+#define LDR_PBL_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	byte_t _result;							\
+	enum md_fault_type _fault;					\
+									\
+	_result = READ_BYTE(GPR_EX(RN) - OFS, _fault);			\
+	if (_fault != md_fault_none)					\
+	  DECLARE_FAULT(_fault);					\
+									\
+	SET_GPR(RD, (word_t)_result);					\
+      }									\
+  }
+DEFINST(LDR_PBL,		0x05,
+	"ldr%cb",		"%d,[%n,-#%o]",
+	RdPort,			F_MEM|F_LOAD|F_DISP|F_CISC,
+	DGPR(RD), DNA, DNA,	DNA, /**/DCOND, DGPR(RN), DNA)
+
+#define STR_PBW_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	enum md_fault_type _fault;					\
+	md_addr_t _addr;						\
+									\
+	_addr = GPR_EX(RN) - OFS;					\
+	WRITE_BYTE((byte_t)GPR_MEM(RD), _addr, _fault);			\
+	if (_fault != md_fault_none)					\
+	  DECLARE_FAULT(_fault);					\
+									\
+	SET_GPR(RN, _addr);						\
+      }									\
+  }
+DEFINST(STR_PBW,		0x06,
+	"str%cb",		"%d,[%n,-#%o]!",
+	WrPort,			F_MEM|F_STORE|F_DISP|F_CISC,
+	DGPR(RN), DNA, DNA,	DGPR(RD), /**/DCOND, DGPR(RN), DNA)
+
+#define LDR_PBWL_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	byte_t _result;							\
+	md_addr_t _addr;						\
+	enum md_fault_type _fault;					\
+									\
+	_addr = GPR_EX(RN) - OFS;					\
+	_result = READ_BYTE(_addr, _fault);				\
+	if (_fault != md_fault_none)					\
+	  DECLARE_FAULT(_fault);					\
+									\
+	SET_GPR(RN, _addr);						\
+	SET_GPR(RD, (word_t)_result);					\
+      }									\
+  }
+DEFINST(LDR_PBWL,		0x07,
+	"ldr%cb",		"%d,[%n,-#%o]!",
+	RdPort,			F_MEM|F_LOAD|F_DISP|F_CISC,
+	DGPR(RD),DGPR(RN),DNA,	DNA, /**/DCOND, DGPR(RN), DNA)
+
+#define STR_PU_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+        enum md_fault_type _fault;					\
+									\
+        WRITE_WORD(GPR_MEM(RD), GPR_EX(RN) + OFS, _fault);		\
+        if (_fault != md_fault_none)					\
+          DECLARE_FAULT(_fault);					\
+      }									\
+  }
+DEFINST(STR_PU,			0x08,
+	"str%c",		"%d,[%n,#%o]",
+	WrPort,			F_MEM|F_STORE|F_DISP|F_CISC,
+	DNA, DNA, DNA,		DGPR(RD), /**/DCOND, DGPR(RN), DNA)
+
+#define LDR_PUL_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+        word_t _result;							\
+        enum md_fault_type _fault;					\
+									\
+        _result = READ_WORD(GPR_EX(RN) + OFS, _fault);			\
+        if (_fault != md_fault_none)					\
+          DECLARE_FAULT(_fault);					\
+									\
+        SET_GPR(RD, _result);						\
+      }									\
+  }
+DEFINST(LDR_PUL,		0x09,
+	"ldr%c",		"%d,[%n,#%o]",
+	RdPort,			F_MEM|F_LOAD|F_DISP|F_CISC,
+	DGPR(RD), DNA, DNA,	DNA, /**/DCOND, DGPR(RN), DNA)
+
+#define STR_PUW_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+        enum md_fault_type _fault;					\
+        md_addr_t _addr;						\
+									\
+        _addr = GPR_EX(RN) + OFS;					\
+        WRITE_WORD(GPR_MEM(RD), _addr, _fault);				\
+        if (_fault != md_fault_none)					\
+          DECLARE_FAULT(_fault);					\
+									\
+        SET_GPR(RN, _addr);						\
+      }									\
+  }
+DEFINST(STR_PUW,		0x0a,
+	"str%c",		"%d,[%n,#%o]!",
+	WrPort,			F_MEM|F_STORE|F_DISP|F_CISC,
+	DGPR(RN), DNA, DNA,	DGPR(RD), /**/DCOND, DGPR(RN), DNA)
+
+#define LDR_PUWL_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+        word_t _result;							\
+        md_addr_t _addr;						\
+        enum md_fault_type _fault;					\
+									\
+        _addr = GPR_EX(RN) + OFS;					\
+        _result = READ_WORD(_addr, _fault);				\
+        if (_fault != md_fault_none)					\
+          DECLARE_FAULT(_fault);					\
+									\
+        SET_GPR(RN, _addr);						\
+        SET_GPR(RD, _result);						\
+      }									\
+  }
+DEFINST(LDR_PUWL,		0x0b,
+	"ldr%c",		"%d,[%n,#%o]!",
+	RdPort,			F_MEM|F_LOAD|F_DISP|F_CISC,
+	DGPR(RD),DGPR(RN),DNA,	DNA, /**/DCOND, DGPR(RN), DNA)
+
+#define STR_PUB_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+        enum md_fault_type _fault;					\
+									\
+        WRITE_BYTE((byte_t)GPR_MEM(RD), GPR_EX(RN) + OFS, _fault);	\
+        if (_fault != md_fault_none)					\
+          DECLARE_FAULT(_fault);					\
+      }									\
+  }
+DEFINST(STR_PUB,		0x0c,
+	"str%cb",		"%d,[%n,#%o]",
+	WrPort,			F_MEM|F_STORE|F_DISP|F_CISC,
+	DNA, DNA, DNA,		DGPR(RD), /**/DCOND, DGPR(RN), DNA)
+
+#define LDR_PUBL_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+        byte_t _result;							\
+        enum md_fault_type _fault;					\
+									\
+        _result = READ_BYTE(GPR_EX(RN) + OFS, _fault);			\
+        if (_fault != md_fault_none)					\
+          DECLARE_FAULT(_fault);					\
+									\
+        SET_GPR(RD, (word_t)_result);					\
+      }									\
+  }
+DEFINST(LDR_PUBL,		0x0d,
+	"ldr%cb",		"%d,[%n,#%o]",
+	RdPort,			F_MEM|F_LOAD|F_DISP|F_CISC,
+	DGPR(RD), DNA, DNA,	DNA, /**/DCOND, DGPR(RN), DNA)
+
+#define STR_PUBW_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+        enum md_fault_type _fault;					\
+        md_addr_t _addr;						\
+									\
+        _addr = GPR_EX(RN) + OFS;					\
+        WRITE_BYTE((byte_t)GPR_MEM(RD), _addr, _fault);			\
+        if (_fault != md_fault_none)					\
+          DECLARE_FAULT(_fault);					\
+									\
+        SET_GPR(RN, _addr);						\
+      }									\
+  }
+DEFINST(STR_PUBW,		0x0e,
+	"str%cb",		"%d,[%n,#%o]!",
+	WrPort,			F_MEM|F_STORE|F_DISP|F_CISC,
+	DGPR(RN), DNA, DNA,	DGPR(RD), /**/DCOND, DGPR(RN), DNA)
+
+#define LDR_PUBWL_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+        byte_t _result;							\
+        md_addr_t _addr;						\
+        enum md_fault_type _fault;					\
+									\
+        _addr = GPR_EX(RN) + OFS;					\
+        _result = READ_BYTE(_addr, _fault);				\
+        if (_fault != md_fault_none)					\
+          DECLARE_FAULT(_fault);					\
+									\
+        SET_GPR(RN, _addr);						\
+        SET_GPR(RD, (word_t)_result);					\
+      }									\
+  }
+DEFINST(LDR_PUBWL,		0x0f,
+	"ldr%cb",		"%d,[%n,#%o]!",
+	RdPort,			F_MEM|F_LOAD|F_DISP|F_CISC,
+	DGPR(RD),DGPR(RN),DNA,	DNA, /**/DCOND, DGPR(RN), DNA)
+
+
+CONNECT(MEMREGPOST_LINK)
+
+#define STR_R_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+        enum md_fault_type _fault;					\
+									\
+        /* register shift amounts not allowed for ld/st (THANK YOU!) */	\
+        if (SHIFT_REG)							\
+          DECLARE_FAULT(md_fault_unimpl);				\
+									\
+        WRITE_WORD(GPR_MEM(RD), GPR_EX(RN), _fault);			\
+        if (_fault != md_fault_none)					\
+          DECLARE_FAULT(_fault);					\
+									\
+        SET_GPR(RN, GPR_EX(RN) - SHIFTRM(GPR(RM), /* unused */0, PSR_C));\
+      }									\
+  }
+DEFINST(STR_R,			0x00,
+	"str%c",		"%d,[%n],-%m!",
+	WrPort,			F_MEM|F_STORE|F_DISP|F_CISC,
+	DGPR(RN), DNA, DNA,	DGPR(RD), /**/DCONDSH, DGPR(RN), DGPR(RM))
+
+#define LDR_RL_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+        enum md_fault_type _fault;					\
+        word_t _result;							\
+									\
+        /* register shift amounts not allowed for ld/st (THANK YOU!) */	\
+        if (SHIFT_REG)							\
+          DECLARE_FAULT(md_fault_unimpl);				\
+									\
+        _result = READ_WORD(GPR_EX(RN), _fault);			\
+        if (_fault != md_fault_none)					\
+          DECLARE_FAULT(_fault);					\
+									\
+        SET_GPR(RN, GPR_EX(RN) - SHIFTRM(GPR_RES(RM), /* unused */0, PSR_C));\
+        SET_GPR(RD, _result);						\
+      }									\
+  }
+DEFINST(LDR_RL,			0x01,
+	"ldr%c",		"%d,[%n],-%m!",
+	WrPort,			F_MEM|F_STORE|F_DISP|F_CISC,
+	DGPR(RD),DGPR(RN),DNA,	DNA, /**/DCONDSH, DGPR(RN), DGPR(RM))
+
+/* FIXME: STR_RW, 0x02, special priv semantics */
+
+/* FIXME: LDR_RWL, 0x03, special priv semantics */
+
+#define STR_RB_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+        enum md_fault_type _fault;					\
+									\
+        /* register shift amounts not allowed for ld/st (THANK YOU!) */	\
+        if (SHIFT_REG)							\
+          DECLARE_FAULT(md_fault_unimpl);				\
+									\
+        WRITE_BYTE((byte_t)GPR_MEM(RD), GPR_EX(RN), _fault);		\
+        if (_fault != md_fault_none)					\
+          DECLARE_FAULT(_fault);					\
+									\
+        SET_GPR(RN, GPR_EX(RN) - SHIFTRM(GPR(RM), /* unused */0, PSR_C));\
+      }									\
+  }
+DEFINST(STR_RB,			0x04,
+	"str%cb",		"%d,[%n],-%m!",
+	WrPort,			F_MEM|F_STORE|F_DISP|F_CISC,
+	DGPR(RN), DNA, DNA,	DGPR(RD), /**/DCONDSH, DGPR(RN), DGPR(RM))
+
+#define LDR_RBL_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+        enum md_fault_type _fault;					\
+        word_t _result;							\
+									\
+        /* register shift amounts not allowed for ld/st (THANK YOU!) */	\
+        if (SHIFT_REG)							\
+          DECLARE_FAULT(md_fault_unimpl);				\
+									\
+        _result = (word_t)READ_BYTE(GPR_EX(RN), _fault);		\
+        if (_fault != md_fault_none)					\
+          DECLARE_FAULT(_fault);					\
+									\
+        SET_GPR(RN, GPR_EX(RN) - SHIFTRM(GPR_RES(RM), /* unused */0, PSR_C));\
+        SET_GPR(RD, _result);						\
+      }									\
+  }
+DEFINST(LDR_RBL,		0x05,
+	"ldr%cb",		"%d,[%n],-%m!",
+	WrPort,			F_MEM|F_STORE|F_DISP|F_CISC,
+	DGPR(RD),DGPR(RN),DNA,	DNA, /**/DCONDSH, DGPR(RN), DGPR(RM))
+
+/* FIXME: STR_RBW, 0x06, special priv semantics */
+
+/* FIXME: LDR_RBWL, 0x07, special priv semantics */
+
+#define STR_RU_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+        enum md_fault_type _fault;					\
+									\
+        /* register shift amounts not allowed for ld/st (THANK YOU!) */	\
+        if (SHIFT_REG)							\
+          DECLARE_FAULT(md_fault_unimpl);				\
+									\
+        WRITE_WORD(GPR_MEM(RD), GPR_EX(RN), _fault);			\
+        if (_fault != md_fault_none)					\
+          DECLARE_FAULT(_fault);					\
+									\
+        SET_GPR(RN, GPR_EX(RN) + SHIFTRM(GPR(RM), /* unused */0, PSR_C));\
+      }									\
+  }
+DEFINST(STR_RU,			0x08,
+	"str%c",		"%d,[%n],%m!",
+	WrPort,			F_MEM|F_STORE|F_DISP|F_CISC,
+	DGPR(RN), DNA, DNA,	DGPR(RD), /**/DCONDSH, DGPR(RN), DGPR(RM))
+
+#define LDR_RUL_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+        word_t _result;							\
+        md_addr_t _addr;						\
+        enum md_fault_type _fault;					\
+									\
+        _result = READ_WORD(GPR_EX(RN), _fault);			\
+        if (_fault != md_fault_none)					\
+          DECLARE_FAULT(_fault);					\
+        _addr = GPR_EX(RN) + SHIFTRM(GPR_RES(RM), /* unused */0, PSR_C);\
+									\
+        SET_GPR(RN, _addr);						\
+        SET_GPR(RD, _result);						\
+      }									\
+  }
+DEFINST(LDR_RUL,		0x09,
+	"ldr%c",		"%d,[%n],%m!",
+	RdPort,			F_MEM|F_LOAD|F_DISP|F_CISC,
+	DGPR(RD),DGPR(RN),DNA,	DNA, /**/DCONDSH, DGPR(RN), DGPR(RM))
+
+/* FIXME: STR_RUW, 0x0a, special priv semantics */
+
+/* FIXME: LDR_RUWL, 0x0b, special priv semantics */
+
+#define STR_RUB_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+        enum md_fault_type _fault;					\
+									\
+        /* register shift amounts not allowed for ld/st (THANK YOU!) */	\
+        if (SHIFT_REG)							\
+          DECLARE_FAULT(md_fault_unimpl);				\
+									\
+        WRITE_BYTE((byte_t)GPR_MEM(RD), GPR_EX(RN), _fault);		\
+        if (_fault != md_fault_none)					\
+          DECLARE_FAULT(_fault);					\
+									\
+        SET_GPR(RN, GPR_EX(RN) + SHIFTRM(GPR(RM), /* unused */0, PSR_C));\
+      }									\
+  }
+DEFINST(STR_RUB,		0x0c,
+	"str%cb",		"%d,[%n],%m!",
+	WrPort,			F_MEM|F_STORE|F_DISP|F_CISC,
+	DGPR(RN), DNA, DNA,	DGPR(RD), /**/DCONDSH, DGPR(RN), DGPR(RM))
+
+#define LDR_RUBL_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+        word_t _result;							\
+        md_addr_t _addr;						\
+        enum md_fault_type _fault;					\
+									\
+        /* register shift amounts not allowed for ld/st (THANK YOU!) */	\
+        if (SHIFT_REG)							\
+          DECLARE_FAULT(md_fault_unimpl);				\
+									\
+        _result = (word_t)READ_BYTE(GPR_EX(RN), _fault);		\
+        if (_fault != md_fault_none)					\
+          DECLARE_FAULT(_fault);					\
+        _addr = GPR_EX(RN) + SHIFTRM(GPR_RES(RM), /* unused */0, PSR_C);\
+									\
+        SET_GPR(RN, _addr);						\
+        SET_GPR(RD, _result);						\
+      }									\
+  }
+DEFINST(LDR_RUBL,		0x0d,
+	"ldr%cb",		"%d,[%n],%m!",
+	RdPort,			F_MEM|F_LOAD|F_DISP|F_CISC,
+	DGPR(RD),DGPR(RN),DNA,	DNA, /**/DCONDSH, DGPR(RN), DGPR(RM))
+
+/* FIXME: STR_RUBW, 0x0e, special priv semantics */
+
+/* FIXME: LDR_RUBWL, 0x0f, special priv semantics */
+
+
+CONNECT(MEMREGPRE_LINK)
+
+#define STR_RP_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+        enum md_fault_type _fault;					\
+	md_addr_t _addr;						\
+									\
+        /* register shift amounts not allowed for ld/st (THANK YOU!) */	\
+        if (SHIFT_REG)							\
+          DECLARE_FAULT(md_fault_unimpl);				\
+									\
+	_addr = GPR_EX(RN) - SHIFTRM(GPR(RM), /* unused */0, PSR_C);	\
+        WRITE_WORD(GPR_MEM(RD), _addr, _fault);				\
+        if (_fault != md_fault_none)					\
+          DECLARE_FAULT(_fault);					\
+      }									\
+  }
+DEFINST(STR_RP,			0x00,
+	"str%c",		"%d,[%n, -%m]",
+	WrPort,			F_MEM|F_STORE|F_DISP|F_CISC,
+	DNA, DNA, DNA,		DGPR(RD), /**/DCONDSH, DGPR(RN), DGPR(RM))
+
+#define LDR_RPL_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+        enum md_fault_type _fault;					\
+        word_t _result;							\
+	md_addr_t _addr;						\
+									\
+        /* register shift amounts not allowed for ld/st (THANK YOU!) */	\
+        if (SHIFT_REG)							\
+          DECLARE_FAULT(md_fault_unimpl);				\
+									\
+	_addr = GPR_EX(RN) - SHIFTRM(GPR(RM), /* unused */0, PSR_C);	\
+        _result = READ_WORD(_addr, _fault);				\
+        if (_fault != md_fault_none)					\
+          DECLARE_FAULT(_fault);					\
+									\
+        SET_GPR(RD, _result);						\
+      }									\
+  }
+DEFINST(LDR_RPL,		0x01,
+	"ldr%c",		"%d,[%n, -%m]",
+	RdPort,			F_MEM|F_LOAD|F_DISP|F_CISC,
+	DGPR(RD), DNA, DNA,	DNA, /**/DCONDSH, DGPR(RN), DGPR(RM))
+
+#define STR_RPW_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+        enum md_fault_type _fault;					\
+	md_addr_t _addr;						\
+									\
+        /* register shift amounts not allowed for ld/st (THANK YOU!) */	\
+        if (SHIFT_REG)							\
+          DECLARE_FAULT(md_fault_unimpl);				\
+									\
+	_addr = GPR_EX(RN) - SHIFTRM(GPR(RM), /* unused */0, PSR_C);	\
+        WRITE_WORD(GPR_MEM(RD), _addr, _fault);				\
+        if (_fault != md_fault_none)					\
+          DECLARE_FAULT(_fault);					\
+									\
+	SET_GPR(RN, _addr);						\
+      }									\
+  }
+DEFINST(STR_RPW,		0x02,
+	"str%c",		"%d,[%n, -%m]!",
+	WrPort,			F_MEM|F_STORE|F_DISP|F_CISC,
+	DGPR(RN), DNA, DNA,	DGPR(RD), /**/DCONDSH, DGPR(RN), DGPR(RM))
+
+#define LDR_RPWL_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+        enum md_fault_type _fault;					\
+        word_t _result;							\
+	md_addr_t _addr;						\
+									\
+        /* register shift amounts not allowed for ld/st (THANK YOU!) */	\
+        if (SHIFT_REG)							\
+          DECLARE_FAULT(md_fault_unimpl);				\
+									\
+	_addr = GPR_EX(RN) - SHIFTRM(GPR(RM), /* unused */0, PSR_C);	\
+        _result = READ_WORD(_addr, _fault);				\
+        if (_fault != md_fault_none)					\
+          DECLARE_FAULT(_fault);					\
+									\
+	SET_GPR(RN, _addr);						\
+        SET_GPR(RD, _result);						\
+      }									\
+  }
+DEFINST(LDR_RPWL,		0x03,
+	"ldr%c",		"%d,[%n, -%m]!",
+	RdPort,			F_MEM|F_LOAD|F_DISP|F_CISC,
+	DGPR(RD),DGPR(RN),DNA,	DNA, /**/DCONDSH, DGPR(RN), DGPR(RM))
+
+#define STR_RPB_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+        enum md_fault_type _fault;					\
+	md_addr_t _addr;						\
+									\
+        /* register shift amounts not allowed for ld/st (THANK YOU!) */	\
+        if (SHIFT_REG)							\
+          DECLARE_FAULT(md_fault_unimpl);				\
+									\
+	_addr = GPR_EX(RN) - SHIFTRM(GPR(RM), /* unused */0, PSR_C);	\
+        WRITE_BYTE((byte_t)GPR_MEM(RD), _addr, _fault);			\
+        if (_fault != md_fault_none)					\
+          DECLARE_FAULT(_fault);					\
+      }									\
+  }
+DEFINST(STR_RPB,		0x04,
+	"str%cb",		"%d,[%n, -%m]",
+	WrPort,			F_MEM|F_STORE|F_DISP|F_CISC,
+	DNA, DNA, DNA,		DGPR(RD), /**/DCONDSH, DGPR(RN), DGPR(RM))
+
+#define LDR_RPBL_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+        enum md_fault_type _fault;					\
+        byte_t _result;							\
+	md_addr_t _addr;						\
+									\
+        /* register shift amounts not allowed for ld/st (THANK YOU!) */	\
+        if (SHIFT_REG)							\
+          DECLARE_FAULT(md_fault_unimpl);				\
+									\
+	_addr = GPR_EX(RN) - SHIFTRM(GPR(RM), /* unused */0, PSR_C);	\
+        _result = READ_BYTE(_addr, _fault);				\
+        if (_fault != md_fault_none)					\
+          DECLARE_FAULT(_fault);					\
+									\
+        SET_GPR(RD, (word_t)_result);					\
+      }									\
+  }
+DEFINST(LDR_RPBL,		0x05,
+	"ldr%cb",		"%d,[%n, -%m]",
+	RdPort,			F_MEM|F_LOAD|F_DISP|F_CISC,
+	DGPR(RD), DNA, DNA,	DNA, /**/DCONDSH, DGPR(RN), DGPR(RM))
+
+#define STR_RPBW_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+        enum md_fault_type _fault;					\
+	md_addr_t _addr;						\
+									\
+        /* register shift amounts not allowed for ld/st (THANK YOU!) */	\
+        if (SHIFT_REG)							\
+          DECLARE_FAULT(md_fault_unimpl);				\
+									\
+	_addr = GPR_EX(RN) - SHIFTRM(GPR(RM), /* unused */0, PSR_C);	\
+        WRITE_BYTE((byte_t)GPR_MEM(RD), _addr, _fault);			\
+        if (_fault != md_fault_none)					\
+          DECLARE_FAULT(_fault);					\
+									\
+	SET_GPR(RN, _addr);						\
+      }									\
+  }
+DEFINST(STR_RPBW,		0x06,
+	"str%cb",		"%d,[%n, -%m]!",
+	WrPort,			F_MEM|F_STORE|F_DISP|F_CISC,
+	DGPR(RN), DNA, DNA,	DGPR(RD), /**/DCONDSH, DGPR(RN), DGPR(RM))
+
+#define LDR_RPBWL_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+        enum md_fault_type _fault;					\
+        byte_t _result;							\
+	md_addr_t _addr;						\
+									\
+        /* register shift amounts not allowed for ld/st (THANK YOU!) */	\
+        if (SHIFT_REG)							\
+          DECLARE_FAULT(md_fault_unimpl);				\
+									\
+	_addr = GPR_EX(RN) - SHIFTRM(GPR(RM), /* unused */0, PSR_C);	\
+        _result = READ_BYTE(_addr, _fault);				\
+        if (_fault != md_fault_none)					\
+          DECLARE_FAULT(_fault);					\
+									\
+	SET_GPR(RN, _addr);						\
+        SET_GPR(RD, (word_t)_result);					\
+      }									\
+  }
+DEFINST(LDR_RPBWL,		0x07,
+	"ldr%cb",		"%d,[%n, -%m]!",
+	RdPort,			F_MEM|F_LOAD|F_DISP|F_CISC,
+	DGPR(RD),DGPR(RN),DNA,	DNA, /**/DCONDSH, DGPR(RN), DGPR(RM))
+
+#define STR_RPU_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+        enum md_fault_type _fault;					\
+	md_addr_t _addr;						\
+									\
+        /* register shift amounts not allowed for ld/st (THANK YOU!) */	\
+        if (SHIFT_REG)							\
+          DECLARE_FAULT(md_fault_unimpl);				\
+									\
+	_addr = GPR_EX(RN) + SHIFTRM(GPR(RM), /* unused */0, PSR_C);	\
+        WRITE_WORD(GPR_MEM(RD), _addr, _fault);				\
+        if (_fault != md_fault_none)					\
+          DECLARE_FAULT(_fault);					\
+      }									\
+  }
+DEFINST(STR_RPU,		0x08,
+	"str%c",		"%d,[%n, %m]",
+	WrPort,			F_MEM|F_STORE|F_DISP|F_CISC,
+	DNA, DNA, DNA,		DGPR(RD), /**/DCONDSH, DGPR(RN), DGPR(RM))
+
+#define LDR_RPUL_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+        enum md_fault_type _fault;					\
+	md_addr_t _addr;						\
+        word_t _result;							\
+									\
+        /* register shift amounts not allowed for ld/st (THANK YOU!) */	\
+        if (SHIFT_REG)							\
+          DECLARE_FAULT(md_fault_unimpl);				\
+									\
+	_addr = GPR_EX(RN) + SHIFTRM(GPR(RM), /* unused */0, PSR_C);	\
+        _result = READ_WORD(_addr, _fault);				\
+        if (_fault != md_fault_none)					\
+          DECLARE_FAULT(_fault);					\
+									\
+        SET_GPR(RD, _result);						\
+      }									\
+  }
+DEFINST(LDR_RPUL,		0x09,
+	"ldr%c",		"%d,[%n, %m]",
+	RdPort,			F_MEM|F_LOAD|F_DISP|F_CISC,
+	DGPR(RD), DNA, DNA,	DNA, /**/DCONDSH, DGPR(RN), DGPR(RM))
+
+#define STR_RPUW_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+        enum md_fault_type _fault;					\
+        md_addr_t _addr;						\
+									\
+        /* register shift amounts not allowed for ld/st (THANK YOU!) */	\
+        if (SHIFT_REG)							\
+          DECLARE_FAULT(md_fault_unimpl);				\
+									\
+        _addr = GPR_EX(RN) + SHIFTRM(GPR(RM), /* unused */0, PSR_C);	\
+        WRITE_WORD(GPR_MEM(RD), _addr, _fault);				\
+        if (_fault != md_fault_none)					\
+          DECLARE_FAULT(_fault);					\
+									\
+        SET_GPR(RN, _addr);						\
+      }									\
+  }
+DEFINST(STR_RPUW,		0x0a,
+	"str%c",		"%d,[%n, %m]!",
+	WrPort,			F_MEM|F_STORE|F_DISP|F_CISC,
+	DGPR(RN), DNA, DNA,	DGPR(RD), /**/DCONDSH, DGPR(RN), DGPR(RM))
+
+#define LDR_RPUWL_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+        md_addr_t _addr;						\
+        word_t _result;							\
+        enum md_fault_type _fault;					\
+									\
+        /* register shift amounts not allowed for ld/st (THANK YOU!) */	\
+        if (SHIFT_REG)							\
+          DECLARE_FAULT(md_fault_unimpl);				\
+									\
+        _addr = GPR_EX(RN) + SHIFTRM(GPR(RM), /* unused */0, PSR_C);	\
+        _result = READ_WORD(_addr, _fault);				\
+        if (_fault != md_fault_none)					\
+          DECLARE_FAULT(_fault);					\
+									\
+        SET_GPR(RN, _addr);						\
+        SET_GPR(RD, _result);						\
+      }									\
+  }
+DEFINST(LDR_RPUWL,		0x0b,
+	"ldr%c",		"%d,[%n, %m]!",
+	RdPort,			F_MEM|F_LOAD|F_DISP|F_CISC,
+	DGPR(RD),DGPR(RN),DNA,	DNA, /**/DCONDSH, DGPR(RN), DGPR(RM))
+
+#define STR_RPUB_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	md_addr_t _addr;						\
+        enum md_fault_type _fault;					\
+									\
+        /* register shift amounts not allowed for ld/st (THANK YOU!) */	\
+        if (SHIFT_REG)							\
+          DECLARE_FAULT(md_fault_unimpl);				\
+									\
+	_addr = GPR_EX(RN) + SHIFTRM(GPR(RM), /* unused */0, PSR_C);	\
+        WRITE_BYTE((byte_t)GPR_MEM(RD), _addr, _fault);			\
+        if (_fault != md_fault_none)					\
+          DECLARE_FAULT(_fault);					\
+      }									\
+  }
+DEFINST(STR_RPUB,		0x0c,
+	"str%cb",		"%d,[%n, %m]",
+	WrPort,			F_MEM|F_STORE|F_DISP|F_CISC,
+	DNA, DNA, DNA,		DGPR(RD), /**/DCONDSH, DGPR(RN), DGPR(RM))
+
+#define LDR_RPUBL_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+        byte_t _result;							\
+	md_addr_t _addr;						\
+        enum md_fault_type _fault;					\
+									\
+	_addr = GPR_EX(RN) + SHIFTRM(GPR(RM), /* unused */0, PSR_C);	\
+        _result = READ_BYTE(_addr, _fault);				\
+        if (_fault != md_fault_none)					\
+          DECLARE_FAULT(_fault);					\
+									\
+        SET_GPR(RD, (word_t)_result);					\
+      }									\
+  }
+DEFINST(LDR_RPUBL,		0x0d,
+	"ldr%cb",		"%d,[%n, %m]",
+	RdPort,			F_MEM|F_LOAD|F_DISP|F_CISC,
+	DGPR(RD), DNA, DNA,	DNA, /**/DCONDSH, DGPR(RN), DGPR(RM))
+
+#define STR_RPUBW_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+        enum md_fault_type _fault;					\
+        md_addr_t _addr;						\
+									\
+        _addr = GPR_EX(RN) + SHIFTRM(GPR(RM), /* unused */0, PSR_C);	\
+        WRITE_BYTE((byte_t)GPR_MEM(RD), _addr, _fault);			\
+        if (_fault != md_fault_none)					\
+          DECLARE_FAULT(_fault);					\
+									\
+        SET_GPR(RN, _addr);						\
+      }									\
+  }
+DEFINST(STR_RPUBW,		0x0e,
+	"str%cb",		"%d,[%n, %m]!",
+	WrPort,			F_MEM|F_STORE|F_DISP|F_CISC,
+	DGPR(RN), DNA, DNA,	DGPR(RD), /**/DCONDSH, DGPR(RN), DGPR(RM))
+
+#define LDR_RPUBWL_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+        byte_t _result;							\
+        md_addr_t _addr;						\
+        enum md_fault_type _fault;					\
+									\
+        _addr = GPR_EX(RN) + SHIFTRM(GPR(RM), /* unused */0, PSR_C);	\
+        _result = READ_BYTE(_addr, _fault);				\
+        if (_fault != md_fault_none)					\
+          DECLARE_FAULT(_fault);					\
+									\
+        SET_GPR(RN, _addr);						\
+        SET_GPR(RD, (word_t)_result);					\
+      }									\
+  }
+DEFINST(LDR_RPUBWL,		0x0f,
+	"ldr%cb",		"%d,[%n, %m]!",
+	RdPort,			F_MEM|F_LOAD|F_DISP|F_CISC,
+	DGPR(RD),DGPR(RN),DNA,	DNA, /**/DCONDSH, DGPR(RN), DGPR(RM))
+
+
+CONNECT(BLKPOST_LINK)
+
+#define STM_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	int _i;								\
+        enum md_fault_type _fault;					\
+	md_addr_t _addr;						\
+									\
+	_addr = GPR_EX(RN) - (ONES(REGLIST) << 2) + 4;			\
+	for (_i=0; _i < 16; _i++)					\
+	  {								\
+	    if (REGLIST & (1 << _i))					\
+	      {								\
+		/* store reg(_i) */					\
+		WRITE_WORD(GPR_MEM(_i), _addr, _fault);			\
+		if (_fault != md_fault_none)				\
+		  DECLARE_FAULT(_fault);				\
+		_addr += 4;						\
+	      }								\
+	  }								\
+      }									\
+  }
+DEFINST(STM,			0x00,
+	"stm%c%a",		"%n,%R",
+	WrPort,			F_MEM|F_STORE|F_DISP|F_CISC,
+	DNA, DNA, DNA,		DNA, DNA, DNA, DNA)
+
+#define LDM_L_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	int _i;								\
+        enum md_fault_type _fault;					\
+	md_addr_t _addr;						\
+        word_t _result;							\
+									\
+	_addr = GPR_EX(RN) - (ONES(REGLIST) << 2) + 4;			\
+	for (_i=0; _i < 16; _i++)					\
+	  {								\
+	    if (REGLIST & (1 << _i))					\
+	      {								\
+		/* store reg(_i) */					\
+		_result = READ_WORD(_addr & ~3, _fault);		\
+		if (_fault != md_fault_none)				\
+		  DECLARE_FAULT(_fault);				\
+		SET_GPR(_i, _result);					\
+		_addr += 4;						\
+	      }								\
+	  }								\
+      }									\
+  }
+DEFINST(LDM_L,			0x01,
+	"ldm%c%a",		"%n,%R",
+	RdPort,			F_MEM|F_STORE|F_DISP|F_CISC,
+	DNA, DNA, DNA,		DNA, DNA, DNA, DNA)
+
+#define STM_W_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	int _i, _first = TRUE;						\
+        enum md_fault_type _fault;					\
+	md_addr_t _addr, _wbaddr;					\
+									\
+	_addr = GPR_EX(RN) - (ONES(REGLIST) << 2) + 4;			\
+	_wbaddr = GPR_EX(RN) - (ONES(REGLIST) << 2);			\
+	for (_i=0; _i < 16; _i++)					\
+	  {								\
+	    if (REGLIST & (1 << _i))					\
+	      {								\
+		/* store reg(_i) */					\
+		WRITE_WORD(GPR_BASE(_i), _addr, _fault);		\
+		if (_fault != md_fault_none)				\
+		  DECLARE_FAULT(_fault);				\
+		_addr += 4;						\
+									\
+		/* done processing first register */			\
+		_first = FALSE;						\
+	      }								\
+	  }								\
+	SET_GPR(RN, _wbaddr);						\
+      }									\
+  }
+DEFINST(STM_W,			0x02,
+	"stm%c%a",		"%n!,%R",
+	WrPort,			F_MEM|F_STORE|F_DISP|F_CISC,
+	DNA, DNA, DNA,		DNA, DNA, DNA, DNA)
+
+#define LDM_WL_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	int _i;								\
+        enum md_fault_type _fault;					\
+	md_addr_t _addr, _wbaddr;					\
+        word_t _result;							\
+									\
+	_addr = GPR_EX(RN) - (ONES(REGLIST) << 2) + 4;			\
+	_wbaddr = GPR_EX(RN) - (ONES(REGLIST) << 2);			\
+	SET_GPR(RN, _wbaddr);						\
+	for (_i=0; _i < 16; _i++)					\
+	  {								\
+	    if (REGLIST & (1 << _i))					\
+	      {								\
+		/* store reg(_i) */					\
+		_result = READ_WORD(_addr & ~3, _fault);		\
+		if (_fault != md_fault_none)				\
+		  DECLARE_FAULT(_fault);				\
+		SET_GPR(_i, _result);					\
+		_addr += 4;						\
+	      }								\
+	  }								\
+      }									\
+  }
+DEFINST(LDM_WL,			0x03,
+	"ldm%c%a",		"%n!,%R",
+	RdPort,			F_MEM|F_STORE|F_DISP|F_CISC,
+	DNA, DNA, DNA,		DNA, DNA, DNA, DNA)
+
+
+/* STM_S, 0x04, TODO... */
+
+#define STM_S_IMPL
+DEFINST(STM_S,			0x04,
+	"stm%c%a",		"%n,%R",
+	WrPort,			F_MEM|F_STORE|F_DISP|F_CISC,
+	DNA, DNA, DNA,		DNA, DNA, DNA, DNA)
+
+
+/* LDM_SL, 0x05, TODO... */
+
+#define LDM_SL_IMPL
+DEFINST(LDM_SL,			0x05,
+	"stm%c%a",		"%n,%R",
+	RdPort,			F_MEM|F_STORE|F_DISP|F_CISC,
+	DNA, DNA, DNA,		DNA, DNA, DNA, DNA)
+
+/* STM_SW, 0x06, TODO... */
+
+#define STM_SW_IMPL
+DEFINST(STM_SW,			0x06,
+	"stm%c%a",		"%n!,%R",
+	WrPort,			F_MEM|F_STORE|F_DISP|F_CISC,
+	DNA, DNA, DNA,		DNA, DNA, DNA, DNA)
+
+
+/* LDM_SWL, 0x07, TODO... */
+
+#define LDM_SWL_IMPL
+DEFINST(LDM_SWL,			0x07,
+	"stm%c%a",		"%n!,%R",
+	RdPort,			F_MEM|F_STORE|F_DISP|F_CISC,
+	DNA, DNA, DNA,		DNA, DNA, DNA, DNA)
+
+#define STM_U_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	int _i;								\
+        enum md_fault_type _fault;					\
+	md_addr_t _addr;						\
+									\
+	_addr = GPR_EX(RN);						\
+	for (_i=0; _i < 16; _i++)					\
+	  {								\
+	    if (REGLIST & (1 << _i))					\
+	      {								\
+		/* store reg(_i) */					\
+		WRITE_WORD(GPR_MEM(_i), _addr, _fault);			\
+		if (_fault != md_fault_none)				\
+		  DECLARE_FAULT(_fault);				\
+		_addr += 4;						\
+	      }								\
+	  }								\
+      }									\
+  }
+DEFINST(STM_U,			0x08,
+	"stm%c%a",		"%n,%R",
+	WrPort,			F_MEM|F_STORE|F_DISP|F_CISC,
+	DNA, DNA, DNA,		DNA, DNA, DNA, DNA)
+
+#define LDM_UL_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	int _i;								\
+        enum md_fault_type _fault;					\
+	md_addr_t _addr;						\
+        word_t _result;							\
+									\
+	_addr = GPR_EX(RN);						\
+	for (_i=0; _i < 16; _i++)					\
+	  {								\
+	    if (REGLIST & (1 << _i))					\
+	      {								\
+		/* store reg(_i) */					\
+		_result = READ_WORD(_addr & ~3, _fault);		\
+		if (_fault != md_fault_none)				\
+		  DECLARE_FAULT(_fault);				\
+		SET_GPR(_i, _result);					\
+		_addr += 4;						\
+	      }								\
+	  }								\
+      }									\
+  }
+DEFINST(LDM_UL,			0x09,
+	"ldm%c%a",		"%n,%R",
+	RdPort,			F_MEM|F_STORE|F_DISP|F_CISC,
+	DNA, DNA, DNA,		DNA, DNA, DNA, DNA)
+
+#define STM_UW_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	int _i, _first = TRUE;						\
+        enum md_fault_type _fault;					\
+	md_addr_t _addr, _wbaddr;					\
+									\
+	_addr = GPR_EX(RN);						\
+	_wbaddr = GPR(RN) + (ONES(REGLIST) << 2);			\
+	for (_i=0; _i < 16; _i++)					\
+	  {								\
+	    if (REGLIST & (1 << _i))					\
+	      {								\
+		/* store reg(_i) */					\
+		WRITE_WORD(GPR_BASE(_i), _addr, _fault);		\
+		if (_fault != md_fault_none)				\
+		  DECLARE_FAULT(_fault);				\
+		_addr += 4;						\
+									\
+		/* done processing first register */			\
+		_first = FALSE;						\
+	      }								\
+	  }								\
+	SET_GPR(RN, _wbaddr);						\
+      }									\
+  }
+DEFINST(STM_UW,			0x0a,
+	"stm%c%a",		"%n!,%R",
+	WrPort,			F_MEM|F_STORE|F_DISP|F_CISC,
+	DNA, DNA, DNA,		DNA, DNA, DNA, DNA)
+
+#define LDM_UWL_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	int _i;								\
+        enum md_fault_type _fault;					\
+	md_addr_t _addr, _wbaddr;					\
+        word_t _result;							\
+									\
+	_addr = GPR_EX(RN);						\
+	_wbaddr = GPR_EX(RN) + (ONES(REGLIST) << 2);			\
+	SET_GPR(RN, _wbaddr);						\
+	for (_i=0; _i < 16; _i++)					\
+	  {								\
+	    if (REGLIST & (1 << _i))					\
+	      {								\
+		/* store reg(_i) */					\
+		_result = READ_WORD(_addr & ~3, _fault);		\
+		if (_fault != md_fault_none)				\
+		  DECLARE_FAULT(_fault);				\
+		SET_GPR(_i, _result);					\
+		_addr += 4;						\
+	      }								\
+	  }								\
+      }									\
+  }
+DEFINST(LDM_UWL,		0x0b,
+	"ldm%c%a",		"%n!,%R", 
+	RdPort,			F_MEM|F_STORE|F_DISP|F_CISC,
+	DNA, DNA, DNA,		DNA, DNA, DNA, DNA)
+
+/* STM_US, 0x0c, TODO... */
+#define STM_US_IMPL
+DEFINST(STM_US,			0x0c,
+	"stm%c%a",		"%n,%R",
+	WrPort,			F_MEM|F_STORE|F_DISP|F_CISC,
+	DNA, DNA, DNA,		DNA, DNA, DNA, DNA)
+
+/* LDM_USL, 0x0d, TODO... */
+#define LDM_USL_IMPL
+DEFINST(LDM_USL,			0x0d,
+	"stm%c%a",		"%n,%R",
+	WrPort,			F_MEM|F_STORE|F_DISP|F_CISC,
+	DNA, DNA, DNA,		DNA, DNA, DNA, DNA)
+
+/* STM_USW, 0x0e, TODO... */
+
+#define STM_USW_IMPL
+DEFINST(STM_USW,			0x0e,
+	"stm%c%a",		"%n,%R",
+	WrPort,			F_MEM|F_STORE|F_DISP|F_CISC,
+	DNA, DNA, DNA,		DNA, DNA, DNA, DNA)
+
+
+/* LDM_USWL, 0x0f, TODO... */
+
+#define LDM_USWL_IMPL
+DEFINST(LDM_USWL,			0x0f,
+	"stm%c%a",		"%n,%R",
+	WrPort,			F_MEM|F_STORE|F_DISP|F_CISC,
+	DNA, DNA, DNA,		DNA, DNA, DNA, DNA)
+
+CONNECT(BLKPRE_LINK)
+
+#define STM_P_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	int _i;								\
+        enum md_fault_type _fault;					\
+	md_addr_t _addr;						\
+									\
+	_addr = GPR_EX(RN) - (ONES(REGLIST) << 2);			\
+	for (_i=0; _i < 16; _i++)					\
+	  {								\
+	    if (REGLIST & (1 << _i))					\
+	      {								\
+		/* store reg(_i) */					\
+		WRITE_WORD(GPR_MEM(_i), _addr, _fault);			\
+		if (_fault != md_fault_none)				\
+		  DECLARE_FAULT(_fault);				\
+		_addr += 4;						\
+	      }								\
+	  }								\
+      }									\
+  }
+DEFINST(STM_P,			0x00,
+	"stm%c%a",		"%n,%R",
+	WrPort,			F_MEM|F_STORE|F_DISP|F_CISC,
+	DNA, DNA, DNA,		DNA, DNA, DNA, DNA)
+
+#define LDM_PL_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	int _i;								\
+        enum md_fault_type _fault;					\
+	md_addr_t _addr;						\
+        word_t _result;							\
+									\
+	_addr = GPR_EX(RN) - (ONES(REGLIST) << 2);			\
+	for (_i=0; _i < 16; _i++)					\
+	  {								\
+	    if (REGLIST & (1 << _i))					\
+	      {								\
+		/* store reg(_i) */					\
+		_result = READ_WORD(_addr & ~3, _fault);		\
+		if (_fault != md_fault_none)				\
+		  DECLARE_FAULT(_fault);				\
+		SET_GPR(_i, _result);					\
+		_addr += 4;						\
+	      }								\
+	  }								\
+      }									\
+  }
+DEFINST(LDM_PL,			0x01,
+	"ldm%c%a",		"%n,%R",
+	RdPort,			F_MEM|F_STORE|F_DISP|F_CISC,
+	DNA, DNA, DNA,		DNA, DNA, DNA, DNA)
+
+#define STM_PW_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	int _i, _first = TRUE;						\
+        enum md_fault_type _fault;					\
+	md_addr_t _addr, _wbaddr;					\
+									\
+	_addr = GPR_EX(RN) - (ONES(REGLIST) << 2);			\
+	_wbaddr = GPR_EX(RN) - (ONES(REGLIST) << 2);			\
+	for (_i=0; _i < 16; _i++)					\
+	  {								\
+	    if (REGLIST & (1 << _i))					\
+	      {								\
+		/* store reg(_i) */					\
+		WRITE_WORD(GPR_BASE(_i), _addr, _fault);		\
+		if (_fault != md_fault_none)				\
+		  DECLARE_FAULT(_fault);				\
+		_addr += 4;						\
+									\
+		/* done processing first register */			\
+		_first = FALSE;						\
+	      }								\
+	  }								\
+	SET_GPR(RN, _wbaddr);						\
+      }									\
+  }
+DEFINST(STM_PW,			0x02,
+	"stm%c%a",		"%n!,%R",
+	WrPort,			F_MEM|F_STORE|F_DISP|F_CISC,
+	DNA, DNA, DNA,		DNA, DNA, DNA, DNA)
+
+#define LDM_PWL_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	int _i;								\
+        enum md_fault_type _fault;					\
+	md_addr_t _addr, _wbaddr;					\
+        word_t _result;							\
+									\
+	_addr = GPR_EX(RN) - (ONES(REGLIST) << 2);			\
+	_wbaddr = GPR_EX(RN) - (ONES(REGLIST) << 2);			\
+	SET_GPR(RN, _wbaddr);						\
+	for (_i=0; _i < 16; _i++)					\
+	  {								\
+	    if (REGLIST & (1 << _i))					\
+	      {								\
+		/* store reg(_i) */					\
+		_result = READ_WORD(_addr & ~3, _fault);		\
+		if (_fault != md_fault_none)				\
+		  DECLARE_FAULT(_fault);				\
+		SET_GPR(_i, _result);					\
+		_addr += 4;						\
+	      }								\
+	  }								\
+      }									\
+  }
+DEFINST(LDM_PWL,       		0x03,
+	"ldm%c%a",		"%n!,%R",
+	RdPort,			F_MEM|F_STORE|F_DISP|F_CISC,
+	DNA, DNA, DNA,		DNA, DNA, DNA, DNA)
+
+/* STM_PS, 0x04, TODO... */
+
+#define STM_PS_IMPL
+DEFINST(STM_PS,			0x04,
+	"stm%c%a",		"%n,%R",
+	WrPort,			F_MEM|F_STORE|F_DISP|F_CISC,
+	DNA, DNA, DNA,		DNA, DNA, DNA, DNA)
+
+
+/* LDM_PSL, 0x05, TODO... */
+
+#define LDM_PSL_IMPL
+DEFINST(LDM_PSL,			0x05,
+	"stm%c%a",		"%n,%R",
+	RdPort,			F_MEM|F_STORE|F_DISP|F_CISC,
+	DNA, DNA, DNA,		DNA, DNA, DNA, DNA)
+
+/* STM_PSW, 0x06, TODO... */
+
+#define STM_PSW_IMPL
+DEFINST(STM_PSW,			0x06,
+	"stm%c%a",		"%n!,%R",
+	WrPort,			F_MEM|F_STORE|F_DISP|F_CISC,
+	DNA, DNA, DNA,		DNA, DNA, DNA, DNA)
+
+
+/* LDM_PSWL, 0x07, TODO... */
+
+#define LDM_PSWL_IMPL
+DEFINST(LDM_PSWL,			0x07,
+	"stm%c%a",		"%n!,%R",
+	RdPort,			F_MEM|F_STORE|F_DISP|F_CISC,
+	DNA, DNA, DNA,		DNA, DNA, DNA, DNA)
+
+#define STM_PU_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	int _i;								\
+        enum md_fault_type _fault;					\
+	md_addr_t _addr;						\
+									\
+	_addr = GPR_EX(RN) + 4;						\
+	for (_i=0; _i < 16; _i++)					\
+	  {								\
+	    if (REGLIST & (1 << _i))					\
+	      {								\
+		/* store reg(_i) */					\
+		WRITE_WORD(GPR_MEM(_i), _addr, _fault);			\
+		if (_fault != md_fault_none)				\
+		  DECLARE_FAULT(_fault);				\
+		_addr += 4;						\
+	      }								\
+	  }								\
+      }									\
+  }
+DEFINST(STM_PU,			0x08,
+	"stm%c%a",		"%n,%R",
+	WrPort,			F_MEM|F_STORE|F_DISP|F_CISC,
+	DNA, DNA, DNA,		DNA, DNA, DNA, DNA)
+
+#define LDM_PUL_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	int _i;								\
+        enum md_fault_type _fault;					\
+	md_addr_t _addr;						\
+        word_t _result;							\
+									\
+	_addr = GPR_EX(RN) + 4;						\
+	for (_i=0; _i < 16; _i++)					\
+	  {								\
+	    if (REGLIST & (1 << _i))					\
+	      {								\
+		/* store reg(_i) */					\
+		_result = READ_WORD(_addr & ~3, _fault);		\
+		if (_fault != md_fault_none)				\
+		  DECLARE_FAULT(_fault);				\
+		SET_GPR(_i, _result);					\
+		_addr += 4;						\
+	      }								\
+	  }								\
+      }									\
+  }
+DEFINST(LDM_PUL,       		0x09,
+	"ldm%c%a",		"%n,%R",
+	RdPort,			F_MEM|F_STORE|F_DISP|F_CISC,
+	DNA, DNA, DNA,		DNA, DNA, DNA, DNA)
+
+#define STM_PUW_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	int _i, _first = TRUE;						\
+        enum md_fault_type _fault;					\
+	md_addr_t _addr, _wbaddr;					\
+									\
+	_addr = GPR_EX(RN) + 4;						\
+	_wbaddr = GPR_EX(RN) + (ONES(REGLIST) << 2);			\
+	for (_i=0; _i < 16; _i++)					\
+	  {								\
+	    if (REGLIST & (1 << _i))					\
+	      {								\
+		/* store reg(_i) */					\
+		WRITE_WORD(GPR_BASE(_i), _addr, _fault);		\
+		if (_fault != md_fault_none)				\
+		  DECLARE_FAULT(_fault);				\
+		_addr += 4;						\
+									\
+		/* done processing first register */			\
+		_first = FALSE;						\
+	      }								\
+	  }								\
+	SET_GPR(RN, _wbaddr);						\
+      }									\
+  }
+DEFINST(STM_PUW,       		0x0a,
+	"stm%c%a",		"%n!,%R",
+	WrPort,			F_MEM|F_STORE|F_DISP|F_CISC,
+	DNA, DNA, DNA,		DNA, DNA, DNA, DNA)
+
+#define LDM_PUWL_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	int _i;								\
+        enum md_fault_type _fault;					\
+	md_addr_t _addr, _wbaddr;					\
+        word_t _result;							\
+									\
+	_addr = GPR_EX(RN) + 4;						\
+	_wbaddr = GPR_EX(RN) + (ONES(REGLIST) << 2);			\
+	SET_GPR(RN, _wbaddr);						\
+	for (_i=0; _i < 16; _i++)					\
+	  {								\
+	    if (REGLIST & (1 << _i))					\
+	      {								\
+		/* store reg(_i) */					\
+		_result = READ_WORD(_addr & ~3, _fault);		\
+		if (_fault != md_fault_none)				\
+		  DECLARE_FAULT(_fault);				\
+		SET_GPR(_i, _result);					\
+		_addr += 4;						\
+	      }								\
+	  }								\
+      }									\
+  }
+DEFINST(LDM_PUWL,		0x0b,
+	"ldm%c%a",		"%n!,%R",
+	RdPort,			F_MEM|F_STORE|F_DISP|F_CISC,
+	DNA, DNA, DNA,		DNA, DNA, DNA, DNA)
+
+
+/* STM_PUS, 0x0c, TODO... */
+#define STM_PUS_IMPL
+DEFINST(STM_PUS,			0x0c,
+	"stm%c%a",		"%n,%R",
+	WrPort,			F_MEM|F_STORE|F_DISP|F_CISC,
+	DNA, DNA, DNA,		DNA, DNA, DNA, DNA)
+
+/* LDM_PUSL, 0x0d, TODO... */
+#define LDM_PUSL_IMPL
+DEFINST(LDM_PUSL,			0x0d,
+	"stm%c%a",		"%n,%R",
+	WrPort,			F_MEM|F_STORE|F_DISP|F_CISC,
+	DNA, DNA, DNA,		DNA, DNA, DNA, DNA)
+
+/* STM_PUSW, 0x0e, TODO... */
+
+#define STM_PUSW_IMPL
+DEFINST(STM_PUSW,			0x0e,
+	"stm%c%a",		"%n,%R",
+	WrPort,			F_MEM|F_STORE|F_DISP|F_CISC,
+	DNA, DNA, DNA,		DNA, DNA, DNA, DNA)
+
+
+/* LDM_PUSWL, 0x0f, TODO... */
+
+#define LDM_PUSWL_IMPL
+DEFINST(LDM_PUSWL,			0x0f,
+	"stm%c%a",		"%n,%R",
+	WrPort,			F_MEM|F_STORE|F_DISP|F_CISC,
+	DNA, DNA, DNA,		DNA, DNA, DNA, DNA)
+
+
+CONNECT(CPROC_LINK)
+
+DEFLINK(FPA_LINK, 0x01, "fpa_link", 4, 0x01)
+
+
+CONNECT(FPA_LINK)
+
+DEFLINK(CPDO_LINK, 0x00, "cpdo_link", 20, 0x0f)
+
+DEFLINK(CPRTCMF_LINK, 0x01, "cprtcmf_link", 12, 0x0f)
+
+
+CONNECT(CPRTCMF_LINK)
+
+DEFLINK(CPRT_CDP_LINK, 0x0e00, "cprt_cdp_link", 4, 0x01)
+
+DEFLINK(CMF_LINK, 0x0f, "cmf_link", 21, 0x07)
+
+
+/* FP coprocessor data operations (CPDO) */
+
+CONNECT(CPDO_LINK)
+
+DEFLINK(ADFMVF_LINK, 0x00, "adfmvf_link", 15, 0x01)
+
+DEFLINK(MUFMNF_LINK, 0x01, "mufmnf_link", 15, 0x01)
+
+DEFLINK(SUFABS_LINK, 0x02, "sufabs_link", 15, 0x01)
+
+DEFLINK(RSFRND_LINK, 0x03, "rsfrnd_link", 15, 0x01)
+
+DEFLINK(DVFSQT_LINK, 0x04, "dvfsqt_link", 15, 0x01)
+
+DEFLINK(RDFLOG_LINK, 0x05, "rdflog_link", 15, 0x01)
+
+DEFLINK(POWLGN_LINK, 0x06, "powlgn_link", 15, 0x01)
+
+DEFLINK(RPWEXP_LINK, 0x07, "rpwexp_link", 15, 0x01)
+
+DEFLINK(RMFSIN_LINK, 0x08, "rmfsin_link", 15, 0x01)
+
+DEFLINK(FMLCOS_LINK, 0x09, "fmlcos_link", 15, 0x01)
+
+DEFLINK(FDVTAN_LINK, 0x0a, "fdvtan_link", 15, 0x01)
+
+DEFLINK(FRDASN_LINK, 0x0b, "frdasn_link", 15, 0x01)
+
+DEFLINK(POLACS_LINK, 0x0c, "polacs_link", 15, 0x01)
+
+DEFLINK(UNDATN_LINK, 0x0d, "undatn_link", 15, 0x01)
+
+DEFLINK(UNDURD_LINK, 0x0e, "undurd_link", 15, 0x01)
+
+DEFLINK(UNDNRM_LINK, 0x0f, "undnrm_link", 15, 0x01)
+
+
+CONNECT(ADFMVF_LINK)
+
+DEFLINK(ADFADFI_LINK, 0x00, "adfadfi_link", 3, 0x01)
+
+DEFLINK(MVFMVFI_LINK, 0x01, "mvfmvfi_link", 3, 0x01)
+
+
+CONNECT(MUFMNF_LINK)
+
+DEFLINK(MUFMUFI_LINK, 0x00, "mufmufi_link", 3, 0x01)
+
+DEFLINK(MNFMNFI_LINK, 0x01, "mnfmnfi_link", 3, 0x01)
+
+
+CONNECT(SUFABS_LINK)
+
+DEFLINK(SUFSUFI_LINK, 0x00, "sufsufi_link", 3, 0x01)
+
+DEFLINK(ABSABSI_LINK, 0x01, "absabsi_link", 3, 0x01)
+
+
+CONNECT(RSFRND_LINK)
+
+DEFLINK(RSFRSFI_LINK, 0x00, "rsfrsfi_link", 3, 0x01)
+
+DEFLINK(RNDRNDI_LINK, 0x01, "rndrndi_link", 3, 0x01)
+
+
+CONNECT(DVFSQT_LINK)
+
+DEFLINK(DVFDVFI_LINK, 0x00, "dvfdvfi_link", 3, 0x01)
+
+DEFLINK(SQTSQTI_LINK, 0x01, "sqtsqti_link", 3, 0x01)
+
+
+CONNECT(RDFLOG_LINK)
+
+DEFLINK(RDFRDFI_LINK, 0x00, "rdfrdfi_link", 3, 0x01)
+
+DEFLINK(LOGLOGI_LINK, 0x01, "loglogi_link", 3, 0x01)
+
+
+CONNECT(POWLGN_LINK)
+
+DEFLINK(POWPOWI_LINK, 0x00, "powpowi_link", 3, 0x01)
+
+DEFLINK(LGNLGNI_LINK, 0x01, "lgnlgni_link", 3, 0x01)
+
+
+CONNECT(RPWEXP_LINK)
+
+DEFLINK(RPWRPWI_LINK, 0x00, "rpwrpwi_link", 3, 0x01)
+
+DEFLINK(EXPEXPI_LINK, 0x01, "expexpi_link", 3, 0x01)
+
+
+CONNECT(RMFSIN_LINK)
+
+DEFLINK(RMFRMFI_LINK, 0x00, "rmfrmfi_link", 3, 0x01)
+
+DEFLINK(SINSINI_LINK, 0x01, "sinsini_link", 3, 0x01)
+
+
+CONNECT(FMLCOS_LINK)
+
+DEFLINK(FMLFMLI_LINK, 0x00, "fmlfmli_link", 3, 0x01)
+
+DEFLINK(COSCOSI_LINK, 0x01, "coscosi_link", 3, 0x01)
+
+
+CONNECT(FDVTAN_LINK)
+
+DEFLINK(FDVFDVI_LINK, 0x00, "fdvfdvi_link", 3, 0x01)
+
+DEFLINK(TANTANI_LINK, 0x01, "tantani_link", 3, 0x01)
+
+
+CONNECT(FRDASN_LINK)
+
+DEFLINK(FRDFRDI_LINK, 0x00, "frdfrdi_link", 3, 0x01)
+
+DEFLINK(ASNASNI_LINK, 0x01, "asnasni_link", 3, 0x01)
+
+
+CONNECT(POLACS_LINK)
+
+DEFLINK(POLPOLI_LINK, 0x00, "polpoli_link", 3, 0x01)
+
+DEFLINK(ACSACSI_LINK, 0x01, "acsacsi_link", 3, 0x01)
+
+
+CONNECT(UNDATN_LINK)
+
+DEFLINK(ATNATNI_LINK, 0x01, "atnatni_link", 3, 0x01)
+
+
+CONNECT(UNDURD_LINK)
+
+DEFLINK(URDURDI_LINK, 0x01, "urdurdi_link", 3, 0x01)
+
+
+CONNECT(UNDNRM_LINK)
+
+DEFLINK(NRMNRMI_LINK, 0x01, "nrmnrmi_link", 3, 0x01)
+
+
+CONNECT(ADFADFI_LINK)
+
+#define ADF_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	SET_FPR(FD, FPR(FN) + FPR(FM));					\
+      }									\
+  }
+DEFINST(ADF,			0x00,
+	"adf%c%t%r",		"%D,%N,%M",
+	FloatADD,		F_FCOMP,
+	DFPR(FD), DNA, DNA,	DCOND, DFPR(FN), DFPR(FM), DNA)
+
+#define ADFI_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	SET_FPR(FD, FPR(FN) + FPIMM);					\
+      }									\
+  }
+DEFINST(ADFI,			0x01,
+	"adf%c%t%r",		"%D,%N,#%I",
+	FloatADD,		F_FCOMP,
+	DFPR(FD), DNA, DNA,	DCOND, DFPR(FN), DNA, DNA)
+
+
+CONNECT(MVFMVFI_LINK)
+
+#define MVF_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	SET_FPR(FD, FPR(FM));						\
+      }									\
+  }
+DEFINST(MVF,			0x00,
+	"mvf%c%t%r",		"%D,%M",
+	FloatADD,		F_FCOMP,
+	DFPR(FD), DNA, DNA,	DCOND, DFPR(FM), DNA, DNA)
+
+#define MVFI_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	SET_FPR(FD, FPIMM);						\
+      }									\
+  }
+DEFINST(MVFI,			0x01,
+	"mvf%c%t%r",		"%D,#%I",
+	FloatADD,		F_FCOMP,
+	DFPR(FD), DNA, DNA,	DCOND, DNA, DNA, DNA)
+
+
+CONNECT(MUFMUFI_LINK)
+
+#define MUF_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	SET_FPR(FD, FPR(FN) * FPR(FM));					\
+      }									\
+  }
+DEFINST(MUF,			0x00,
+	"muf%c%t%r",		"%D,%N,%M",
+	FloatMULT,		F_FCOMP,
+	DFPR(FD), DNA, DNA,	DCOND, DFPR(FN), DFPR(FM), DNA)
+
+#define MUFI_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	SET_FPR(FD, FPR(FN) * FPIMM);					\
+      }									\
+  }
+DEFINST(MUFI,			0x01,
+	"muf%c%t%r",		"%D,%N,#%I",
+	FloatMULT,		F_FCOMP,
+	DFPR(FD), DNA, DNA,	DCOND, DFPR(FN), DNA, DNA)
+
+
+CONNECT(MNFMNFI_LINK)
+
+#define MNF_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	SET_FPR(FD, -FPR(FM));						\
+      }									\
+  }
+DEFINST(MNF,			0x00,
+	"mnf%c%t%r",		"%D,%M",
+	FloatADD,		F_FCOMP,
+	DFPR(FD), DNA, DNA,	DCOND, DFPR(FM), DNA, DNA)
+
+#define MNFI_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	SET_FPR(FD, -FPIMM);						\
+      }									\
+  }
+DEFINST(MNFI,			0x01,
+	"mnf%c%t%r",		"%D,#%I",
+	FloatADD,		F_FCOMP,
+	DFPR(FD), DNA, DNA,	DCOND, DNA, DNA, DNA)
+
+
+CONNECT(SUFSUFI_LINK)
+
+#define SUF_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	SET_FPR(FD, FPR(FN) - FPR(FM));					\
+      }									\
+  }
+DEFINST(SUF,			0x00,
+	"suf%c%t%r",		"%D,%N,%M",
+	FloatADD,		F_FCOMP,
+	DFPR(FD), DNA, DNA,	DCOND, DFPR(FN), DFPR(FM), DNA)
+
+#define SUFI_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	SET_FPR(FD, FPR(FN) - FPIMM);					\
+      }									\
+  }
+DEFINST(SUFI,			0x01,
+	"suf%c%t%r",		"%D,%N,#%I",
+	FloatADD,		F_FCOMP,
+	DFPR(FD), DNA, DNA,	DCOND, DFPR(FN), DNA, DNA)
+
+
+CONNECT(ABSABSI_LINK)
+
+#define ABS_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	SET_FPR(FD, fabs(FPR(FM)));					\
+      }									\
+  }
+DEFINST(ABS,			0x00,
+	"abs%c%t%r",		"%D,%M",
+	FloatADD,		F_FCOMP,
+	DFPR(FD), DNA, DNA,	DCOND, DFPR(FM), DNA, DNA)
+
+#define ABSI_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	SET_FPR(FD, fabs(FPIMM));					\
+      }									\
+  }
+DEFINST(ABSI,			0x01,
+	"abs%c%t%r",		"%D,#%I",
+	FloatADD,		F_FCOMP,
+	DFPR(FD), DNA, DNA,	DCOND, DNA, DNA, DNA)
+
+
+CONNECT(RSFRSFI_LINK)
+
+#define RSF_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	SET_FPR(FD, FPR(FM) - FPR(FN));					\
+      }									\
+  }
+DEFINST(RSF,			0x00,
+	"rsf%c%t%r",		"%D,%N,%M",
+	FloatADD,		F_FCOMP,
+	DFPR(FD), DNA, DNA,	DCOND, DFPR(FN), DFPR(FM), DNA)
+
+#define RSFI_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	SET_FPR(FD, FPIMM - FPR(FN));					\
+      }									\
+  }
+DEFINST(RSFI,			0x01,
+	"rsf%c%t%r",		"%D,%N,#%I",
+	FloatADD,		F_FCOMP,
+	DFPR(FD), DNA, DNA,	DCOND, DFPR(FN), DNA, DNA)
+
+
+CONNECT(RNDRNDI_LINK)
+
+#define RND_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	/* FIXME: need to track current rounding mode... */		\
+	SET_FPR(FD, rint(FPR(FM)));					\
+      }									\
+  }
+DEFINST(RND,			0x00,
+	"rnd%c%t%r",		"%D,%M",
+	FloatADD,		F_FCOMP,
+	DFPR(FD), DNA, DNA,	DCOND, DFPR(FM), DNA, DNA)
+
+#define RNDI_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	/* FIXME: need to track current rounding mode... */		\
+	SET_FPR(FD, rint(FPIMM));					\
+      }									\
+  }
+DEFINST(RNDI,			0x01,
+	"rnd%c%t%r",		"%D,#%I",
+	FloatADD,		F_FCOMP,
+	DFPR(FD), DNA, DNA,	DCOND, DNA, DNA, DNA)
+
+
+CONNECT(DVFDVFI_LINK)
+
+#define DVF_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	SET_FPR(FD, FPR(FN) / FPR(FM));					\
+      }									\
+  }
+DEFINST(DVF,			0x00,
+	"dvf%c%t%r",		"%D,%N,%M",
+	FloatDIV,		F_FCOMP,
+	DFPR(FD), DNA, DNA,	DCOND, DFPR(FN), DFPR(FM), DNA)
+
+#define DVFI_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	SET_FPR(FD, FPR(FN) / FPIMM);					\
+      }									\
+  }
+DEFINST(DVFI,			0x01,
+	"dvf%c%t%r",		"%D,%N,#%I",
+	FloatDIV,		F_FCOMP,
+	DFPR(FD), DNA, DNA,	DCOND, DFPR(FN), DNA, DNA)
+
+
+CONNECT(SQTSQTI_LINK)
+
+#define SQT_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	SET_FPR(FD, sqrt(FPR(FM)));					\
+      }									\
+  }
+DEFINST(SQT,			0x00,
+	"sqt%c%t%r",		"%D,%M",
+	FloatSQRT,		F_FCOMP,
+	DFPR(FD), DNA, DNA,	DCOND, DFPR(FM), DNA, DNA)
+
+#define SQTI_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	SET_FPR(FD, sqrt(FPIMM));					\
+      }									\
+  }
+DEFINST(SQTI,			0x01,
+	"sqt%c%t%r",		"%D,#%I",
+	FloatSQRT,		F_FCOMP,
+	DFPR(FD), DNA, DNA,	DCOND, DNA, DNA, DNA)
+
+
+CONNECT(RDFRDFI_LINK)
+
+#define RDF_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	SET_FPR(FD, FPR(FM) / FPR(FN));					\
+      }									\
+  }
+DEFINST(RDF,			0x00,
+	"rdf%c%t%r",		"%D,%N,%M",
+	FloatDIV,		F_FCOMP,
+	DFPR(FD), DNA, DNA,	DCOND, DFPR(FN), DFPR(FM), DNA)
+
+#define RDFI_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	SET_FPR(FD, FPIMM / FPR(FN));					\
+      }									\
+  }
+DEFINST(RDFI,			0x01,
+	"rdf%c%t%r",		"%D,%N,#%I",
+	FloatDIV,		F_FCOMP,
+	DFPR(FD), DNA, DNA,	DCOND, DFPR(FN), DNA, DNA)
+
+
+CONNECT(LOGLOGI_LINK)
+
+#define LOG_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	SET_FPR(FD, log10(FPR(FM)));					\
+      }									\
+  }
+DEFINST(LOG,			0x00,
+	"log%c%t%r",		"%D,%N,%M",
+	FloatADD,		F_FCOMP,
+	DFPR(FD), DNA, DNA,	DCOND, DFPR(FM), DNA, DNA)
+
+#define LOGI_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	SET_FPR(FD, log10(FPIMM));					\
+      }									\
+  }
+DEFINST(LOGI,			0x01,
+	"log%c%t%r",		"%D,%N,#%I",
+	FloatADD,		F_FCOMP,
+	DFPR(FD), DNA, DNA,	DCOND, DNA, DNA, DNA)
+
+
+CONNECT(POWPOWI_LINK)
+
+#define POW_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	SET_FPR(FD, pow(FPR(FN), FPR(FM)));				\
+      }									\
+  }
+DEFINST(POW,			0x00,
+	"pow%c%t%r",		"%D,%N,%M",
+	FloatADD,		F_FCOMP,
+	DFPR(FD), DNA, DNA,	DCOND, DFPR(FN), DFPR(FM), DNA)
+
+#define POWI_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	SET_FPR(FD, pow(FPR(FN), FPIMM));				\
+      }									\
+  }
+DEFINST(POWI,			0x01,
+	"pow%c%t%r",		"%D,%N,#%I",
+	FloatADD,		F_FCOMP,
+	DFPR(FD), DNA, DNA,	DCOND, DFPR(FN), DNA, DNA)
+
+
+CONNECT(LGNLGNI_LINK)
+
+#define LGN_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	SET_FPR(FD, log(FPR(FM)));					\
+      }									\
+  }
+DEFINST(LGN,			0x00,
+	"lgn%c%t%r",		"%D,%N,%M",
+	FloatADD,		F_FCOMP,
+	DFPR(FD), DNA, DNA,	DCOND, DFPR(FM), DNA, DNA)
+
+#define LGNI_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	SET_FPR(FD, log(FPIMM));					\
+      }									\
+  }
+DEFINST(LGNI,			0x01,
+	"lgn%c%t%r",		"%D,%N,#%I",
+	FloatADD,		F_FCOMP,
+	DFPR(FD), DNA, DNA,	DCOND, DNA, DNA, DNA)
+
+
+CONNECT(RPWRPWI_LINK)
+
+#define RPW_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	SET_FPR(FD, pow(FPR(FM), FPR(FN)));				\
+      }									\
+  }
+DEFINST(RPW,			0x00,
+	"rpw%c%t%r",		"%D,%N,%M",
+	FloatADD,		F_FCOMP,
+	DFPR(FD), DNA, DNA,	DCOND, DFPR(FN), DFPR(FM), DNA)
+
+#define RPWI_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	SET_FPR(FD, pow(FPIMM, FPR(FN)));				\
+      }									\
+  }
+DEFINST(RPWI,			0x01,
+	"rpw%c%t%r",		"%D,%N,#%I",
+	FloatADD,		F_FCOMP,
+	DFPR(FD), DNA, DNA,	DCOND, DFPR(FN), DNA, DNA)
+
+
+CONNECT(EXPEXPI_LINK)
+
+#define EXP_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	SET_FPR(FD, exp(FPR(FM)));					\
+      }									\
+  }
+DEFINST(EXP,			0x00,
+	"exp%c%t%r",		"%D,%N,%M",
+	FloatADD,		F_FCOMP,
+	DFPR(FD), DNA, DNA,	DCOND, DFPR(FM), DNA, DNA)
+
+#define EXPI_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	SET_FPR(FD, exp(FPIMM));					\
+      }									\
+  }
+DEFINST(EXPI,			0x01,
+	"exp%c%t%r",		"%D,%N,#%I",
+	FloatADD,		F_FCOMP,
+	DFPR(FD), DNA, DNA,	DCOND, DNA, DNA, DNA)
+
+
+CONNECT(RMFRMFI_LINK)
+
+#define RMF_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	SET_FPR(FD, drem(FPR(FN), FPR(FM)));				\
+      }									\
+  }
+DEFINST(RMF,			0x00,
+	"rmf%c%t%r",		"%D,%N,%M",
+	FloatADD,		F_FCOMP,
+	DFPR(FD), DNA, DNA,	DCOND, DFPR(FN), DFPR(FM), DNA)
+
+#define RMFI_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	SET_FPR(FD, drem(FPR(FN), FPIMM));				\
+      }									\
+  }
+DEFINST(RMFI,			0x01,
+	"rmf%c%t%r",		"%D,%N,#%I",
+	FloatADD,		F_FCOMP,
+	DFPR(FD), DNA, DNA,	DCOND, DFPR(FN), DNA, DNA)
+
+
+CONNECT(SINSINI_LINK)
+
+#define SIN_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	SET_FPR(FD, sin(FPR(FM)));					\
+      }									\
+  }
+DEFINST(SIN,			0x00,
+	"sin%c%t%r",		"%D,%N,%M",
+	FloatADD,		F_FCOMP,
+	DFPR(FD), DNA, DNA,	DCOND, DFPR(FM), DNA, DNA)
+
+#define SINI_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	SET_FPR(FD, sin(FPIMM));					\
+      }									\
+  }
+DEFINST(SINI,			0x01,
+	"sin%c%t%r",		"%D,%N,#%I",
+	FloatADD,		F_FCOMP,
+	DFPR(FD), DNA, DNA,	DCOND, DNA, DNA, DNA)
+
+
+CONNECT(FMLFMLI_LINK)
+
+#define FML_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	SET_FPR(FD, FPR(FN) * FPR(FM));					\
+      }									\
+  }
+DEFINST(FML,			0x00,
+	"fml%c%t%r",		"%D,%N,%M",
+	FloatMULT,		F_FCOMP,
+	DFPR(FD), DNA, DNA,	DCOND, DFPR(FN), DFPR(FM), DNA)
+
+#define FMLI_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	SET_FPR(FD, FPR(FN) * FPIMM);					\
+      }									\
+  }
+DEFINST(FMLI,			0x01,
+	"fml%c%t%r",		"%D,%N,#%I",
+	FloatMULT,		F_FCOMP,
+	DFPR(FD), DNA, DNA,	DCOND, DFPR(FN), DNA, DNA)
+
+
+CONNECT(COSCOSI_LINK)
+
+#define COS_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	SET_FPR(FD, cos(FPR(FM)));					\
+      }									\
+  }
+DEFINST(COS,			0x00,
+	"cos%c%t%r",		"%D,%N,%M",
+	FloatADD,		F_FCOMP,
+	DFPR(FD), DNA, DNA,	DCOND, DFPR(FM), DNA, DNA)
+
+#define COSI_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	SET_FPR(FD, cos(FPIMM));					\
+      }									\
+  }
+DEFINST(COSI,			0x01,
+	"cos%c%t%r",		"%D,%N,#%I",
+	FloatADD,		F_FCOMP,
+	DFPR(FD), DNA, DNA,	DCOND, DNA, DNA, DNA)
+
+
+CONNECT(FDVFDVI_LINK)
+
+#define FDV_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	SET_FPR(FD, FPR(FN) / FPR(FM));					\
+      }									\
+  }
+DEFINST(FDV,			0x00,
+	"fdv%c%t%r",		"%D,%N,%M",
+	FloatDIV,		F_FCOMP,
+	DFPR(FD), DNA, DNA,	DCOND, DFPR(FN), DFPR(FM), DNA)
+
+#define FDVI_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	SET_FPR(FD, FPR(FN) / FPIMM);					\
+      }									\
+  }
+DEFINST(FDVI,			0x01,
+	"fdv%c%t%r",		"%D,%N,#%I",
+	FloatDIV,		F_FCOMP,
+	DFPR(FD), DNA, DNA,	DCOND, DFPR(FN), DNA, DNA)
+
+
+CONNECT(TANTANI_LINK)
+
+#define TAN_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	SET_FPR(FD, tan(FPR(FM)));					\
+      }									\
+  }
+DEFINST(TAN,			0x00,
+	"tan%c%t%r",		"%D,%N,%M",
+	FloatADD,		F_FCOMP,
+	DFPR(FD), DNA, DNA,	DCOND, DFPR(FM), DNA, DNA)
+
+#define TANI_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	SET_FPR(FD, tan(FPIMM));					\
+      }									\
+  }
+DEFINST(TANI,			0x01,
+	"tan%c%t%r",		"%D,%N,#%I",
+	FloatADD,		F_FCOMP,
+	DFPR(FD), DNA, DNA,	DCOND, DNA, DNA, DNA)
+
+
+CONNECT(FRDFRDI_LINK)
+
+#define FRD_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	SET_FPR(FD, FPR(FM) / FPR(FN));					\
+      }									\
+  }
+DEFINST(FRD,			0x00,
+	"frd%c%t%r",		"%D,%N,%M",
+	FloatDIV,		F_FCOMP,
+	DFPR(FD), DNA, DNA,	DCOND, DFPR(FN), DFPR(FM), DNA)
+
+#define FRDI_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	SET_FPR(FD, FPIMM / FPR(FN));					\
+      }									\
+  }
+DEFINST(FRDI,			0x01,
+	"frd%c%t%r",		"%D,%N,#%I",
+	FloatDIV,		F_FCOMP,
+	DFPR(FD), DNA, DNA,	DCOND, DFPR(FN), DNA, DNA)
+
+
+CONNECT(ASNASNI_LINK)
+
+#define ASN_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	SET_FPR(FD, asin(FPR(FM)));					\
+      }									\
+  }
+DEFINST(ASN,			0x00,
+	"asn%c%t%r",		"%D,%N,%M",
+	FloatADD,		F_FCOMP,
+	DFPR(FD), DNA, DNA,	DCOND, DFPR(FM), DNA, DNA)
+
+#define ASNI_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	SET_FPR(FD, asin(FPIMM));					\
+      }									\
+  }
+DEFINST(ASNI,			0x01,
+	"asn%c%t%r",		"%D,%N,#%I",
+	FloatADD,		F_FCOMP,
+	DFPR(FD), DNA, DNA,	DCOND, DNA, DNA, DNA)
+
+
+CONNECT(POLPOLI_LINK)
+
+#define POL_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	SET_FPR(FD, atan2(FPR(FN), FPR(FM)));				\
+      }									\
+  }
+DEFINST(POL,			0x00,
+	"pol%c%t%r",		"%D,%N,%M",
+	FloatSQRT,		F_FCOMP,
+	DFPR(FD), DNA, DNA,	DCOND, DFPR(FN), DFPR(FM), DNA)
+
+#define POLI_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	SET_FPR(FD, atan2(FPR(FN), FPIMM));				\
+      }									\
+  }
+DEFINST(POLI,			0x01,
+	"pol%c%t%r",		"%D,%N,#%I",
+	FloatSQRT,		F_FCOMP,
+	DFPR(FD), DNA, DNA,	DCOND, DFPR(FN), DNA, DNA)
+
+
+CONNECT(ACSACSI_LINK)
+
+#define ACS_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	SET_FPR(FD, acos(FPR(FM)));					\
+      }									\
+  }
+DEFINST(ACS,			0x00,
+	"acs%c%t%r",		"%D,%N,%M",
+	FloatADD,		F_FCOMP,
+	DFPR(FD), DNA, DNA,	DCOND, DFPR(FM), DNA, DNA)
+
+#define ACSI_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	SET_FPR(FD, acos(FPIMM));					\
+      }									\
+  }
+DEFINST(ACSI,			0x01,
+	"acs%c%t%r",		"%D,%N,#%I",
+	FloatADD,		F_FCOMP,
+	DFPR(FD), DNA, DNA,	DCOND, DNA, DNA, DNA)
+
+
+CONNECT(ATNATNI_LINK)
+
+#define ATN_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	SET_FPR(FD, atan(FPR(FM)));					\
+      }									\
+  }
+DEFINST(ATN,			0x00,
+	"atn%c%t%r",		"%D,%N,%M",
+	FloatADD,		F_FCOMP,
+	DFPR(FD), DNA, DNA,	DCOND, DFPR(FM), DNA, DNA)
+
+#define ATNI_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	SET_FPR(FD, atan(FPIMM));					\
+      }									\
+  }
+DEFINST(ATNI,			0x01,
+	"atn%c%t%r",		"%D,%N,#%I",
+	FloatADD,		F_FCOMP,
+	DFPR(FD), DNA, DNA,	DCOND, DNA, DNA, DNA)
+
+
+CONNECT(URDURDI_LINK)
+
+#define FURD_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	/* FIXME: how does this work??? */				\
+	DECLARE_FAULT(md_fault_unimpl);					\
+      }									\
+  }
+DEFINST(FURD,			0x00,
+	"urd%c%t%r",		"%D,%M",
+	FloatADD,		F_FCOMP,
+	DNA, DNA, DNA,		DCOND, DNA, DNA, DNA)
+
+#define FURDI_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	/* FIXME: how does this work??? */				\
+	DECLARE_FAULT(md_fault_unimpl);					\
+      }									\
+  }
+DEFINST(FURDI,			0x01,
+	"urd%c%t%r",		"%D,#%I",
+	FloatADD,		F_FCOMP,
+	DNA, DNA, DNA,		DCOND, DNA, DNA, DNA)
+
+
+CONNECT(NRMNRMI_LINK)
+
+#define NRM_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	/* FIXME: how does this work??? */				\
+	DECLARE_FAULT(md_fault_unimpl);					\
+      }									\
+  }
+DEFINST(NRM,			0x00,
+	"nrm%c%t%r",		"%D,%M",
+	FloatADD,		F_FCOMP,
+	DNA, DNA, DNA,		DCOND, DNA, DNA, DNA)
+
+#define NRMI_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	/* FIXME: how does this work??? */				\
+	DECLARE_FAULT(md_fault_unimpl);					\
+      }									\
+  }
+DEFINST(NRMI,			0x01,
+	"nrm%c%t%r",		"%D,#%I",
+	FloatADD,		F_FCOMP,
+	DNA, DNA, DNA,		DCOND, DNA, DNA, DNA)
+
+
+/* FP coprocessor register transfer (CPRT) */
+
+CONNECT(CPRT_CDP_LINK)
+
+DEFLINK(CDP_LINK, 0x00, "cdp_link", 4, 0x01)
+
+DEFLINK(CPRT_LINK, 0x01, "cprt_link", 20, 0x0f)
+
+
+CONNECT(CDP_LINK)
+
+	/* FIXME: Work more on this CDP instruction !!!! */
+	
+#define CDP_IMPL						\
+	{							\
+	  /* what exactly does this do?? */			\
+	}							\
+	
+/* need to fix this instruction definition */
+
+DEFINST(CDP,			0x00,
+	"cdp%c",		"%P, %p, c%d, c%n, c%w, {%g}",
+	FloatADD,		F_FCOMP,
+	DNA, DNA, DNA,		DCOND, DNA, DNA, DNA)
+
+CONNECT(CPRT_LINK)
+
+#define FLT_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	SET_FPR(FN, (dfloat_t)(sword_t)GPR_MEM(RD));			\
+      }									\
+  }
+DEFINST(FLT,			0x00,
+	"flt%c%t%r",		"%N,%d",
+	FloatADD,		F_FCOMP,
+	DFPR(FN), DNA, DNA,	DCOND, DGPR(RD), DNA, DNA)
+
+#define FIX_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	SET_GPR(RD, (word_t)FPR(FM));					\
+      }									\
+  }
+DEFINST(FIX,			0x01,
+	"fix%c%r",		"%d,%M",
+	FloatADD,		F_ICOMP,
+	DGPR(RD), DNA, DNA,	DCOND, DFPR(FM), DNA, DNA)
+
+#define WFS_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	SET_FPSR(GPR_MEM(RD));						\
+      }									\
+  }
+DEFINST(WFS,			0x02,
+	"wfs%c",		"%d",
+	IntALU,			F_ICOMP,
+	DFPSR, DNA, DNA,	DCOND, DGPR(RD), DNA, DNA)
+
+#define RFS_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	SET_GPR(RD, FPSR);						\
+      }									\
+  }
+DEFINST(RFS,			0x03,
+	"rfs%c",		"%d",
+	IntALU,			F_ICOMP,
+	DGPR(RD), DNA, DNA,	DCOND, DFPSR, DNA, DNA)
+
+#define WFC_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	/* FIXME: supervisory mode only... */				\
+	SET_FPSR(GPR_MEM(RD));						\
+      }									\
+  }
+DEFINST(WFC,			0x04,
+	"wfc%c",		"%d",
+	IntALU,			F_ICOMP,
+	DFPSR, DNA, DNA,	DCOND, DGPR(RD), DNA, DNA)
+
+#define RFC_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	/* FIXME: supervisory mode only... */				\
+	SET_GPR(RD, FPSR);						\
+      }									\
+  }
+DEFINST(RFC,			0x05,
+	"rfc%c",		"%d",
+	IntALU,			F_ICOMP,
+	DGPR(RD), DNA, DNA,	DCOND, DFPSR, DNA, DNA)
+
+
+CONNECT(CMF_LINK)
+
+DEFLINK(CMFCMFI_LINK, 0x04, "cmfcmfi_link", 3, 0x01)
+
+DEFLINK(CNFCNFI_LINK, 0x05, "cnfcnfi_link", 3, 0x01)
+
+DEFLINK(CMFECMFEI_LINK, 0x06, "cmfecmfei_link", 3, 0x01)
+
+DEFLINK(CNFECNFEI_LINK, 0x07, "cnfecnfei_link", 3, 0x01)
+
+
+CONNECT(CMFCMFI_LINK)
+
+#define CMF_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	dfloat_t fn = FPR(FN), fm = FPR(FM);				\
+	int nanfn = isnan(fn), nanfm = isnan(fm);			\
+									\
+	SET_PSR_N(fn < fm);						\
+	SET_PSR_Z(fn == fm);						\
+	SET_PSR_C(fn >= fm);						\
+	SET_PSR_V(nanfn || nanfm);					\
+      }									\
+  }
+DEFINST(CMF,			0x00,
+	"cmf%c",		"%N,%M",
+	FloatADD,		F_FCOMP,
+	DPSR, DNA, DNA,		DCOND, DFPR(FN), DFPR(FM), DNA)
+
+#define CMFI_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	dfloat_t fn = FPR(FN), fm = FPIMM;				\
+	int nanfn = isnan(fn), nanfm = isnan(fm);			\
+									\
+	SET_PSR_N(fn < fm);						\
+	SET_PSR_Z(fn == fm);						\
+	SET_PSR_C(fn >= fm);						\
+	SET_PSR_V(nanfn || nanfm);					\
+      }									\
+  }
+DEFINST(CMFI,			0x01,
+	"cmf%c",		"%N,#%I",
+	FloatADD,		F_FCOMP,
+	DPSR, DNA, DNA,		DCOND, DFPR(FN), DNA, DNA)
+
+
+CONNECT(CNFCNFI_LINK)
+
+#define CNF_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	dfloat_t fn = FPR(FN), fm = -FPR(FM);				\
+	int nanfn = isnan(fn), nanfm = isnan(fm);			\
+									\
+	SET_PSR_N(fn < fm);						\
+	SET_PSR_Z(fn == fm);						\
+	SET_PSR_C(fn >= fm);						\
+	SET_PSR_V(nanfn || nanfm);					\
+      }									\
+  }
+DEFINST(CNF,			0x00,
+	"cnf%c",		"%N,%M",
+	FloatADD,		F_FCOMP,
+	DPSR, DNA, DNA,		DCOND, DFPR(FN), DFPR(FM), DNA)
+
+#define CNFI_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	dfloat_t fn = FPR(FN), fm = -FPIMM;				\
+	int nanfn = isnan(fn), nanfm = isnan(fm);			\
+									\
+	SET_PSR_N(fn < fm);						\
+	SET_PSR_Z(fn == fm);						\
+	SET_PSR_C(fn >= fm);						\
+	SET_PSR_V(nanfn || nanfm);					\
+      }									\
+  }
+DEFINST(CNFI,			0x01,
+	"cnf%c",		"%N,#%I",
+	FloatADD,		F_FCOMP,
+	DPSR, DNA, DNA,		DCOND, DFPR(FN), DNA, DNA)
+
+
+CONNECT(CMFECMFEI_LINK)
+
+#define CMFE_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	dfloat_t fn = FPR(FN), fm = FPR(FM);				\
+	int nanfn = isnan(fn), nanfm = isnan(fm);			\
+									\
+	if (nanfn || nanfm)						\
+	  /* DECLARE_FAULT(md_fault_invalid) */;			\
+									\
+	SET_PSR_N(fn < fm);						\
+	SET_PSR_Z(fn == fm);						\
+	SET_PSR_C(fn >= fm);						\
+	SET_PSR_V(nanfn || nanfm);					\
+      }									\
+  }
+DEFINST(CMFE,			0x00,
+	"cmfe%c",		"%N,%M",
+	FloatADD,		F_FCOMP,
+	DPSR, DNA, DNA,		DCOND, DFPR(FN), DFPR(FM), DNA)
+
+#define CMFEI_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	dfloat_t fn = FPR(FN), fm = FPIMM;				\
+	int nanfn = isnan(fn), nanfm = isnan(fm);			\
+									\
+	if (nanfn || nanfm)						\
+	  /* DECLARE_FAULT(md_fault_invalid) */;			\
+									\
+	SET_PSR_N(fn < fm);						\
+	SET_PSR_Z(fn == fm);						\
+	SET_PSR_C(fn >= fm);						\
+	SET_PSR_V(nanfn || nanfm);					\
+      }									\
+  }
+DEFINST(CMFEI,			0x01,
+	"cmfe%c",		"%N,#%I",
+	FloatADD,		F_FCOMP,
+	DPSR, DNA, DNA,		DCOND, DFPR(FN), DNA, DNA)
+
+
+CONNECT(CNFECNFEI_LINK)
+
+#define CNFE_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	dfloat_t fn = FPR(FN), fm = -FPR(FM);				\
+	int nanfn = isnan(fn), nanfm = isnan(fm);			\
+									\
+	if (nanfn || nanfm)						\
+	  /* DECLARE_FAULT(md_fault_invalid) */;			\
+									\
+	SET_PSR_N(fn < fm);						\
+	SET_PSR_Z(fn == fm);						\
+	SET_PSR_C(fn >= fm);						\
+	SET_PSR_V(nanfn || nanfm);					\
+      }									\
+  }
+DEFINST(CNFE,			0x00,
+	"cnfe%c",		"%N,%M",
+	FloatADD,		F_FCOMP,
+	DPSR, DNA, DNA,		DCOND, DFPR(FN), DFPR(FM), DNA)
+
+#define CNFEI_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	dfloat_t fn = FPR(FN), fm = -FPIMM;				\
+	int nanfn = isnan(fn), nanfm = isnan(fm);			\
+									\
+	if (nanfn || nanfm)						\
+	  /* DECLARE_FAULT(md_fault_invalid) */;			\
+									\
+	SET_PSR_N(fn < fm);						\
+	SET_PSR_Z(fn == fm);						\
+	SET_PSR_C(fn >= fm);						\
+	SET_PSR_V(nanfn || nanfm);					\
+      }									\
+  }
+DEFINST(CNFEI,			0x01,
+	"cnfe%c",		"%N,#%I",
+	FloatADD,		F_FCOMP,
+	DPSR, DNA, DNA,		DCOND, DFPR(FN), DNA, DNA)
+
+
+CONNECT(CDXPOST_LINK)
+
+DEFLINK(LDFSTFPOST_LINK, 0x01, "ldfstfpost_link", 20, 0x0f)
+
+DEFLINK(LFMSFMPOST_LINK, 0x02, "lfmsfmpost_link", 20, 0x0b)
+
+
+CONNECT(CDXPRE_LINK)
+
+DEFLINK(LDFSTFPRE_LINK, 0x01, "ldfstfpre_link", 20, 0x0f)
+
+DEFLINK(LFMSFMPRE_LINK, 0x02, "lfmsfmpre_link", 20, 0x0b)
+
+
+CONNECT(LDFSTFPOST_LINK)
+
+/* DEFLINK(STFSSTFD_LINK, 0x00, "stfsstfd_link", 15, 0x01) */
+
+/* DEFLINK(LDFS_LLDFD_L_LINK, 0x01, "ldfs_lldfd_l_link", 15, 0x01) */
+
+DEFLINK(STFS_WSTFD_W_LINK, 0x02, "stfs_wstfd_w_link", 15, 0x01)
+
+DEFLINK(LDFS_WLLDFD_WL_LINK, 0x03, "ldfs_wlldfd_wl_link", 15, 0x01)
+
+DEFLINK(STFE_WSTFP_W_LINK, 0x06, "stfe_wstfp_w_link", 15, 0x01)
+
+DEFLINK(LDFE_WLLDFP_WL_LINK, 0x07, "ldfe_wlldfp_wl_link", 15, 0x01)
+
+/* DEFLINK(STFS_USTFD_U_LINK, 0x08, "stfs_ustfd_u_link", 15, 0x01) */
+
+/* DEFLINK(LDFS_ULLDFD_UL_LINK, 0x09, "ldfs_ulldfd_ul_link", 15, 0x01) */
+
+DEFLINK(STFS_UWSTFD_UW_LINK, 0x0a, "stfs_uwstfd_uw_link", 15, 0x01)
+
+DEFLINK(LDFS_UWLLDFD_UWL_LINK, 0x0b, "ldfs_uwlldfd_uwl_link", 15, 0x01)
+
+DEFLINK(STFE_UWSTFP_UW_LINK, 0x0e, "stfe_uwstfp_uw_link", 15, 0x01)
+
+DEFLINK(LDFE_UWLLDFP_UWL_LINK, 0x0f, "ldfe_uwlldfp_uwl_link", 15, 0x01)
+
+
+CONNECT(STFS_WSTFD_W_LINK)
+
+#define STFS_W_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	md_addr_t _addr;						\
+	enum md_fault_type _fault;					\
+									\
+	WRITE_WORD(FPR_W(FD), GPR_EX(RN), _fault);			\
+	if (_fault != md_fault_none)					\
+	  DECLARE_FAULT(_fault);					\
+	_addr = GPR_EX(RN) - FPOFS;					\
+									\
+	SET_GPR(RN, _addr);						\
+      }									\
+  }
+DEFINST(STFS_W,			0x00,
+	"stf%cs",		"%D,[%n],-#%O",
+	WrPort,			F_MEM|F_STORE|F_DISP|F_CISC,
+	DGPR(RN), DNA, DNA,	DFPR(FD), /**/DCOND, DGPR(RN), DNA)
+
+#define STFD_W_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	md_addr_t _addr;						\
+	enum md_fault_type _fault;					\
+									\
+	WRITE_QWORD(FPR_Q(FD), GPR_EX(RN), _fault);			\
+	if (_fault != md_fault_none)					\
+	  DECLARE_FAULT(_fault);					\
+	_addr = GPR_EX(RN) - FPOFS;					\
+									\
+	SET_GPR(RN, _addr);						\
+      }									\
+  }
+DEFINST(STFD_W,			0x01,
+
+	"stf%cd",		"%D,[%n],-#%O",
+	WrPort,			F_MEM|F_STORE|F_DISP|F_CISC,
+	DGPR(RN), DNA, DNA,	DFPR(FD), /**/DCOND, DGPR(RN), DNA)
+
+
+CONNECT(LDFS_WLLDFD_WL_LINK)
+
+#define LDFS_WL_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	word_t _result;							\
+	md_addr_t _addr;						\
+	enum md_fault_type _fault;					\
+									\
+	_result = READ_WORD(GPR_EX(RN), _fault);			\
+	if (_fault != md_fault_none)					\
+	  DECLARE_FAULT(_fault);					\
+	_addr = GPR_EX(RN) - FPOFS;					\
+									\
+	SET_FPR_W(FD, _result);						\
+	SET_GPR(RN, _addr);						\
+      }									\
+  }
+DEFINST(LDFS_WL,		0x00,
+	"ldf%cs",		"%D,[%n],-#%O",
+	RdPort,			F_MEM|F_LOAD|F_DISP|F_CISC,
+	DFPR(FD),DGPR(RN),DNA,	DNA, /**/DCOND, DGPR(RN), DNA)
+
+#define LDFD_WL_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	qword_t _result;						\
+	md_addr_t _addr;						\
+	enum md_fault_type _fault;					\
+									\
+	_result = READ_QWORD(GPR_EX(RN), _fault);			\
+	if (_fault != md_fault_none)					\
+	  DECLARE_FAULT(_fault);					\
+	_addr = GPR_EX(RN) - FPOFS;					\
+									\
+	SET_FPR_Q(FD, _result);						\
+	SET_GPR(RN, _addr);						\
+      }									\
+  }
+DEFINST(LDFD_WL,		0x01,
+	
+	"ldf%cd",		"%D,[%n],-#%O",
+	RdPort,			F_MEM|F_LOAD|F_DISP|F_CISC,
+	DFPR(FD),DGPR(RN),DNA,	DNA, /**/DCOND, DGPR(RN), DNA)
+
+
+CONNECT(STFE_WSTFP_W_LINK)
+
+#define STFE_W_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	md_addr_t _addr;						\
+	enum md_fault_type _fault;					\
+									\
+	/* FIXME: need to store an extended word here... */		\
+	WRITE_QWORD(FPR_Q(FD), GPR_EX(RN), _fault);			\
+	if (_fault != md_fault_none)					\
+	  DECLARE_FAULT(_fault);					\
+	_addr = GPR_EX(RN) - FPOFS;					\
+									\
+	SET_GPR(RN, _addr);						\
+      }									\
+  }
+DEFINST(STFE_W,			0x00,
+	"stf%ce",		"%D,[%n],-#%O",
+	WrPort,			F_MEM|F_STORE|F_DISP|F_CISC,
+	DGPR(RN), DNA, DNA,	DFPR(FD), /**/DCOND, DGPR(RN), DNA)
+
+#define STFP_W_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	/* FIXME: todo... */						\
+	DECLARE_FAULT(md_fault_unimpl);					\
+      }									\
+  }
+DEFINST(STFP_W,			0x01,
+	"stf%cp",		"%D,[%n],-#%O",
+	WrPort,			F_MEM|F_STORE|F_DISP/*|F_CISC*/,
+	DNA, DNA, DNA,		DCOND, DNA, DNA, DNA)
+
+
+CONNECT(LDFE_WLLDFP_WL_LINK)
+
+#define LDFE_WL_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	qword_t _result;						\
+	md_addr_t _addr;						\
+	enum md_fault_type _fault;					\
+									\
+	/* FIXME: need to load an extended word here... */		\
+	_result = READ_QWORD(GPR_EX(RN), _fault);			\
+	if (_fault != md_fault_none)					\
+	  DECLARE_FAULT(_fault);					\
+	_addr = GPR_EX(RN) - FPOFS;					\
+									\
+	SET_FPR_Q(FD, _result);						\
+	SET_GPR(RN, _addr);						\
+      }									\
+  }
+DEFINST(LDFE_WL,		0x00,
+	"ldf%ce",		"%D,[%n],-#%O",
+	RdPort,			F_MEM|F_LOAD|F_DISP|F_CISC,
+	DFPR(FD),DGPR(RN),DNA,	DNA, /**/DCOND, DGPR(RN), DNA)
+
+#define LDFP_WL_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	/* FIXME: todo... */						\
+	DECLARE_FAULT(md_fault_unimpl);					\
+      }									\
+  }
+DEFINST(LDFP_WL,		0x01,
+	"ldf%cp",		"%D,[%n],-#%O",
+	RdPort,			F_MEM|F_LOAD|F_DISP/*|F_CISC*/,
+	DNA, DNA, DNA,		DCOND, DNA, DNA, DNA)
+
+
+CONNECT(STFS_UWSTFD_UW_LINK)
+
+#define STFS_UW_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	md_addr_t _addr;						\
+	enum md_fault_type _fault;					\
+									\
+	WRITE_WORD(FPR_W(FD), GPR_EX(RN), _fault);			\
+	if (_fault != md_fault_none)					\
+	  DECLARE_FAULT(_fault);					\
+	_addr = GPR_EX(RN) + FPOFS;					\
+									\
+	SET_GPR(RN, _addr);						\
+      }									\
+  }
+DEFINST(STFS_UW,		0x00,
+	"stf%cs",		"%D,[%n],#%O",
+	WrPort,			F_MEM|F_STORE|F_DISP|F_CISC,
+	DGPR(RN), DNA, DNA,	DFPR(FD), /**/DCOND, DGPR(RN), DNA)
+
+#define STFD_UW_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	md_addr_t _addr;						\
+	enum md_fault_type _fault;					\
+									\
+	WRITE_QWORD(FPR_Q(FD), GPR_EX(RN), _fault);			\
+	if (_fault != md_fault_none)					\
+	  DECLARE_FAULT(_fault);					\
+	_addr = GPR_EX(RN) + FPOFS;					\
+									\
+	SET_GPR(RN, _addr);						\
+      }									\
+  }
+DEFINST(STFD_UW,		0x01,
+	"stf%cd",		"%D,[%n],#%O",
+	WrPort,			F_MEM|F_STORE|F_DISP|F_CISC,
+	DGPR(RN), DNA, DNA,	DFPR(FD), /**/DCOND, DGPR(RN), DNA)
+
+
+CONNECT(LDFS_UWLLDFD_UWL_LINK)
+
+#define LDFS_UWL_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	word_t _result;							\
+	md_addr_t _addr;						\
+	enum md_fault_type _fault;					\
+									\
+	_result = READ_WORD(GPR_EX(RN), _fault);			\
+	if (_fault != md_fault_none)					\
+	  DECLARE_FAULT(_fault);					\
+	_addr = GPR_EX(RN) + FPOFS;					\
+									\
+	SET_FPR_W(FD, _result);						\
+	SET_GPR(RN, _addr);						\
+      }									\
+  }
+DEFINST(LDFS_UWL,		0x00,
+	"ldf%cs",		"%D,[%n],#%O",
+	RdPort,			F_MEM|F_LOAD|F_DISP|F_CISC,
+	DFPR(FD),DGPR(RN),DNA,	DNA, /**/DCOND, DGPR(RN), DNA)
+
+#define LDFD_UWL_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	qword_t _result;						\
+	md_addr_t _addr;						\
+	enum md_fault_type _fault;					\
+									\
+	_result = READ_QWORD(GPR_EX(RN), _fault);			\
+	if (_fault != md_fault_none)					\
+	  DECLARE_FAULT(_fault);					\
+	_addr = GPR_EX(RN) + FPOFS;					\
+									\
+	SET_FPR_Q(FD, _result);						\
+	SET_GPR(RN, _addr);						\
+      }									\
+  }
+DEFINST(LDFD_UWL,		0x01,
+	"ldf%cd",		"%D,[%n],#%O",
+	RdPort,			F_MEM|F_LOAD|F_DISP|F_CISC,
+	DFPR(FD),DGPR(RN),DNA,	DNA, /**/DCOND, DGPR(RN), DNA)
+
+
+CONNECT(STFE_UWSTFP_UW_LINK)
+
+#define STFE_UW_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	md_addr_t _addr;						\
+	enum md_fault_type _fault;					\
+									\
+	/* FIXME: need to load an extended word here... */		\
+	WRITE_QWORD(FPR_Q(FD), GPR_EX(RN), _fault);			\
+	if (_fault != md_fault_none)					\
+	  DECLARE_FAULT(_fault);					\
+	_addr = GPR_EX(RN) + FPOFS;					\
+									\
+	SET_GPR(RN, _addr);						\
+      }									\
+  }
+DEFINST(STFE_UW,		0x00,
+	"stf%ce",		"%D,[%n],#%O",
+	WrPort,			F_MEM|F_STORE|F_DISP|F_CISC,
+	DGPR(RN), DNA, DNA,	DFPR(FD), /**/DCOND, DGPR(RN), DNA)
+
+#define STFP_UW_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	/* FIXME: todo... */						\
+	DECLARE_FAULT(md_fault_unimpl);					\
+      }									\
+  }
+DEFINST(STFP_UW,		0x01,
+	"stf%cp",		"%D,[%n],#%O",
+	WrPort,			F_MEM|F_STORE|F_DISP/*|F_CISC*/,
+	DNA, DNA, DNA,		DCOND, DNA, DNA, DNA)
+
+
+CONNECT(LDFE_UWLLDFP_UWL_LINK)
+
+#define LDFE_UWL_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	qword_t _result;						\
+	md_addr_t _addr;						\
+	enum md_fault_type _fault;					\
+									\
+	/* FIXME: need to load an extended word here... */		\
+	_result = READ_QWORD(GPR_EX(RN), _fault);			\
+	if (_fault != md_fault_none)					\
+	  DECLARE_FAULT(_fault);					\
+	_addr = GPR_EX(RN) + FPOFS;					\
+									\
+	SET_FPR_Q(FD, _result);						\
+	SET_GPR(RN, _addr);						\
+      }									\
+  }
+DEFINST(LDFE_UWL,		0x00,
+	"ldf%ce",		"%D,[%n],#%O",
+	RdPort,			F_MEM|F_LOAD|F_DISP|F_CISC,
+	DFPR(FD),DGPR(RN),DNA,	DNA, /**/DCOND, DGPR(RN), DNA)
+
+#define LDFP_UWL_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	/* FIXME: todo... */						\
+	DECLARE_FAULT(md_fault_unimpl);					\
+      }									\
+  }
+DEFINST(LDFP_UWL,		0x01,
+	"ldf%cp",		"%D,[%n],#%O",
+	RdPort,			F_MEM|F_LOAD|F_DISP/*|F_CISC*/,
+	DNA, DNA, DNA,		DCOND, DNA, DNA, DNA)
+
+
+CONNECT(LDFSTFPRE_LINK)
+
+DEFLINK(STFS_PSTFD_P_LINK, 0x00, "stfs_pstfd_p_link", 15, 0x01)
+
+DEFLINK(LDFS_PLLDFD_PL_LINK, 0x01, "ldfs_plldfd_pl_link", 15, 0x01)
+
+DEFLINK(STFS_PWSTFD_PW_LINK, 0x02, "stfs_pwstfd_pw_link", 15, 0x01)
+
+DEFLINK(LDFS_PWLLDFD_PWL_LINK, 0x03, "ldfs_pwlldfd_pwl_link", 15, 0x01)
+
+DEFLINK(STFE_PSTFP_P_LINK, 0x04, "stfe_pstfp_p_link", 15, 0x01)
+
+DEFLINK(LDFE_PLLDFP_PL_LINK, 0x05, "ldfe_plldfp_pl_link", 15, 0x01)
+
+DEFLINK(STFE_PWSTFP_PW_LINK, 0x06, "stfe_pwstfp_pw_link", 15, 0x01)
+
+DEFLINK(LDFE_PWLLDFP_PWL_LINK, 0x07, "ldfe_pwlldfp_pwl_link", 15, 0x01)
+
+DEFLINK(STFS_PUSTFD_PU_LINK, 0x08, "stfs_pustfd_pu_link", 15, 0x01)
+
+DEFLINK(LDFS_PULLDFD_PUL_LINK, 0x09, "ldfs_pulldfd_pul_link",15,0x01)
+
+DEFLINK(STFS_PUWSTFD_PUW_LINK, 0x0a, "stfs_puwstfd_puw_link", 15, 0x01)
+
+DEFLINK(LDFS_PUWLLDFD_PUWL_LINK, 0x0b, "ldfs_puwlldfd_puwl_link", 15, 0x01)
+
+DEFLINK(STFE_PUSTFP_PU_LINK, 0x0c, "stfe_pustfp_pu_link", 15, 0x01)
+
+DEFLINK(LDFE_PULLDFP_PUL_LINK, 0x0d, "ldfe_pulldfp_pul_link", 15, 0x01)
+
+DEFLINK(STFE_PUWSTFP_PUW_LINK, 0x0e, "stfe_puwstfp_puw_link", 15, 0x01)
+
+DEFLINK(LDFE_PUWLLDFP_PUWL_LINK, 0x0f, "ldfe_puwlldfp_puwl_link", 15, 0x01)
+
+
+CONNECT(STFS_PSTFD_P_LINK)
+
+#define STFS_P_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	enum md_fault_type _fault;					\
+									\
+	WRITE_WORD(FPR_W(FD), GPR_EX(RN) - FPOFS, _fault);		\
+	if (_fault != md_fault_none)					\
+	  DECLARE_FAULT(_fault);					\
+      }									\
+  }
+DEFINST(STFS_P,			0x00,
+	"stf%cs",		"%D,[%n,-#%O]",
+	WrPort,			F_MEM|F_STORE|F_DISP|F_CISC,
+	DNA, DNA, DNA,		DFPR(FD), /**/DCOND, DGPR(RN), DNA)
+
+#define STFD_P_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	enum md_fault_type _fault;					\
+									\
+	WRITE_QWORD(FPR_Q(FD), GPR_EX(RN) - FPOFS, _fault);		\
+	if (_fault != md_fault_none)					\
+	  DECLARE_FAULT(_fault);					\
+      }									\
+  }
+DEFINST(STFD_P,			0x01,
+	"stf%cd",		"%D,[%n,-#%O]",
+	WrPort,			F_MEM|F_STORE|F_DISP|F_CISC,
+	DNA, DNA, DNA,		DFPR(FD), /**/DCOND, DGPR(RN), DNA)
+
+
+CONNECT(LDFS_PLLDFD_PL_LINK)
+
+#define LDFS_PL_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	word_t _result;							\
+	enum md_fault_type _fault;					\
+									\
+	_result = READ_WORD(GPR_EX(RN) - FPOFS, _fault);		\
+	if (_fault != md_fault_none)					\
+	  DECLARE_FAULT(_fault);					\
+									\
+	SET_FPR_W(FD, _result);						\
+      }									\
+  }
+DEFINST(LDFS_PL,		0x00,
+	"ldf%cs",		"%D,[%n,-#%O]",
+	RdPort,			F_MEM|F_LOAD|F_DISP|F_CISC,
+	DFPR(FD), DNA, DNA,	DNA, /**/DCOND, DGPR(RN), DNA)
+
+#define LDFD_PL_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	qword_t _result;						\
+	enum md_fault_type _fault;					\
+									\
+	_result = READ_QWORD(GPR_EX(RN) - FPOFS, _fault);		\
+	if (_fault != md_fault_none)					\
+	  DECLARE_FAULT(_fault);					\
+									\
+	SET_FPR_Q(FD, _result);						\
+      }									\
+  }
+DEFINST(LDFD_PL,		0x01,
+	"ldf%cd",		"%D,[%n,-#%O]",
+	RdPort,			F_MEM|F_LOAD|F_DISP|F_CISC,
+	DFPR(FD), DNA, DNA,	DNA, /**/DCOND, DGPR(RN), DNA)
+
+
+CONNECT(STFS_PWSTFD_PW_LINK)
+
+#define STFS_PW_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	enum md_fault_type _fault;					\
+	md_addr_t _addr;						\
+									\
+	_addr = GPR_EX(RN) - FPOFS;					\
+	WRITE_WORD(FPR_W(FD), _addr, _fault);				\
+	if (_fault != md_fault_none)					\
+	  DECLARE_FAULT(_fault);					\
+									\
+	SET_GPR(RN, _addr);						\
+      }									\
+  }
+DEFINST(STFS_PW,		0x00,
+	"stf%cs",		"%D,[%n,-#%O]!",
+	WrPort,			F_MEM|F_STORE|F_DISP|F_CISC,
+	DGPR(RN), DNA, DNA,	DFPR(FD), /**/DCOND, DGPR(RN), DNA)
+
+#define STFD_PW_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	enum md_fault_type _fault;					\
+	md_addr_t _addr;						\
+									\
+	_addr = GPR_EX(RN) - FPOFS;					\
+	WRITE_QWORD(FPR_Q(FD), _addr, _fault);				\
+	if (_fault != md_fault_none)					\
+	  DECLARE_FAULT(_fault);					\
+									\
+	SET_GPR(RN, _addr);						\
+      }									\
+  }
+DEFINST(STFD_PW,		0x01,
+	"stf%cd",		"%D,[%n,-#%O]!",
+	WrPort,			F_MEM|F_STORE|F_DISP|F_CISC,
+	DGPR(RN), DNA, DNA,	DFPR(FD), /**/DCOND, DGPR(RN), DNA)
+
+
+CONNECT(LDFS_PWLLDFD_PWL_LINK)
+
+#define LDFS_PWL_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	word_t _result;							\
+	md_addr_t _addr;						\
+	enum md_fault_type _fault;					\
+									\
+	_addr = GPR_EX(RN) - FPOFS;					\
+	_result = READ_WORD(_addr, _fault);				\
+	if (_fault != md_fault_none)					\
+	  DECLARE_FAULT(_fault);					\
+									\
+	SET_FPR_W(FD, _result);						\
+	SET_GPR(RN, _addr);						\
+      }									\
+  }
+DEFINST(LDFS_PWL,		0x00,
+	"ldf%cs",		"%D,[%n,-#%O]!",
+	RdPort,			F_MEM|F_LOAD|F_DISP|F_CISC,
+	DFPR(FD),DGPR(RN),DNA,	DNA, /**/DCOND, DGPR(RN), DNA)
+
+#define LDFD_PWL_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	qword_t _result;						\
+	md_addr_t _addr;						\
+	enum md_fault_type _fault;					\
+									\
+	_addr = GPR_EX(RN) - FPOFS;					\
+	_result = READ_QWORD(_addr, _fault);				\
+	if (_fault != md_fault_none)					\
+	  DECLARE_FAULT(_fault);					\
+									\
+	SET_FPR_Q(FD, _result);						\
+	SET_GPR(RN, _addr);						\
+      }									\
+  }
+DEFINST(LDFD_PWL,		0x01,
+	"ldf%cd",		"%D,[%n,-#%O]!",
+	RdPort,			F_MEM|F_LOAD|F_DISP|F_CISC,
+	DFPR(FD),DGPR(RN),DNA,	DNA, /**/DCOND, DGPR(RN), DNA)
+
+
+CONNECT(STFE_PSTFP_P_LINK)
+
+#define STFE_P_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	enum md_fault_type _fault;					\
+									\
+	/* FIXME: need to load an extended word here... */		\
+	WRITE_QWORD(FPR_Q(FD), GPR_EX(RN) - FPOFS, _fault);		\
+	if (_fault != md_fault_none)					\
+	  DECLARE_FAULT(_fault);					\
+      }									\
+  }
+DEFINST(STFE_P,			0x00,
+	"stf%ce",		"%D,[%n,-#%O]",
+	WrPort,			F_MEM|F_STORE|F_DISP|F_CISC,
+	DNA, DNA, DNA,		DFPR(FD), /**/DCOND, DGPR(RN), DNA)
+
+#define STFP_P_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	/* FIXME: todo... */						\
+	DECLARE_FAULT(md_fault_unimpl);					\
+      }									\
+  }
+DEFINST(STFP_P,			0x01,
+	"stf%cp",		"%D,[%n,-#%O]",
+	WrPort,			F_MEM|F_STORE|F_DISP/*|F_CISC*/,
+	DNA, DNA, DNA,		DCOND, DNA, DNA, DNA)
+
+
+CONNECT(LDFE_PLLDFP_PL_LINK)
+
+#define LDFE_PL_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	qword_t _result;						\
+	enum md_fault_type _fault;					\
+									\
+	/* FIXME: need to load an extended word here... */		\
+	_result = READ_QWORD(GPR_EX(RN) - FPOFS, _fault);		\
+	if (_fault != md_fault_none)					\
+	  DECLARE_FAULT(_fault);					\
+									\
+	SET_FPR_Q(FD, _result);						\
+      }									\
+  }
+DEFINST(LDFE_PL,		0x00,
+	"ldf%ce",		"%D,[%n,-#%O]",
+	RdPort,			F_MEM|F_LOAD|F_DISP|F_CISC,
+	DFPR(FD), DNA, DNA,	DNA, /**/DCOND, DGPR(RN), DNA)
+
+#define LDFP_PL_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	/* FIXME: todo... */						\
+	DECLARE_FAULT(md_fault_unimpl);					\
+      }									\
+  }
+DEFINST(LDFP_PL,		0x01,
+	"ldf%cp",		"%D,[%n,-#%O]",
+	RdPort,			F_MEM|F_LOAD|F_DISP/*|F_CISC*/,
+	DNA, DNA, DNA,		DCOND, DNA, DNA, DNA)
+
+
+CONNECT(STFE_PWSTFP_PW_LINK)
+
+#define STFE_PW_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	enum md_fault_type _fault;					\
+	md_addr_t _addr;						\
+									\
+	/* FIXME: need to load an extended word here... */		\
+	_addr = GPR_EX(RN) - FPOFS;					\
+	WRITE_QWORD(FPR_Q(FD), _addr, _fault);				\
+	if (_fault != md_fault_none)					\
+	  DECLARE_FAULT(_fault);					\
+									\
+	SET_GPR(RN, _addr);						\
+      }									\
+  }
+DEFINST(STFE_PW,		0x00,
+	"stf%ce",		"%D,[%n,-#%O]!",
+	WrPort,			F_MEM|F_STORE|F_DISP|F_CISC,
+	DGPR(RN), DNA, DNA,	DFPR(FD), /**/DCOND, DGPR(RN), DNA)
+
+#define STFP_PW_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	/* FIXME: todo... */						\
+	DECLARE_FAULT(md_fault_unimpl);					\
+      }									\
+  }
+DEFINST(STFP_PW,		0x01,
+	"stf%cp",		"%D,[%n,-#%O]!",
+	WrPort,			F_MEM|F_STORE|F_DISP/*|F_CISC*/,
+	DNA, DNA, DNA,		DCOND, DNA, DNA, DNA)
+
+
+CONNECT(LDFE_PWLLDFP_PWL_LINK)
+
+#define LDFE_PWL_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	qword_t _result;						\
+	md_addr_t _addr;						\
+	enum md_fault_type _fault;					\
+									\
+	/* FIXME: need to load an extended word here... */		\
+	_addr = GPR_EX(RN) - FPOFS;					\
+	_result = READ_QWORD(_addr, _fault);				\
+	if (_fault != md_fault_none)					\
+	  DECLARE_FAULT(_fault);					\
+									\
+	SET_FPR_Q(FD, _result);						\
+	SET_GPR(RN, _addr);						\
+      }									\
+  }
+DEFINST(LDFE_PWL,		0x00,
+	"ldf%ce",		"%D,[%n,-#%O]!",
+	RdPort,			F_MEM|F_LOAD|F_DISP|F_CISC,
+	DFPR(FD),DGPR(RN),DNA,	DNA, /**/DCOND, DGPR(RN), DNA)
+
+#define LDFP_PWL_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	/* FIXME: todo... */						\
+	DECLARE_FAULT(md_fault_unimpl);					\
+      }									\
+  }
+DEFINST(LDFP_PWL,		0x01,
+	"ldf%cp",		"%D,[%n,-#%O]!",
+	RdPort,			F_MEM|F_LOAD|F_DISP/*|F_CISC*/,
+	DNA, DNA, DNA,		DCOND, DNA, DNA, DNA)
+
+
+CONNECT(STFS_PUSTFD_PU_LINK)
+
+#define STFS_PU_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+        enum md_fault_type _fault;					\
+									\
+        WRITE_WORD(FPR_W(FD), GPR_EX(RN) + FPOFS, _fault);		\
+        if (_fault != md_fault_none)					\
+          DECLARE_FAULT(_fault);					\
+      }									\
+  }
+DEFINST(STFS_PU,		0x00,
+	"stf%cs",		"%D,[%n,#%O]",
+	WrPort,			F_MEM|F_STORE|F_DISP|F_CISC,
+	DNA, DNA, DNA,		DFPR(FD), /**/DCOND, DGPR(RN), DNA)
+
+#define STFD_PU_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+        enum md_fault_type _fault;					\
+									\
+        WRITE_QWORD(FPR_Q(FD), GPR_EX(RN) + FPOFS, _fault);		\
+        if (_fault != md_fault_none)					\
+          DECLARE_FAULT(_fault);					\
+      }									\
+  }
+DEFINST(STFD_PU,		0x01,
+	"stf%cd",		"%D,[%n,#%O]",
+	WrPort,			F_MEM|F_STORE|F_DISP|F_CISC,
+	DNA, DNA, DNA,		DFPR(FD), /**/DCOND, DGPR(RN), DNA)
+
+
+CONNECT(LDFS_PULLDFD_PUL_LINK)
+
+#define LDFS_PUL_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+        word_t _result;							\
+        enum md_fault_type _fault;					\
+									\
+        _result = READ_WORD(GPR_EX(RN) + FPOFS, _fault);		\
+        if (_fault != md_fault_none)					\
+          DECLARE_FAULT(_fault);					\
+									\
+        SET_FPR_W(FD, _result);						\
+      }									\
+  }
+DEFINST(LDFS_PUL,		0x00,
+	"ldf%cs",		"%D,[%n,#%O]",
+	RdPort,			F_MEM|F_LOAD|F_DISP|F_CISC,
+	DFPR(FD), DNA, DNA,	DNA, /**/DCOND, DGPR(RN), DNA)
+
+#define LDFD_PUL_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+        qword_t _result;						\
+        enum md_fault_type _fault;					\
+									\
+        _result = READ_QWORD(GPR_EX(RN) + FPOFS, _fault);		\
+        if (_fault != md_fault_none)					\
+          DECLARE_FAULT(_fault);					\
+									\
+        SET_FPR_Q(FD, _result);						\
+      }									\
+  }
+DEFINST(LDFD_PUL,		0x01,
+	"ldf%cd",		"%D,[%n,#%O]",
+	RdPort,			F_MEM|F_LOAD|F_DISP|F_CISC,
+	DFPR(FD), DNA, DNA,	DNA, /**/DCOND, DGPR(RN), DNA)
+
+
+CONNECT(STFS_PUWSTFD_PUW_LINK)
+
+#define STFS_PUW_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+        enum md_fault_type _fault;					\
+        md_addr_t _addr;						\
+									\
+        _addr = GPR_EX(RN) + FPOFS;					\
+        WRITE_WORD(FPR_W(FD), _addr, _fault);				\
+        if (_fault != md_fault_none)					\
+          DECLARE_FAULT(_fault);					\
+									\
+        SET_GPR(RN, _addr);						\
+      }									\
+  }
+DEFINST(STFS_PUW,		0x00,
+	"stf%cs",		"%D,[%n,#%O]!",
+	WrPort,			F_MEM|F_STORE|F_DISP|F_CISC,
+	DGPR(RN), DNA, DNA,	DFPR(FD), /**/DCOND, DGPR(RN), DNA)
+
+#define STFD_PUW_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+        enum md_fault_type _fault;					\
+        md_addr_t _addr;						\
+									\
+        _addr = GPR_EX(RN) + FPOFS;					\
+        WRITE_QWORD(FPR_Q(FD), _addr, _fault);				\
+        if (_fault != md_fault_none)					\
+          DECLARE_FAULT(_fault);					\
+									\
+        SET_GPR(RN, _addr);						\
+      }									\
+  }
+DEFINST(STFD_PUW,		0x01,
+	"stf%cd",		"%D,[%n,#%O]!",
+	WrPort,			F_MEM|F_STORE|F_DISP|F_CISC,
+	DGPR(RN), DNA, DNA,	DFPR(FD), /**/DCOND, DGPR(RN), DNA)
+
+
+CONNECT(LDFS_PUWLLDFD_PUWL_LINK)
+
+#define LDFS_PUWL_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+        word_t _result;							\
+        md_addr_t _addr;						\
+        enum md_fault_type _fault;					\
+									\
+        _addr = GPR_EX(RN) + FPOFS;					\
+        _result = READ_WORD(_addr, _fault);				\
+        if (_fault != md_fault_none)					\
+          DECLARE_FAULT(_fault);					\
+									\
+        SET_FPR_W(FD, _result);						\
+        SET_GPR(RN, _addr);						\
+      }									\
+  }
+DEFINST(LDFS_PUWL,		0x00,
+	"ldf%cs",		"%D,[%n,#%O]!",
+	RdPort,			F_MEM|F_LOAD|F_DISP|F_CISC,
+	DFPR(FD),DGPR(RN),DNA,	DNA, /**/DCOND, DGPR(RN), DNA)
+
+#define LDFD_PUWL_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+        qword_t _result;						\
+        md_addr_t _addr;						\
+        enum md_fault_type _fault;					\
+									\
+        _addr = GPR_EX(RN) + FPOFS;					\
+        _result = READ_QWORD(_addr, _fault);				\
+        if (_fault != md_fault_none)					\
+          DECLARE_FAULT(_fault);					\
+									\
+        SET_FPR_Q(FD, _result);						\
+        SET_GPR(RN, _addr);						\
+      }									\
+  }
+DEFINST(LDFD_PUWL,		0x01,
+	"ldf%cd",		"%D,[%n,#%O]!",
+	RdPort,			F_MEM|F_LOAD|F_DISP|F_CISC,
+	DFPR(FD),DGPR(RN),DNA,	DNA, /**/DCOND, DGPR(RN), DNA)
+
+
+CONNECT(STFE_PUSTFP_PU_LINK)
+
+#define STFE_PU_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+        enum md_fault_type _fault;					\
+									\
+        WRITE_QWORD(FPR_Q(FD), GPR_EX(RN) + FPOFS, _fault);		\
+        if (_fault != md_fault_none)					\
+          DECLARE_FAULT(_fault);					\
+      }									\
+  }
+DEFINST(STFE_PU,		0x00,
+	"stf%ce",		"%D,[%n,#%O]",
+	WrPort,			F_MEM|F_STORE|F_DISP|F_CISC,
+	DNA, DNA, DNA,		DFPR(FD), /**/DCOND, DGPR(RN), DNA)
+
+#define STFP_PU_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	/* FIXME: todo... */						\
+	DECLARE_FAULT(md_fault_unimpl);					\
+      }									\
+  }
+DEFINST(STFP_PU,		0x01,
+	"stf%cp",		"%D,[%n,#%O]",
+	WrPort,			F_MEM|F_STORE|F_DISP/*|F_CISC*/,
+	DNA, DNA, DNA,		DCOND, DNA, DNA, DNA)
+
+
+CONNECT(LDFE_PULLDFP_PUL_LINK)
+
+#define LDFE_PUL_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+        word_t _result;							\
+        enum md_fault_type _fault;					\
+									\
+        _result = READ_WORD(GPR_EX(RN) + FPOFS, _fault);		\
+        if (_fault != md_fault_none)					\
+          DECLARE_FAULT(_fault);					\
+									\
+        SET_FPR_W(FD, _result);						\
+      }									\
+  }
+DEFINST(LDFE_PUL,		0x00,
+	"ldf%ce",		"%D,[%n,#%O]",
+	RdPort,			F_MEM|F_LOAD|F_DISP|F_CISC,
+	DFPR(FD), DNA, DNA,	DNA, /**/DCOND, DGPR(RN), DNA)
+
+#define LDFP_PUL_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	/* FIXME: todo... */						\
+	DECLARE_FAULT(md_fault_unimpl);					\
+      }									\
+  }
+DEFINST(LDFP_PUL,		0x01,
+	"ldf%cp",		"%D,[%n,#%O]",
+	RdPort,			F_MEM|F_LOAD|F_DISP/*|F_CISC*/,
+	DNA, DNA, DNA,		DCOND, DNA, DNA, DNA)
+
+
+CONNECT(STFE_PUWSTFP_PUW_LINK)
+
+#define STFE_PUW_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+        enum md_fault_type _fault;					\
+        md_addr_t _addr;						\
+									\
+	/* FIXME: need to load an extended word here... */		\
+        _addr = GPR_EX(RN) + FPOFS;					\
+        WRITE_QWORD(FPR_Q(FD), _addr, _fault);				\
+        if (_fault != md_fault_none)					\
+          DECLARE_FAULT(_fault);					\
+									\
+        SET_GPR(RN, _addr);						\
+      }									\
+  }
+DEFINST(STFE_PUW,		0x00,
+	"stf%ce",		"%D,[%n,#%O]!",
+	WrPort,			F_MEM|F_STORE|F_DISP|F_CISC,
+	DGPR(RN), DNA, DNA,	DFPR(FD), /**/DCOND, DGPR(RN), DNA)
+
+#define STFP_PUW_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	/* FIXME: todo... */						\
+	DECLARE_FAULT(md_fault_unimpl);					\
+      }									\
+  }
+DEFINST(STFP_PUW,		0x01,
+	"stf%cp",		"%D,[%n,#%O]!",
+	WrPort,			F_MEM|F_STORE|F_DISP/*|F_CISC*/,
+	DNA, DNA, DNA,		DCOND, DNA, DNA, DNA)
+
+
+CONNECT(LDFE_PUWLLDFP_PUWL_LINK)
+
+#define LDFE_PUWL_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+        qword_t _result;						\
+        md_addr_t _addr;						\
+        enum md_fault_type _fault;					\
+									\
+	/* FIXME: need to load an extended word here... */		\
+        _addr = GPR_EX(RN) + FPOFS;					\
+        _result = READ_QWORD(_addr, _fault);				\
+        if (_fault != md_fault_none)					\
+          DECLARE_FAULT(_fault);					\
+									\
+        SET_FPR_Q(FD, _result);						\
+        SET_GPR(RN, _addr);						\
+      }									\
+  }
+DEFINST(LDFE_PUWL,		0x00,
+	"ldf%ce",		"%D,[%n,#%O]!",
+	RdPort,			F_MEM|F_LOAD|F_DISP|F_CISC,
+	DFPR(FD),DGPR(RN),DNA,	DNA, /**/DCOND, DGPR(RN), DNA)
+
+#define LDFP_PUWL_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	/* FIXME: todo... */						\
+	DECLARE_FAULT(md_fault_unimpl);					\
+      }									\
+  }
+DEFINST(LDFP_PUWL,		0x01,
+	"ldf%cp",		"%D,[%n,#%O]!",
+	RdPort,			F_MEM|F_LOAD|F_DISP/*|F_CISC*/,
+	DNA, DNA, DNA,		DCOND, DNA, DNA, DNA)
+
+CONNECT(LFMSFMPOST_LINK)
+
+/* SFM, 0x00 */
+
+/* LFM, 0x01 */
+
+#define SFM_W_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	int _i, _count = FCNT ? FCNT : 4;				\
+	md_addr_t _addr;						\
+	enum md_fault_type _fault;					\
+									\
+	_addr = GPR_EX(RN) - FPOFS;					\
+	for (_i=0; _i < _count; _i++)					\
+	  {								\
+	    WRITE_QWORD(FPR_Q((FD)+_i), GPR_EX(RN)+_i*8, _fault);	\
+	    if (_fault != md_fault_none)				\
+	      DECLARE_FAULT(_fault);					\
+	  }								\
+									\
+	SET_GPR(RN, _addr);						\
+      }									\
+  }
+DEFINST(SFM_W,			0x02,
+	"sfm%c",		"%D,%C,[%n],-#%O",
+	WrPort,			F_MEM|F_STORE|F_DISP|F_CISC,
+	DNA, DNA, DNA,		DCOND, DNA, DNA, DNA)
+
+#define LFM_WL_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	int _i, _count = FCNT ? FCNT : 4;				\
+	md_addr_t _addr;						\
+	qword_t _result;						\
+	enum md_fault_type _fault;					\
+									\
+	_addr = GPR_EX(RN) - FPOFS;					\
+	for (_i=0; _i < _count; _i++)					\
+	  {								\
+	    _result = READ_QWORD(GPR_EX(RN)+_i*8, _fault);		\
+	    if (_fault != md_fault_none)				\
+	      DECLARE_FAULT(_fault);					\
+	    SET_FPR_Q((FD)+_i, _result);				\
+	  }								\
+									\
+	SET_GPR(RN, _addr);						\
+      }									\
+  }
+DEFINST(LFM_WL,			0x03,
+	"lfm%c",		"%D,%C,[%n],-#%O",
+	WrPort,			F_MEM|F_STORE|F_DISP|F_CISC,
+	DNA, DNA, DNA,		DCOND, DNA, DNA, DNA)
+
+#define SFM_UW_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	int _i, _count = FCNT ? FCNT : 4;				\
+	md_addr_t _addr;						\
+	enum md_fault_type _fault;					\
+									\
+	_addr = GPR_EX(RN) + FPOFS;					\
+	for (_i=0; _i < _count; _i++)					\
+	  {								\
+	    WRITE_QWORD(FPR_Q((FD)+_i), GPR_EX(RN)+_i*8, _fault);	\
+	    if (_fault != md_fault_none)				\
+	      DECLARE_FAULT(_fault);					\
+	  }								\
+									\
+	SET_GPR(RN, _addr);						\
+      }									\
+  }
+DEFINST(SFM_UW,			0x0a,
+	"sfm%c",		"%D,%C,[%n],#%O",
+	WrPort,			F_MEM|F_STORE|F_DISP|F_CISC,
+	DNA, DNA, DNA,		DCOND, DNA, DNA, DNA)
+
+#define LFM_UWL_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	int _i, _count = FCNT ? FCNT : 4;				\
+	md_addr_t _addr;						\
+	qword_t _result;						\
+	enum md_fault_type _fault;					\
+									\
+	_addr = GPR_EX(RN) + FPOFS;					\
+	for (_i=0; _i < _count; _i++)					\
+	  {								\
+	    _result = READ_QWORD(GPR_EX(RN)+_i*8, _fault);		\
+	    if (_fault != md_fault_none)				\
+	      DECLARE_FAULT(_fault);					\
+	    SET_FPR_Q((FD)+_i, _result);				\
+	  }								\
+									\
+	SET_GPR(RN, _addr);						\
+      }									\
+  }
+DEFINST(LFM_UWL,		0x0b,
+	"lfm%c",		"%D,%C,[%n],#%O",
+	WrPort,			F_MEM|F_STORE|F_DISP|F_CISC,
+	DNA, DNA, DNA,		DCOND, DNA, DNA, DNA)
+
+
+CONNECT(LFMSFMPRE_LINK)
+
+#define SFM_P_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	int _i, _count = FCNT ? FCNT : 4;				\
+	md_addr_t _addr;						\
+	enum md_fault_type _fault;					\
+									\
+	_addr = GPR_EX(RN) - FPOFS;					\
+	for (_i=0; _i < _count; _i++)					\
+	  {								\
+	    WRITE_QWORD(FPR_Q((FD)+_i), _addr+_i*8, _fault);		\
+	    if (_fault != md_fault_none)				\
+	      DECLARE_FAULT(_fault);					\
+	  }								\
+      }									\
+  }
+DEFINST(SFM_P,			0x00,
+	"sfm%c",		"%D,%C,[%n,-#%O]",
+	WrPort,			F_MEM|F_STORE|F_DISP|F_CISC,
+	DNA, DNA, DNA,		DCOND, DNA, DNA, DNA)
+
+#define LFM_PL_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	int _i, _count = FCNT ? FCNT : 4;				\
+	md_addr_t _addr;						\
+	qword_t _result;						\
+	enum md_fault_type _fault;					\
+									\
+	_addr = GPR_EX(RN) - FPOFS;					\
+	for (_i=0; _i < _count; _i++)					\
+	  {								\
+	    _result = READ_QWORD(_addr+_i*8, _fault);			\
+	    if (_fault != md_fault_none)				\
+	      DECLARE_FAULT(_fault);					\
+	    SET_FPR_Q((FD)+_i, _result);				\
+	  }								\
+      }									\
+  }
+DEFINST(LFM_PL,			0x01,
+	"lfm%c",		"%D,%C,[%n,-#%O]",
+	WrPort,			F_MEM|F_STORE|F_DISP|F_CISC,
+	DNA, DNA, DNA,		DCOND, DNA, DNA, DNA)
+
+#define SFM_PW_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	int _i, _count = FCNT ? FCNT : 4;				\
+	md_addr_t _addr;						\
+	enum md_fault_type _fault;					\
+									\
+	_addr = GPR_EX(RN) - FPOFS;					\
+	for (_i=0; _i < _count; _i++)					\
+	  {								\
+	    WRITE_QWORD(FPR_Q((FD)+_i), _addr+_i*8, _fault);		\
+	    if (_fault != md_fault_none)				\
+	      DECLARE_FAULT(_fault);					\
+	  }								\
+									\
+	SET_GPR(RN, _addr);						\
+      }									\
+  }
+DEFINST(SFM_PW,			0x02,
+	"sfm%c",		"%D,%C,[%n,-#%O]!",
+	WrPort,			F_MEM|F_STORE|F_DISP|F_CISC,
+	DNA, DNA, DNA,		DCOND, DNA, DNA, DNA)
+
+#define LFM_PWL_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	int _i, _count = FCNT ? FCNT : 4;				\
+	md_addr_t _addr;						\
+	qword_t _result;						\
+	enum md_fault_type _fault;					\
+									\
+	_addr = GPR_EX(RN) - FPOFS;					\
+	for (_i=0; _i < _count; _i++)					\
+	  {								\
+	    _result = READ_QWORD(_addr+_i*8, _fault);			\
+	    if (_fault != md_fault_none)				\
+	      DECLARE_FAULT(_fault);					\
+	    SET_FPR_Q((FD)+_i, _result);				\
+	  }								\
+									\
+	SET_GPR(RN, _addr);						\
+      }									\
+  }
+DEFINST(LFM_PWL,		0x03,
+	"lfm%c",		"%D,%C,[%n,-#%O]!",
+	WrPort,			F_MEM|F_STORE|F_DISP|F_CISC,
+	DNA, DNA, DNA,		DCOND, DNA, DNA, DNA)
+
+#define SFM_PU_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	int _i, _count = FCNT ? FCNT : 4;				\
+	md_addr_t _addr;						\
+	enum md_fault_type _fault;					\
+									\
+	_addr = GPR_EX(RN) + FPOFS;					\
+	for (_i=0; _i < _count; _i++)					\
+	  {								\
+	    WRITE_QWORD(FPR_Q((FD)+_i), _addr+_i*8, _fault);		\
+	    if (_fault != md_fault_none)				\
+	      DECLARE_FAULT(_fault);					\
+	  }								\
+      }									\
+  }
+DEFINST(SFM_PU,			0x08,
+	"sfm%c",		"%D,%C,[%n,#%O]",
+	WrPort,			F_MEM|F_STORE|F_DISP|F_CISC,
+	DNA, DNA, DNA,		DCOND, DNA, DNA, DNA)
+
+#define LFM_PUL_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	int _i, _count = FCNT ? FCNT : 4;				\
+	md_addr_t _addr;						\
+	qword_t _result;						\
+	enum md_fault_type _fault;					\
+									\
+	_addr = GPR_EX(RN) + FPOFS;					\
+	for (_i=0; _i < _count; _i++)					\
+	  {								\
+	    _result = READ_QWORD(_addr+_i*8, _fault);			\
+	    if (_fault != md_fault_none)				\
+	      DECLARE_FAULT(_fault);					\
+	    SET_FPR_Q((FD)+_i, _result);				\
+	  }								\
+      }									\
+  }
+DEFINST(LFM_PUL,		0x09,
+	"lfm%c",		"%D,%C,[%n,#%O]",
+	WrPort,			F_MEM|F_STORE|F_DISP|F_CISC,
+	DNA, DNA, DNA,		DCOND, DNA, DNA, DNA)
+
+#define SFM_PUW_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	int _i, _count = FCNT ? FCNT : 4;				\
+	md_addr_t _addr;						\
+	enum md_fault_type _fault;					\
+									\
+	_addr = GPR_EX(RN) + FPOFS;					\
+	for (_i=0; _i < _count; _i++)					\
+	  {								\
+	    WRITE_QWORD(FPR_Q((FD)+_i), _addr+_i*8, _fault);		\
+	    if (_fault != md_fault_none)				\
+	      DECLARE_FAULT(_fault);					\
+	  }								\
+									\
+	SET_GPR(RN, _addr);						\
+      }									\
+  }
+DEFINST(SFM_PUW,		0x0a,
+	"sfm%c",		"%D,%C,[%n,#%O]!",
+	WrPort,			F_MEM|F_STORE|F_DISP|F_CISC,
+	DNA, DNA, DNA,		DCOND, DNA, DNA, DNA)
+
+#define LFM_PUWL_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	int _i, _count = FCNT ? FCNT : 4;				\
+	md_addr_t _addr;						\
+	qword_t _result;						\
+	enum md_fault_type _fault;					\
+									\
+	_addr = GPR_EX(RN) + FPOFS;					\
+	for (_i=0; _i < _count; _i++)					\
+	  {								\
+	    _result = READ_QWORD(_addr+_i*8, _fault);			\
+	    if (_fault != md_fault_none)				\
+	      DECLARE_FAULT(_fault);					\
+	    SET_FPR_Q((FD)+_i, _result);				\
+	  }								\
+									\
+	SET_GPR(RN, _addr);						\
+      }									\
+  }
+DEFINST(LFM_PUWL,		0x0b,
+	"lfm%c",		"%D,%C,[%n,#%O]!",
+	WrPort,			F_MEM|F_STORE|F_DISP|F_CISC,
+	DNA, DNA, DNA,		DCOND, DNA, DNA, DNA)
+
+
+/*
+ * UOP definitions
+ */
+
+/* address generation UOPs */
+#define AGEN_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+        SET_GPR(URD, GPR_EX(URN) - SHIFTRM(GPR(RM), /* unused */0, PSR_C));\
+      }									\
+  }
+DEFUOP(AGEN,
+       "agen%c",		"%v,%u,-%m",
+       IntALU,			F_ICOMP|F_AGEN,
+       DGPR(URD), DNA, DNA,	DCONDSH, DGPR(URN), DGPR(RM), DNA)
+
+#define AGEN_U_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+        SET_GPR(URD, GPR_EX(URN) + SHIFTRM(GPR(RM), /* unused */0, PSR_C));\
+      }									\
+  }
+DEFUOP(AGEN_U,
+       "agen%c",		"%v,%u,%m",
+       IntALU,			F_ICOMP|F_AGEN,
+       DGPR(URD), DNA, DNA,	DCONDSH, DGPR(URN), DGPR(RM), DNA)
+
+#define AGENI_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+        SET_GPR(URD, GPR_EX(URN) - OFS);				\
+      }									\
+  }
+DEFUOP(AGENI,
+       "agen%c",		"%v,%u,-%o",
+       IntALU,			F_ICOMP|F_AGEN,
+       DGPR(URD), DNA, DNA,	DCOND, DGPR(URN), DNA, DNA)
+
+#define AGENI_U_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+        SET_GPR(URD, GPR_EX(URN) + OFS);				\
+      }									\
+  }
+DEFUOP(AGENI_U,
+       "agen%c",		"%v,%u,%o",
+       IntALU,			F_ICOMP|F_AGEN,
+       DGPR(URD), DNA, DNA,	DCOND, DGPR(URN), DNA, DNA)
+
+/* load/store primitives */
+#define STP_B_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	enum md_fault_type _fault;					\
+									\
+	WRITE_BYTE((byte_t)GPR_MEM(RD), GPR_EX(URN), _fault);		\
+	if (_fault != md_fault_none)					\
+	  DECLARE_FAULT(_fault);					\
+      }									\
+  }
+DEFUOP(STP_B,
+       "stp%cb",		"%d,[%u]",
+       WrPort,			F_MEM|F_STORE|F_DISP,
+       DNA, DNA, DNA,		DGPR(RD), /**/DCOND, DGPR(URN), DNA)
+
+#define LDP_B_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	byte_t _result;							\
+	enum md_fault_type _fault;					\
+									\
+	_result = READ_BYTE(GPR_EX(URN), _fault);			\
+	if (_fault != md_fault_none)					\
+	  DECLARE_FAULT(_fault);					\
+	SET_GPR(RD, (word_t)_result);					\
+      }									\
+  }
+DEFUOP(LDP_B,
+       "ldp%cb",		"%d,[%u]",
+       WrPort,			F_MEM|F_LOAD|F_DISP,
+       DGPR(RD), DNA, DNA,	DNA, /**/DCOND, DGPR(URN), DNA)
+
+#define LDP_SB_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	byte_t _result;							\
+	enum md_fault_type _fault;					\
+									\
+	_result = READ_BYTE(GPR_EX(URN), _fault);			\
+	if (_fault != md_fault_none)					\
+	  DECLARE_FAULT(_fault);					\
+	SET_GPR(RD, (word_t)(sword_t)(sbyte_t)_result);			\
+      }									\
+  }
+DEFUOP(LDP_SB,
+       "ldp%csb",		"%d,[%u]",
+       WrPort,			F_MEM|F_LOAD|F_DISP,
+       DGPR(RD), DNA, DNA,	DNA, /**/DCOND, DGPR(URN), DNA)
+
+#define STP_H_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	enum md_fault_type _fault;					\
+									\
+	WRITE_HALF((half_t)GPR_MEM(RD), GPR_EX(URN), _fault);		\
+	if (_fault != md_fault_none)					\
+	  DECLARE_FAULT(_fault);					\
+      }									\
+  }
+DEFUOP(STP_H,
+       "stp%ch",		"%d,[%u]",
+       WrPort,			F_MEM|F_STORE|F_DISP,
+       DNA, DNA, DNA,		DGPR(RD), /**/DCOND, DGPR(URN), DNA)
+
+#define LDP_H_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	half_t _result;							\
+	enum md_fault_type _fault;					\
+									\
+	_result = READ_HALF(GPR_EX(URN), _fault);			\
+	if (_fault != md_fault_none)					\
+	  DECLARE_FAULT(_fault);					\
+	SET_GPR(RD, (word_t)_result);					\
+      }									\
+  }
+DEFUOP(LDP_H,
+       "ldp%ch",		"%d,[%u]",
+       WrPort,			F_MEM|F_LOAD|F_DISP,
+       DGPR(RD), DNA, DNA,	DNA, /**/DCOND, DGPR(URN), DNA)
+
+#define LDP_SH_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	half_t _result;							\
+	enum md_fault_type _fault;					\
+									\
+	_result = READ_HALF(GPR_EX(URN), _fault);			\
+	if (_fault != md_fault_none)					\
+	  DECLARE_FAULT(_fault);					\
+	SET_GPR(RD, (word_t)(sword_t)(shalf_t)_result);			\
+      }									\
+  }
+DEFUOP(LDP_SH,
+       "ldp%csh",		"%d,[%u]",
+       WrPort,			F_MEM|F_LOAD|F_DISP,
+       DGPR(RD), DNA, DNA,	DNA, /**/DCOND, DGPR(URN), DNA)
+
+#define STP_W_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	enum md_fault_type _fault;					\
+									\
+	WRITE_WORD(GPR_MEM(RD), GPR_EX(URN), _fault);			\
+	if (_fault != md_fault_none)					\
+	  DECLARE_FAULT(_fault);					\
+      }									\
+  }
+DEFUOP(STP_W,
+       "stp%c",			"%d,[%u]",
+       WrPort,			F_MEM|F_STORE|F_DISP,
+       DNA, DNA, DNA,		DGPR(RD), /**/DCOND, DGPR(URN), DNA)
+
+#define LDP_W_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	word_t _result;							\
+	enum md_fault_type _fault;					\
+									\
+	_result = READ_WORD(GPR_EX(URN), _fault);			\
+	if (_fault != md_fault_none)					\
+	  DECLARE_FAULT(_fault);					\
+	SET_GPR(RD, _result);						\
+      }									\
+  }
+DEFUOP(LDP_W,
+       "ldp%c",			"%d,[%u]",
+       WrPort,			F_MEM|F_LOAD|F_DISP,
+       DGPR(RD), DNA, DNA,	DNA, /**/DCOND, DGPR(URN), DNA)
+
+#define STP_S_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	enum md_fault_type _fault;					\
+									\
+	WRITE_WORD(FPR_W(FD), GPR_EX(URN), _fault);			\
+	if (_fault != md_fault_none)					\
+	  DECLARE_FAULT(_fault);					\
+      }									\
+  }
+DEFUOP(STP_S,
+       "stp%cs",		"%D,[%u]",
+       WrPort,			F_MEM|F_STORE|F_DISP,
+       DNA, DNA, DNA,		DFPR(FD), /**/DCOND, DGPR(URN), DNA)
+
+#define LDP_S_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	word_t _result;							\
+	enum md_fault_type _fault;					\
+									\
+	_result = READ_WORD(GPR_EX(URN), _fault);			\
+	if (_fault != md_fault_none)					\
+	  DECLARE_FAULT(_fault);					\
+	SET_FPR_W(FD, _result);						\
+      }									\
+  }
+DEFUOP(LDP_S,
+       "ldp%cs",		"%D,[%u]",
+       WrPort,			F_MEM|F_LOAD|F_DISP,
+       DFPR(FD), DNA, DNA,	DNA, /**/DCOND, DGPR(URN), DNA)
+
+#define STP_D_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	enum md_fault_type _fault;					\
+									\
+	WRITE_QWORD(FPR_Q(FD), GPR_EX(URN), _fault);			\
+	if (_fault != md_fault_none)					\
+	  DECLARE_FAULT(_fault);					\
+      }									\
+  }
+DEFUOP(STP_D,
+       "stp%cd",		"%D,[%u]",
+       WrPort,			F_MEM|F_STORE|F_DISP,
+       DNA, DNA, DNA,		DFPR(FD), /**/DCOND, DGPR(URN), DNA)
+
+#define LDP_D_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	qword_t _result;						\
+	enum md_fault_type _fault;					\
+									\
+	_result = READ_QWORD(GPR_EX(URN), _fault);			\
+	if (_fault != md_fault_none)					\
+	  DECLARE_FAULT(_fault);					\
+	SET_FPR_Q(FD, _result);						\
+      }									\
+  }
+DEFUOP(LDP_D,
+       "ldp%cd",		"%D,[%u]",
+       WrPort,			F_MEM|F_LOAD|F_DISP,
+       DFPR(FD), DNA, DNA,	DNA, /**/DCOND, DGPR(URN), DNA)
+
+#define STP_E_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	enum md_fault_type _fault;					\
+									\
+	WRITE_QWORD(FPR_Q(FD), GPR_EX(URN), _fault);			\
+	if (_fault != md_fault_none)					\
+	  DECLARE_FAULT(_fault);					\
+      }									\
+  }
+DEFUOP(STP_E,
+       "stp%ce",		"%D,[%u]",
+       WrPort,			F_MEM|F_STORE|F_DISP,
+       DNA, DNA, DNA,		DFPR(FD), /**/DCOND, DGPR(URN), DNA)
+
+#define LDP_E_IMPL							\
+  {									\
+    if (COND_VALID(PSR))						\
+      {									\
+	qword_t _result;						\
+	enum md_fault_type _fault;					\
+									\
+	_result = READ_QWORD(GPR_EX(URN), _fault);			\
+	if (_fault != md_fault_none)					\
+	  DECLARE_FAULT(_fault);					\
+	SET_FPR_Q(FD, _result);						\
+      }									\
+  }
+DEFUOP(LDP_E,
+       "ldp%ce",		"%D,[%u]",
+       WrPort,			F_MEM|F_LOAD|F_DISP,
+       DFPR(FD), DNA, DNA,	DNA, /**/DCOND, DGPR(URN), DNA)
+
+
+/* clean up all definitions... */
+#undef BR_IMPL
+#undef BRL_IMPL
+#undef SWI_IMPL
+#undef AND_IMPL
+#undef ANDS_IMPL
+#undef EOR_IMPL
+#undef EORS_IMPL
+#undef SUB_IMPL
+#undef SUBS_IMPL
+#undef RSB_IMPL
+#undef RSBS_IMPL
+#undef ADD_IMPL
+#undef ADDS_IMPL
+#undef ADC_IMPL
+#undef ADCS_IMPL
+#undef SBC_IMPL
+#undef SBCS_IMPL
+#undef RSC_IMPL
+#undef RSCS_IMPL
+#undef TSTS_IMPL
+#undef TEQS_IMPL
+#undef CMPS_IMPL
+#undef CMNS_IMPL
+#undef ORR_IMPL
+#undef ORRS_IMPL
+#undef MOV_IMPL
+#undef MOVS_IMPL
+#undef BIC_IMPL
+#undef BICS_IMPL
+#undef MVN_IMPL
+#undef MVNS_IMPL
+#undef MRS_CPSR_IMPL
+#undef TST_IMPL
+#undef SWP_IMPL
+#undef TEQ_IMPL
+#undef MSR_CPSR_IMPL
+#undef MRS_SPSR_IMPL
+#undef CMP_IMPL
+#undef SWP1_IMPL
+#undef TST1_IMPL
+#undef MSR_SPSR_IMPL
+#undef ANDI_IMPL
+#undef ANDSI_IMPL
+#undef EORI_IMPL
+#undef EORSI_IMPL
+#undef SUBI_IMPL
+#undef SUBSI_IMPL
+#undef RSBI_IMPL
+#undef RSBSI_IMPL
+#undef ADDI_IMPL
+#undef ADDSI_IMPL
+#undef ADCI_IMPL
+#undef ADCSI_IMPL
+#undef SBCI_IMPL
+#undef SBCSI_IMPL
+#undef RSCI_IMPL
+#undef RSCSI_IMPL
+#undef TSTI_IMPL
+#undef TSTSI_IMPL
+#undef TEQSI_IMPL
+#undef CMPI_IMPL
+#undef CMPSI_IMPL
+#undef CMNSI_IMPL
+#undef ORRI_IMPL
+#undef ORRSI_IMPL
+#undef MOVI_IMPL
+#undef MOVSI_IMPL
+#undef BICI_IMPL
+#undef BICSI_IMPL
+#undef MVNI_IMPL
+#undef MVNSI_IMPL
+#undef TEQI_IMPL
+#undef MSRI_CPSR_IMPL
+#undef TSTI1_IMPL
+#undef MSRI_SPSR_IMPL
+#undef MUL_IMPL
+#undef MULS_IMPL
+#undef MLA_IMPL
+#undef MLAS_IMPL
+#undef UMULL_IMPL
+#undef UMULLS_IMPL
+#undef UMLAL_IMPL
+#undef UMLALS_IMPL
+#undef SMULL_IMPL
+#undef SMULLS_IMPL
+#undef SMLAL_IMPL
+#undef SMLALS_IMPL
+#undef STRH_R_IMPL
+#undef LDRH_RL_IMPL
+#undef STRH_O_IMPL
+#undef LDRH_OL_IMPL
+#undef STRH_RU_IMPL
+#undef LDRH_RUL_IMPL
+#undef STRH_OU_IMPL
+#undef LDRH_OUL_IMPL
+#undef LDRSB_RL_IMPL
+#undef LDRSB_OL_IMPL
+#undef LDRSB_RUL_IMPL
+#undef LDRSB_OUL_IMPL
+#undef LDRSH_RL_IMPL
+#undef LDRSH_OL_IMPL
+#undef LDRSH_RUL_IMPL
+#undef LDRSH_OUL_IMPL
+#undef STRH_PR_IMPL
+#undef LDRH_PRL_IMPL
+#undef STRH_PRW_IMPL
+#undef LDRH_PRWL_IMPL
+#undef STRH_PO_IMPL
+#undef LDRH_POL_IMPL
+#undef STRH_POW_IMPL
+#undef LDRH_POWL_IMPL
+#undef STRH_PRU_IMPL
+#undef LDRH_PRUL_IMPL
+#undef STRH_PRUW_IMPL
+#undef LDRH_PRUWL_IMPL
+#undef STRH_POU_IMPL
+#undef LDRH_POUL_IMPL
+#undef STRH_POUW_IMPL
+#undef LDRH_POUWL_IMPL
+#undef LDRSB_PRL_IMPL
+#undef LDRSB_PRWL_IMPL
+#undef LDRSB_POL_IMPL
+#undef LDRSB_POWL_IMPL
+#undef LDRSB_PRUL_IMPL
+#undef LDRSB_PRUWL_IMPL
+#undef LDRSB_POUL_IMPL
+#undef LDRSB_POUWL_IMPL
+#undef LDRSH_PRL_IMPL
+#undef LDRSH_PRWL_IMPL
+#undef LDRSH_POL_IMPL
+#undef LDRSH_POWL_IMPL
+#undef LDRSH_PRUL_IMPL
+#undef LDRSH_PRUWL_IMPL
+#undef LDRSH_POUL_IMPL
+#undef LDRSH_POUWL_IMPL
+#undef STR_IMPL
+#undef LDR_L_IMPL
+#undef STR_B_IMPL
+#undef LDR_BL_IMPL
+#undef STR_U_IMPL
+#undef LDR_UL_IMPL
+#undef STR_UB_IMPL
+#undef LDR_UBL_IMPL
+#undef STR_P_IMPL
+#undef LDR_PL_IMPL
+#undef STR_PW_IMPL
+#undef LDR_PWL_IMPL
+#undef STR_PB_IMPL
+#undef LDR_PBL_IMPL
+#undef STR_PBW_IMPL
+#undef LDR_PBWL_IMPL
+#undef STR_PU_IMPL
+#undef LDR_PUL_IMPL
+#undef STR_PUW_IMPL
+#undef LDR_PUWL_IMPL
+#undef STR_PUB_IMPL
+#undef LDR_PUBL_IMPL
+#undef STR_PUBW_IMPL
+#undef LDR_PUBWL_IMPL
+#undef STR_R_IMPL
+#undef LDR_RL_IMPL
+#undef STR_RB_IMPL
+#undef LDR_RBL_IMPL
+#undef STR_RU_IMPL
+#undef LDR_RUL_IMPL
+#undef STR_RUB_IMPL
+#undef LDR_RUBL_IMPL
+#undef STR_RP_IMPL
+#undef LDR_RPL_IMPL
+#undef STR_RPW_IMPL
+#undef LDR_RPWL_IMPL
+#undef STR_RPB_IMPL
+#undef LDR_RPBL_IMPL
+#undef STR_RPBW_IMPL
+#undef LDR_RPBWL_IMPL
+#undef STR_RPU_IMPL
+#undef LDR_RPUL_IMPL
+#undef STR_RPUW_IMPL
+#undef LDR_RPUWL_IMPL
+#undef STR_RPUB_IMPL
+#undef LDR_RPUBL_IMPL
+#undef STR_RPUBW_IMPL
+#undef LDR_RPUBWL_IMPL
+#undef STM_IMPL
+#undef STM_S_IMPL 
+#undef LDM_SL_IMPL
+#undef LDM_SWL_IMPL 
+#undef STM_US_IMPL
+#undef LDM_USL_IMPL
+#undef LDM_USWL_IMPL
+#undef LDM_PUWL_IMPL
+#undef STM_PS_IMPL
+#undef LDM_PSL_IMPL
+#undef LDM_PSWL_IMPL
+#undef STM_PUS_IMPL
+#undef LDM_PUSL_IMPL
+#undef LDM_PUSWL_IMPL
+#undef LDM_L_IMPL
+#undef STM_W_IMPL
+#undef LDM_WL_IMPL
+#undef STM_U_IMPL
+#undef LDM_UL_IMPL
+#undef STM_UW_IMPL
+#undef LDM_UWL_IMPL
+#undef STM_P_IMPL
+#undef LDM_PL_IMPL
+#undef STM_PW_IMPL
+#undef LDM_PWL_IMPL
+#undef STM_PU_IMPL
+#undef LDM_PUL_IMPL
+#undef STM_PUW_IMPL
+#undef LDM_PUWL_IMPL
+#undef ADF_IMPL
+#undef ADFI_IMPL
+#undef MVF_IMPL
+#undef MVFI_IMPL
+#undef MUF_IMPL
+#undef MUFI_IMPL
+#undef MNF_IMPL
+#undef MNFI_IMPL
+#undef SUF_IMPL
+#undef SUFI_IMPL
+#undef ABS_IMPL
+#undef ABSI_IMPL
+#undef RSF_IMPL
+#undef RSFI_IMPL
+#undef RND_IMPL
+#undef RNDI_IMPL
+#undef DVF_IMPL
+#undef DVFI_IMPL
+#undef SQT_IMPL
+#undef SQTI_IMPL
+#undef RDF_IMPL
+#undef RDFI_IMPL
+#undef LOG_IMPL
+#undef LOGI_IMPL
+#undef POW_IMPL
+#undef POWI_IMPL
+#undef LGN_IMPL
+#undef LGNI_IMPL
+#undef RPW_IMPL
+#undef RPWI_IMPL
+#undef EXP_IMPL
+#undef EXPI_IMPL
+#undef RMF_IMPL
+#undef RMFI_IMPL
+#undef SIN_IMPL
+#undef SINI_IMPL
+#undef FML_IMPL
+#undef FMLI_IMPL
+#undef COS_IMPL
+#undef COSI_IMPL
+#undef FDV_IMPL
+#undef FDVI_IMPL
+#undef TAN_IMPL
+#undef TANI_IMPL
+#undef FRD_IMPL
+#undef FRDI_IMPL
+#undef ASN_IMPL
+#undef ASNI_IMPL
+#undef POL_IMPL
+#undef POLI_IMPL
+#undef ACS_IMPL
+#undef ACSI_IMPL
+#undef ATN_IMPL
+#undef ATNI_IMPL
+#undef FURD_IMPL
+#undef FURDI_IMPL
+#undef NRM_IMPL
+#undef NRMI_IMPL
+#undef CDP_IMPL
+#undef FLT_IMPL
+#undef FIX_IMPL
+#undef WFS_IMPL
+#undef RFS_IMPL
+#undef WFC_IMPL
+#undef RFC_IMPL
+#undef CMF_IMPL
+#undef CMFI_IMPL
+#undef CNF_IMPL
+#undef CNFI_IMPL
+#undef CMFE_IMPL
+#undef CMFEI_IMPL
+#undef CNFE_IMPL
+#undef CNFEI_IMPL
+#undef STFS_W_IMPL
+#undef STFD_W_IMPL
+#undef LDFS_WL_IMPL
+#undef LDFD_WL_IMPL
+#undef STFE_W_IMPL
+#undef STFP_W_IMPL
+#undef LDFE_WL_IMPL
+#undef LDFP_WL_IMPL
+#undef STFS_UW_IMPL
+#undef STFD_UW_IMPL
+#undef LDFS_UWL_IMPL
+#undef LDFD_UWL_IMPL
+#undef STFE_UW_IMPL
+#undef STFP_UW_IMPL
+#undef LDFE_UWL_IMPL
+#undef LDFP_UWL_IMPL
+#undef STFS_P_IMPL
+#undef STFD_P_IMPL
+#undef LDFS_PL_IMPL
+#undef LDFD_PL_IMPL
+#undef STFS_PW_IMPL
+#undef STFD_PW_IMPL
+#undef LDFS_PWL_IMPL
+#undef LDFD_PWL_IMPL
+#undef STFE_P_IMPL
+#undef STFP_P_IMPL
+#undef LDFE_PL_IMPL
+#undef LDFP_PL_IMPL
+#undef STFE_PW_IMPL
+#undef STFP_PW_IMPL
+#undef LDFE_PWL_IMPL
+#undef LDFP_PWL_IMPL
+#undef STFS_PU_IMPL
+#undef STFD_PU_IMPL
+#undef LDFS_PUL_IMPL
+#undef LDFD_PUL_IMPL
+#undef STFS_PUW_IMPL
+#undef STFD_PUW_IMPL
+#undef LDFS_PUWL_IMPL
+#undef LDFD_PUWL_IMPL
+#undef STFE_PU_IMPL
+#undef STFP_PU_IMPL
+#undef LDFE_PUL_IMPL
+#undef LDFP_PUL_IMPL
+#undef STFE_PUW_IMPL
+#undef STFP_PUW_IMPL
+#undef LDFE_PUWL_IMPL
+#undef LDFP_PUWL_IMPL
+#undef SFM_W_IMPL
+#undef LFM_WL_IMPL
+#undef SFM_UW_IMPL
+#undef LFM_UWL_IMPL
+#undef SFM_P_IMPL
+#undef LFM_PL_IMPL
+#undef SFM_PW_IMPL
+#undef LFM_PWL_IMPL
+#undef SFM_PU_IMPL
+#undef LFM_PUL_IMPL
+#undef SFM_PUW_IMPL
+#undef LFM_PUWL_IMPL
+#undef AGEN_IMPL
+#undef AGEN_U_IMPL
+#undef AGENI_IMPL
+#undef AGENI_U_IMPL
+#undef STP_B_IMPL
+#undef LDP_B_IMPL
+#undef LDP_SB_IMPL
+#undef STP_H_IMPL
+#undef LDP_H_IMPL
+#undef LDP_SH_IMPL
+#undef STP_W_IMPL
+#undef LDP_W_IMPL
+#undef STP_S_IMPL
+#undef LDP_S_IMPL
+#undef STP_D_IMPL
+#undef LDP_D_IMPL
+#undef STP_E_IMPL
+#undef LDP_E_IMPL
+
+#undef DEFINST
+#undef DEFUOP
+#undef DEFLINK
+#undef CONNECT
diff --git a/machine.h b/machine.h
deleted file mode 120000
index 2e357de..ac581e0
--- a/machine.h
+++ /dev/null
@@ -1 +0,0 @@
-target-arm/arm.h
\ No newline at end of file
diff --git a/machine.h b/machine.h
new file mode 100644
index 2e357de..ac581e0
--- /dev/null
+++ b/machine.h
@@ -0,0 +1,876 @@
+/*
+ * arm.h - ARM ISA definitions
+ *
+ * This file is a part of the SimpleScalar tool suite written by
+ * Todd M. Austin as a part of the Multiscalar Research Project.
+ *  
+ * The tool suite is currently maintained by Doug Burger and Todd M. Austin.
+ * 
+ * Copyright (C) 1994, 1995, 1996, 1997, 1998 by Todd M. Austin
+ *
+ * This source file is distributed "as is" in the hope that it will be
+ * useful.  The tool set comes with no warranty, and no author or
+ * distributor accepts any responsibility for the consequences of its
+ * use. 
+ * 
+ * Everyone is granted permission to copy, modify and redistribute
+ * this tool set under the following conditions:
+ * 
+ *    This source code is distributed for non-commercial use only. 
+ *    Please contact the maintainer for restrictions applying to 
+ *    commercial use.
+ *
+ *    Permission is granted to anyone to make or distribute copies
+ *    of this source code, either as received or modified, in any
+ *    medium, provided that all copyright notices, permission and
+ *    nonwarranty notices are preserved, and that the distributor
+ *    grants the recipient permission for further redistribution as
+ *    permitted by this document.
+ *
+ *    Permission is granted to distribute this file in compiled
+ *    or executable form under the same conditions that apply for
+ *    source code, provided that either:
+ *
+ *    A. it is accompanied by the corresponding machine-readable
+ *       source code,
+ *    B. it is accompanied by a written offer, with no time limit,
+ *       to give anyone a machine-readable copy of the corresponding
+ *       source code in return for reimbursement of the cost of
+ *       distribution.  This written offer must permit verbatim
+ *       duplication by anyone, or
+ *    C. it is distributed by someone who received only the
+ *       executable form, and is accompanied by a copy of the
+ *       written offer of source code that they received concurrently.
+ *
+ * In other words, you are welcome to use, share and improve this
+ * source file.  You are forbidden to forbid anyone else to use, share
+ * and improve what you give them.
+ *
+ * INTERNET: dburger@cs.wisc.edu
+ * US Mail:  1210 W. Dayton Street, Madison, WI 53706
+ *
+ * $Id: arm.h,v 1.1.1.1 2000/11/29 14:53:54 cu-cs Exp $
+ *
+ * $Log: arm.h,v $
+ * Revision 1.1.1.1  2000/11/29 14:53:54  cu-cs
+ * Grand unification of arm sources.
+ *
+ *
+ * Revision 1.1.2.17  2000/11/21 14:52:08  taustin
+ * Completed changes for SA-1 core validation.
+ *
+ * Revision 1.1.2.16  2000/09/26 15:45:38  taustin
+ * Attempted to get sim-outorder working, so so...
+ * Dependency fixes.
+ *
+ * Revision 1.1.2.15  2000/09/22 01:58:19  taustin
+ * Finished UOP flow generation support.
+ *
+ * Revision 1.1.2.14  2000/09/19 17:25:38  taustin
+ * Completed UOP decomposition code, all UOPs now take nominally one cycle on a
+ * simple pipeline, including loads and stores.  Initial testing has the code
+ * working fine, however, extensive random testing will occur when sim-fuzz.c
+ * gets extended to support multiple functional units...
+ *
+ * Revision 1.1.2.13  2000/09/11 12:23:10  taustin
+ * Added UOP decomposition routines, used by sim-uop, soon to used by perf
+ * simulators.
+ *
+ * Revision 1.1.2.12  2000/09/05 13:56:34  taustin
+ * Lots of fixes after simulating using the new SimpleScalar/ARM fuzz buster to
+ * perform random co-simulation testing, very handy!
+ *
+ * Revision 1.1.2.11  2000/08/29 14:18:27  taustin
+ * Fixed word and qword size fp register accesses.
+ * Addes time() and times() system call support (for Perl).
+ *
+ * Revision 1.1.2.10  2000/08/26 06:54:11  taustin
+ * Simplified SimpleScalar/ARM PC handling - seems to work...
+ * More SimpleScalar/ARM instruction definition debug work.
+ *
+ * Revision 1.1.2.9  2000/08/22 18:38:54  taustin
+ * More progress on the SimpleScalar/ARM target.
+ *
+ * Revision 1.1.2.8  2000/08/02 08:52:15  taustin
+ * SimpleScalar/ARM co-simulation component, based on the ARMulator.
+ * More fixes to the SimpleScalar/ARM target.
+ *
+ * Revision 1.1.2.7  2000/07/27 21:45:06  taustin
+ * Added umpteen half word and signed byte loads.
+ *
+ * Revision 1.1.2.6  2000/07/27 19:12:09  omutlu
+ * some fixes to cdp instruction. needs more work
+ *
+ * Revision 1.1.2.5  2000/07/26 05:01:52  taustin
+ * More disassembler fixes...
+ *
+ * Revision 1.1.2.4  2000/07/25 18:29:06  omutlu
+ * Modified the branch offset calculation, cmp, ldm
+ *
+ * Revision 1.1.2.3  2000/07/21 18:31:00  taustin
+ * More progress on the SimpleScalar/ARM target.
+ *
+ * Revision 1.1.2.2  2000/07/13 03:09:56  taustin
+ * More progress on the SimpleScalar/ARM target.
+ *
+ * Revision 1.1.2.1  2000/05/31 19:26:00  taustin
+ * ARM definition files
+ *
+ * Revision 1.1.1.1  2000/05/26 15:22:27  taustin
+ * SimpleScalar Tool Set
+ *
+ *
+ * Revision 1.4  1999/12/31 18:58:15  taustin
+ * quad_t naming conflicts removed
+ * MD_FETCH_INST() macro fixed
+ * Alpha instruction set extensions (MVI, BWX, AMASK, IMPLVER, etc...)
+ *
+ * Revision 1.3  1999/12/13 18:59:40  taustin
+ * cross endian execution support added
+ *
+ * Revision 1.2  1998/08/31 17:15:23  taustin
+ * fixed non-portable SEXT definitions
+ *
+ * Revision 1.1  1998/08/27 16:53:36  taustin
+ * Initial revision
+ *
+ * Revision 1.1  1998/05/06  01:09:18  calder
+ * Initial revision
+ *
+ * Revision 1.5  1997/03/11  01:38:10  taustin
+ * updated copyrights
+ * long/int tweaks made for ALPHA target support
+ * IFAIL() hook now allows simulators to declare instruction faults
+ * IDIV()/IMOD()/FDIV() hooks now support simulator fault masking
+ * supported added for non-GNU C compilers
+ *
+ * Revision 1.4  1997/01/06  16:08:10  taustin
+ * comments updated
+ * functional unit definitions moved from ss.def
+ *
+ * Revision 1.3  1996/12/27  15:55:37  taustin
+ * fixed system header collision with MAXINT
+ *
+ * Revision 1.1  1996/12/05  18:50:23  taustin
+ * Initial revision
+ *
+ */
+
+#ifndef ARM_H
+#define ARM_H
+
+#include <stdio.h>
+
+#include "host.h"
+#include "misc.h"
+#include "config.h"
+#include "endian.h"
+
+
+/*
+ * This file contains various definitions needed to decode, disassemble, and
+ * execute ARM instructions.
+ */
+
+/* build for ARM target */
+#define TARGET_ARM
+
+/* probe cross-endian execution */
+#if defined(BYTES_BIG_ENDIAN)
+#define MD_CROSS_ENDIAN
+#endif
+
+/* not applicable/available, usable in most definition contexts */
+#define NA		0
+
+/*
+ * target-dependent type definitions
+ */
+
+/* define MD_QWORD_ADDRS if the target requires 64-bit (qword) addresses */
+/* #define MD_QWORD_ADDRS */
+
+/* address type definition */
+typedef word_t md_addr_t;
+
+
+/*
+ * target-dependent memory module configuration
+ */
+
+/* physical memory page size (must be a power-of-two) */
+#define MD_PAGE_SIZE		4096
+#define MD_LOG_PAGE_SIZE	12
+
+
+/*
+ * target-dependent instruction faults
+ */
+
+enum md_fault_type {
+  md_fault_none = 0,		/* no fault */
+  md_fault_access,		/* storage access fault */
+  md_fault_alignment,		/* storage alignment fault */
+  md_fault_overflow,		/* signed arithmetic overflow fault */
+  md_fault_div0,		/* division by zero fault */
+  md_fault_invalid,             /* invalid arithmetic operation */ 
+                                /* added to allow SQRT{S,T} in FIX exts */
+  md_fault_break,		/* BREAK instruction fault */
+  md_fault_unimpl,		/* unimplemented instruction fault */
+  md_fault_internal		/* internal S/W fault */
+};
+
+
+#define MD_CLOCK_CYCLES_PER_MICROSECOND     25 /* i.e. 25MHz processor */
+/*
+ * target-dependent register file definitions, used by regs.[hc]
+ */
+
+/* number of integer registers */
+#define MD_NUM_IREGS		(/* arch */16 + /* Ucode */16 + /*saved*/ 10)
+#define MD_R13_SVC          32
+#define MD_R13_ABORT        34
+#define MD_R13_IRQ          36
+#define MD_R13_FIQ          38
+#define MD_R13_UNDEF        40
+
+/* number of floating point registers */
+#define MD_NUM_FREGS		8
+
+/* number of control registers */
+#define MD_NUM_CREGS		4
+
+/* total number of registers, excluding PC and NPC */
+#define MD_TOTAL_REGS							\
+  (/*int*/32 + /*fp*/8 + /*misc*/3 + /*tmp*/1 + /*mem*/1 + /*ctrl*/2)
+
+/* general purpose (integer) register file entry type */
+typedef word_t md_gpr_t[MD_NUM_IREGS];
+
+/* floating point register file entry type */
+typedef union {
+  qword_t q[MD_NUM_FREGS];	/* integer qword view */
+  dfloat_t d[MD_NUM_FREGS];	/* double-precision floating point view */
+} md_fpr_t;
+
+/* control register file contents */
+typedef struct {
+  word_t cpsr;			/* processor status register */
+  word_t spsr [ 5 ] ;
+  word_t fpsr;			/* floating point status register */
+} md_ctrl_t;
+
+#define MD_SPSR_SVC     0
+#define MD_SPSR_ABORT   1
+#define MD_SPSR_UNDEF   2
+#define MD_SPSR_IRQ     3
+#define MD_SPSR_FIQ     4
+
+/* well known registers */
+enum md_reg_names {
+  MD_REG_R0 = 0,
+  MD_REG_V0 = 0,	/* return value reg */
+  MD_REG_A0 = 0,	/* argument regs */
+  MD_REG_R1 = 1,
+  MD_REG_A1 = 1,
+  MD_REG_R2 = 2,
+  MD_REG_A2 = 2,
+  MD_REG_R3 = 3,
+  MD_REG_A3 = 3,
+  MD_REG_R4 = 4,
+  MD_REG_R5 = 5,
+  MD_REG_R6 = 6,
+  MD_REG_R7 = 7,
+  MD_REG_R8 = 8,
+  MD_REG_R9 = 9,
+  MD_REG_R10 = 10,
+  MD_REG_SL = 10,
+  MD_REG_R11 = 11,
+  MD_REG_FP = 11,	/* frame pointer */
+  MD_REG_R12 = 12,
+  MD_REG_IP = 12,
+  MD_REG_R13 = 13,
+  MD_REG_SP = 13,	/* stack pointer */
+  MD_REG_R14 = 14,
+  MD_REG_LR = 14,	/* link register */
+  MD_REG_R15 = 15,
+  MD_REG_PC = 15,	/* link register */
+  MD_REG_TMP0 = 16,	/* temp registers - used by Ucode, 16 total */
+  MD_REG_TMP1 = 17,
+  MD_REG_TMP2 = 18,
+  MD_REG_TMP3 = 19
+};
+
+/*
+ * target-dependent instruction format definition
+ */
+
+/* instruction formats */
+typedef word_t md_inst_t;
+
+/* preferred nop instruction definition */
+extern md_inst_t MD_NOP_INST;
+
+/* target swap support */
+#ifdef MD_CROSS_ENDIAN
+
+#define MD_SWAPH(X)		SWAP_HALF(X)
+#define MD_SWAPW(X)		SWAP_WORD(X)
+#define MD_SWAPQ(X)		SWAP_QWORD(X)
+#define MD_SWAPI(X)		SWAP_WORD(X)
+
+#else /* !MD_CROSS_ENDIAN */
+
+#define MD_SWAPH(X)		(X)
+#define MD_SWAPW(X)		(X)
+#define MD_SWAPQ(X)		(X)
+#define MD_SWAPD(X)		(X)
+#define MD_SWAPI(X)		(X)
+
+#endif
+
+/* fetch an instruction */
+#define MD_FETCH_INST(INST, MEM, PC)					\
+  { (INST) = MEM_READ_WORD((MEM), (PC)); }
+
+/*
+ * target-dependent loader module configuration
+ */
+
+/* maximum size of argc+argv+envp environment */
+#define MD_MAX_ENVIRON		16384
+
+
+/*
+ * machine.def specific definitions
+ */
+
+/* inst -> enum md_opcode mapping, use this macro to decode insts */
+#define MD_TOP_OP(INST)		(((INST) >> 24) & 0x0f)
+#define MD_SET_OPCODE(OP, INST)						\
+  { OP = md_mask2op[MD_TOP_OP(INST)];					\
+    while (md_opmask[OP])						\
+      OP = md_mask2op[((INST >> md_opshift[OP]) & md_opmask[OP])	\
+		      + md_opoffset[OP]]; }
+
+/* largest opcode field value (currently upper 8-bit are used for pre/post-
+    incr/decr operation specifiers */
+#define MD_MAX_MASK		2048
+
+/* internal decoder state */
+extern enum md_opcode md_mask2op[];
+extern unsigned int md_opoffset[];
+extern unsigned int md_opmask[];
+extern unsigned int md_opshift[];
+
+/* global opcode names, these are returned by the decoder (MD_OP_ENUM()) */
+enum md_opcode {
+  OP_NA = 0,	/* NA */
+#define DEFINST(OP,MSK,NAME,OPFORM,RES,FLAGS,O1,O2,O3,I1,I2,I3,I4) OP,
+#define DEFUOP(OP,NAME,OPFORM,RES,FLAGS,O1,O2,O3,I1,I2,I3,I4) OP,
+#define DEFLINK(OP,MSK,NAME,MASK,SHIFT) OP,
+#define CONNECT(OP)
+#include "machine.def"
+  OP_MAX	/* number of opcodes + NA */
+};
+
+/* enum md_opcode -> description string */
+#define MD_OP_NAME(OP)		(md_op2name[OP])
+extern char *md_op2name[];
+
+/* enum md_opcode -> opcode operand format, used by disassembler */
+#define MD_OP_FORMAT(OP)	(md_op2format[OP])
+extern char *md_op2format[];
+
+/* function unit classes, update md_fu2name if you update this definition */
+enum md_fu_class {
+  FUClamd_NA = 0,	/* inst does not use a functional unit */
+  IntALU,		/* integer ALU */
+  IntMULT,		/* integer multiplier */
+  IntDIV,		/* integer divider */
+  FloatADD,		/* floating point adder/subtractor */
+  FloatCMP,		/* floating point comparator */
+  FloatCVT,		/* floating point<->integer converter */
+  FloatMULT,		/* floating point multiplier */
+  FloatDIV,		/* floating point divider */
+  FloatSQRT,		/* floating point square root */
+  RdPort,		/* memory read port */
+  WrPort,		/* memory write port */
+  NUM_FU_CLASSES	/* total functional unit classes */
+};
+
+/* enum md_opcode -> enum md_fu_class, used by performance simulators */
+#define MD_OP_FUCLASS(OP)	(md_op2fu[OP])
+extern enum md_fu_class md_op2fu[];
+
+/* enum md_fu_class -> description string */
+#define MD_FU_NAME(FU)		(md_fu2name[FU])
+extern char *md_fu2name[];
+
+/* instruction flags */
+#define F_ICOMP		0x00000001	/* integer computation */
+#define F_FCOMP		0x00000002	/* FP computation */
+#define F_CTRL		0x00000004	/* control inst */
+#define F_UNCOND	0x00000008	/*   unconditional change */
+#define F_COND		0x00000010	/*   conditional change */
+#define F_MEM		0x00000020	/* memory access inst */
+#define F_LOAD		0x00000040	/*   load inst */
+#define F_STORE		0x00000080	/*   store inst */
+#define F_DISP		0x00000100	/*   displaced (R+C) addr mode */
+#define F_RR		0x00000200	/*   R+R addr mode */
+#define F_DIRECT	0x00000400	/*   direct addressing mode */
+#define F_TRAP		0x00000800	/* traping inst */
+#define F_LONGLAT	0x00001000	/* long latency inst (for sched) */
+#define F_DIRJMP	0x00002000	/* direct jump */
+#define F_INDIRJMP	0x00004000	/* indirect jump */
+#define F_CALL		0x00008000	/* function call */
+#define F_FPCOND	0x00010000	/* FP conditional branch */
+#define F_IMM		0x00020000	/* instruction has immediate operand */
+#define F_CISC		0x00040000	/* CISC instruction */
+#define F_AGEN		0x00080000	/* AGEN micro-instruction */
+
+/* enum md_opcode -> opcode flags, used by simulators */
+#define MD_OP_FLAGS(OP)		(md_op2flags[OP])
+extern unsigned int md_op2flags[];
+
+
+/* integer register specifiers */
+#define RN		((inst >> 16) & 0x0f)
+#define URN		((inst >> 17) & 0x1f)	/* Ucode RN */
+#define RD		((inst >> 12) & 0x0f)
+#define URD		((inst >> 12) & 0x1f)	/* Ucode RD */
+#define RS		((inst >> 8) & 0x0f)
+#define RM		(inst & 0x0f)
+
+/* floating point register specifiers */
+#define FN		((inst >> 16) & 0x07)
+#define FD		((inst >> 12) & 0x07)
+#define FM		(inst & 0x07)
+
+/* register shift accessors */
+#define SHIFT_BITS	((inst >> 4) & 0xff)
+#define SHIFT_REG	((inst >> 4) & 0x01)
+#define SHIFT_REG_PAD	((inst >> 7) & 0x01)
+#define SHIFT_TYPE	((inst >> 5) & 0x03)
+#define SHIFT_SHAMT	((inst >> 7) & 0x1f)
+
+/* register shift types */
+#define SHIFT_LSL	0x00
+#define SHIFT_LSR	0x01
+#define SHIFT_ASR	0x02
+#define SHIFT_ROR	0x03
+
+/* rotated immediate accessors */
+#define ROTIMM		(inst & 0xff)
+#define ROTAMT		((inst >> 8) & 0x0f)
+
+/* rotate operator */
+#define ROTR(VAL,N)							\
+  (((VAL) >> (int)((N) & 31)) | ((VAL) << (32 - (int)((N) & 31))))
+
+/* load/store 12-bit unsigned offset field value */
+#define OFS		((word_t)(inst & 0xfff))
+
+/* load/store 8-bit unsigned offset field value */
+#define HOFS		((word_t)((RS << 4) + RM))
+
+/* fp load/store 8-bit unsigned offset field value */
+#define FPOFS		((word_t)((inst & 0xff) << 2))
+
+/* returns 24-bit signed immediate field value - made 2's complement - Onur 07/24/00 */
+#define BOFS								\
+  ((inst & 0x800000)							\
+   ? (0xfc000000 | ((inst & 0xffffff) << 2))				\
+   : ((inst & 0x7fffff) << 2))
+
+#if 0
+#define BOFS		((((word_t)(inst & 0xffffff)) >> 23) ? ((word_t)(-67108864 + (word_t)(((inst & 0xffffff) << 2)))) : ((word_t)((inst & 0xffffff)) << 2))
+#endif
+
+/* coprocessor operation code for CDP instruction */
+#define CPOPC ((inst >> 20) & 0x0f)
+#define CPEXT ((inst >> 5) & 0x07)
+
+/* sign-extend operands */
+#define SEXT24(X)							\
+  (((X) & 0x800000) ? ((sword_t)(X) | 0xff800000)) : (sqword_t)(X))
+
+/* load/store opcode accessors */
+#define LDST_PU		((inst >> 23) & 0x03)
+#define REGLIST		(inst & 0xffff)
+
+/* floating point opcode accessors */
+#define FPIMMBITS	(inst & 0x07)
+#define FPIMM		(md_fpimm[FPIMMBITS])
+extern double md_fpimm[8];
+
+#define EF_SIZE		(((inst >> 18) & 0x02) | ((inst >> 7) & 0x01))
+#define LDST_EF_SIZE	(((inst >> 21) & 0x02) | ((inst >> 15) & 0x01))
+#define GH_RNDMODE	((inst >> 5) & 0x03)
+#define FCNT		(((inst >> 21) & 0x02) | ((inst >> 15) & 0x01))
+
+/* ones counter */
+#define ONES(EXPR)	(md_ones(EXPR))
+
+/* ones counter function */
+int md_ones(word_t val);
+
+/* arithmetic flags */
+#define ADDC(LHS, RHS, RES)		md_addc((LHS), (RHS), (RES))
+#define ADDV(LHS, RHS, RES)		md_addv((LHS), (RHS), (RES))
+#define SUBC(LHS, RHS, RES)		md_subc((LHS), (RHS), (RES))
+#define SUBV(LHS, RHS, RES)		md_subv((LHS), (RHS), (RES))
+
+int md_addc(word_t lhs, word_t rhs, word_t res);
+int md_addv(word_t lhs, word_t rhs, word_t res);
+int md_subc(word_t lhs, word_t rhs, word_t res);
+int md_subv(word_t lhs, word_t rhs, word_t res);
+
+/* SWI accessors */
+#define SYSCODE		(inst & 0xffffff)
+
+/* default target PC handling */
+#ifndef SET_TPC
+#define SET_TPC(PC)	(void)0
+#endif /* SET_TPC */
+
+/* processor status register accessors */
+#define _PSR_N(PSR)		(((PSR) >> 31) & 1)
+#define _SET_PSR_N(PSR, VAL)						\
+  ((PSR) = (((PSR) & ~(1 << 31)) | (((VAL) & 1) << 31)))
+#define _PSR_Z(PSR)		(((PSR) >> 30) & 1)
+#define _SET_PSR_Z(PSR, VAL)						\
+  ((PSR) = (((PSR) & ~(1 << 30)) | (((VAL) & 1) << 30)))
+#define _PSR_C(PSR)		(((PSR) >> 29) & 1)
+#define _SET_PSR_C(PSR, VAL)						\
+  ((PSR) = (((PSR) & ~(1 << 29)) | (((VAL) & 1) << 29)))
+#define _PSR_V(PSR)		(((PSR) >> 28) & 1)
+#define _SET_PSR_V(PSR, VAL)						\
+  ((PSR) = (((PSR) & ~(1 << 28)) | (((VAL) & 1) << 28)))
+
+#define _PSR_IRQ(PSR)		(((PSR) >> 7) & 1)
+#define _PSR_FIQ(PSR)		(((PSR) >> 6) & 1)
+#define _PSR_MODE(PSR)		((PSR) & 0x1f)
+
+/* condition code values */
+#define COND_EQ		0x00
+#define COND_NE		0x01
+#define COND_CS		0x02
+#define COND_CC		0x03
+#define COND_MI		0x04
+#define COND_PL		0x05
+#define COND_VS		0x06
+#define COND_VC		0x07
+#define COND_HI		0x08
+#define COND_LS		0x09
+#define COND_GE		0x0a
+#define COND_LT		0x0b
+#define COND_GT		0x0c
+#define COND_LE		0x0d
+#define COND_AL		0x0e
+#define COND_NV		0x0f
+
+/* condition opcode accessor */
+#define COND		((inst >> 28) & 0x0f)
+
+/* test instruction condition value */
+#define COND_VALID(PSR)	(((COND) == COND_AL) || md_cond_ok(inst, PSR))
+
+/* full capability instruction condition evaluator */
+extern int md_cond_ok(md_inst_t inst, word_t psr);
+
+/* compute shifted register RM value */
+#define SHIFTRM(RMVAL, RSVAL, CFVAL)					\
+  (((SHIFT_BITS)==0) ? (RMVAL) : md_shiftrm(inst, (RMVAL), (RSVAL), (CFVAL)))
+
+/* full capability shifted register RM routine */
+extern word_t
+md_shiftrm(md_inst_t inst, word_t rmval, word_t rs_val, word_t psr);
+
+#define SHIFTC(RMVAL, RSVAL, CFVAL)					\
+  (((SHIFT_BITS)==0) ? (CFVAL) : md_shiftc(inst, (RMVAL), (RSVAL), (CFVAL)))
+
+/* full capability shifted register CF routine */
+word_t
+md_shiftc(md_inst_t inst, word_t rmval, word_t rsval, word_t cfval);
+
+/*
+ * various other helper macros/functions
+ */
+
+/* non-zero if system call is an exit() */
+#define OSF_SYS_exit			1
+#define MD_EXIT_SYSCALL(REGS)						\
+  ((REGS)->regs_R[MD_REG_V0] == OSF_SYS_exit)
+
+/* non-zero if system call is a write to stdout/stderr */
+#define OSF_SYS_write			4
+#define MD_OUTPUT_SYSCALL(REGS)						\
+  ((REGS)->regs_R[MD_REG_V0] == OSF_SYS_write				\
+   && ((REGS)->regs_R[MD_REG_A0] == /* stdout */1			\
+       || (REGS)->regs_R[MD_REG_A0] == /* stderr */2))
+
+/* returns stream of an output system call, translated to host */
+#define MD_STREAM_FILENO(REGS)		((REGS)->regs_R[MD_REG_A0])
+
+/* returns non-zero if instruction is a function call */
+#define MD_IS_CALL(OP)			((OP) == BRL)
+
+/* returns non-zero if instruction is a function return */
+/* FIXME: this will never return TRUE */
+#define MD_IS_RETURN(OP)		((OP) == MOV)
+
+/* returns non-zero if instruction is an indirect jump */
+/* FIXME: !!! */
+#define MD_IS_INDIR(OP)			((OP) == MOV)
+
+/* addressing mode probe, enums and strings */
+enum md_amode_type {
+  md_amode_imm,		/* immediate addressing mode */
+  md_amode_gp,		/* global data access through global pointer */
+  md_amode_sp,		/* stack access through stack pointer */
+  md_amode_fp,		/* stack access through frame pointer */
+  md_amode_disp,	/* (reg + const) addressing */
+  md_amode_rr,		/* (reg + reg) addressing */
+  md_amode_NUM
+};
+extern char *md_amode_str[md_amode_NUM];
+
+/* addressing mode pre-probe FSM, must see all instructions */
+#define MD_AMODE_PREPROBE(OP, FSM)		{ (FSM) = 0; }
+
+/* compute addressing mode, only for loads/stores */
+#define MD_AMODE_PROBE(AM, OP, FSM)					\
+  {									\
+    if (MD_OP_FLAGS(OP) & F_DISP)					\
+      {									\
+	if ((RB) == MD_REG_GP)						\
+	  (AM) = md_amode_gp;						\
+	else if ((RB) == MD_REG_SP)					\
+	  (AM) = md_amode_sp;						\
+	else if ((RB) == MD_REG_FP) /* && bind_to_seg(addr) == seg_stack */\
+	  (AM) = md_amode_fp;						\
+	else								\
+	  (AM) = md_amode_disp;						\
+      }									\
+    else if (MD_OP_FLAGS(OP) & F_RR)					\
+      (AM) = md_amode_rr;						\
+    else								\
+      panic("cannot decode addressing mode");				\
+  }
+
+/* addressing mode pre-probe FSM, after all loads and stores */
+#define MD_AMODE_POSTPROBE(FSM)			/* nada... */
+
+
+/*
+ * EIO package configuration/macros
+ */
+
+/* expected EIO file format */
+#define MD_EIO_FILE_FORMAT		EIO_ALPHA_FORMAT
+
+#define MD_MISC_REGS_TO_EXO(REGS)					\
+  exo_new(ec_list,							\
+	  /*icnt*/exo_new(ec_integer, (exo_integer_t)sim_num_insn),	\
+	  /*PC*/exo_new(ec_address, (exo_integer_t)(REGS)->regs_PC),	\
+	  /*NPC*/exo_new(ec_address, (exo_integer_t)(REGS)->regs_NPC),	\
+	  NULL)
+
+#if XXX
+	  /*FPCR*/exo_new(ec_integer, (exo_integer_t)(REGS)->regs_C.fpcr),
+	  /*UNIQ*/exo_new(ec_integer, (exo_integer_t)(REGS)->regs_C.uniq),
+#endif
+
+#define MD_IREG_TO_EXO(REGS, IDX)					\
+  exo_new(ec_address, (exo_integer_t)(REGS)->regs_R[IDX])
+
+#define MD_FREG_TO_EXO(REGS, IDX)					\
+  exo_new(ec_address, (exo_integer_t)(REGS)->regs_F.q[IDX])
+
+#define MD_EXO_TO_MISC_REGS(EXO, ICNT, REGS)				\
+  /* check EXO format for errors... */					\
+  if (!exo								\
+      || exo->ec != ec_list						\
+      || !exo->as_list.head						\
+      || exo->as_list.head->ec != ec_integer				\
+      || !exo->as_list.head->next					\
+      || exo->as_list.head->next->ec != ec_address			\
+      || !exo->as_list.head->next->next					\
+      || exo->as_list.head->next->next->ec != ec_address		\
+      || !exo->as_list.head->next->next->next				\
+      || exo->as_list.head->next->next->next->ec != ec_integer		\
+      || !exo->as_list.head->next->next->next->next			\
+      || exo->as_list.head->next->next->next->next->ec != ec_integer	\
+      || exo->as_list.head->next->next->next->next->next != NULL)	\
+    fatal("could not read EIO misc regs");				\
+  (ICNT) = (counter_t)exo->as_list.head->as_integer.val;		\
+  (REGS)->regs_PC = (md_addr_t)exo->as_list.head->next->as_integer.val;	\
+  (REGS)->regs_NPC =							\
+    (md_addr_t)exo->as_list.head->next->next->as_integer.val;
+
+#if XXX
+  (REGS)->regs_C.fpcr =
+    (qword_t)exo->as_list.head->next->next->next->as_integer.val;
+  (REGS)->regs_C.uniq =
+    (qword_t)exo->as_list.head->next->next->next->next->as_integer.val;
+#endif
+
+#define MD_EXO_TO_IREG(EXO, REGS, IDX)					\
+  ((REGS)->regs_R[IDX] = (qword_t)(EXO)->as_integer.val)
+
+#define MD_EXO_TO_FREG(EXO, REGS, IDX)					\
+  ((REGS)->regs_F.q[IDX] = (qword_t)(EXO)->as_integer.val)
+
+#define MD_EXO_CMP_IREG(EXO, REGS, IDX)					\
+  ((REGS)->regs_R[IDX] != (qword_t)(EXO)->as_integer.val)
+
+#define MD_FIRST_IN_REG			0
+#define MD_LAST_IN_REG			21
+
+#define MD_FIRST_OUT_REG		0
+#define MD_LAST_OUT_REG			21
+
+
+/*
+ * configure the EXO package
+ */
+
+/* EXO pointer class */
+typedef qword_t exo_address_t;
+
+/* EXO integer class, 64-bit encoding */
+typedef qword_t exo_integer_t;
+
+/* EXO floating point class, 64-bit encoding */
+typedef double exo_float_t;
+
+
+/*
+ * configure the stats package
+ */
+
+/* counter stats */
+#define stat_reg_counter		stat_reg_sqword
+#define sc_counter			sc_sqword
+#define for_counter			for_sqword
+
+/* address stats */
+#define stat_reg_addr			stat_reg_uint
+
+
+/*
+ * configure the DLite! debugger
+ */
+
+/* register bank specifier */
+enum md_reg_type {
+  rt_gpr,		/* general purpose register */
+  rt_lpr,		/* integer-precision floating pointer register */
+  rt_fpr,		/* single-precision floating pointer register */
+  rt_dpr,		/* double-precision floating pointer register */
+  rt_ctrl,		/* control register */
+  rt_PC,		/* program counter */
+  rt_NPC,		/* next program counter */
+  rt_NUM
+};
+
+/* register name specifier */
+struct md_reg_names_t {
+  char *str;			/* register name */
+  enum md_reg_type file;	/* register file */
+  int reg;			/* register index */
+};
+
+/* symbolic register names, parser is case-insensitive */
+extern struct md_reg_names_t md_reg_names[];
+
+/* returns a register name string */
+char *md_reg_name(enum md_reg_type rt, int reg);
+
+/* default register accessor object */
+struct eval_value_t;
+struct regs_t;
+char *						/* err str, NULL for no err */
+md_reg_obj(struct regs_t *regs,			/* registers to access */
+	   int is_write,			/* access type */
+	   enum md_reg_type rt,			/* reg bank to probe */
+	   int reg,				/* register number */
+	   struct eval_value_t *val);		/* input, output */
+
+/* print integer REG(S) to STREAM */
+void md_print_ireg(md_gpr_t regs, int reg, FILE *stream);
+void md_print_iregs(md_gpr_t regs, FILE *stream);
+
+/* print floating point REG(S) to STREAM */
+void md_print_fpreg(md_fpr_t regs, int reg, FILE *stream);
+void md_print_fpregs(md_fpr_t regs, FILE *stream);
+
+/* print control REG(S) to STREAM */
+void md_print_creg(md_ctrl_t regs, int reg, FILE *stream);
+void md_print_cregs(md_ctrl_t regs, FILE *stream);
+
+/* xor checksum registers */
+word_t md_xor_regs(struct regs_t *regs);
+
+
+/*
+ * configure sim-outorder specifics
+ */
+
+/* primitive operation used to compute addresses within pipeline */
+#define MD_AGEN_OP		ADDQ
+
+/* NOP operation when injected into the pipeline */
+#define MD_NOP_OP		OP_NA
+
+/* non-zero for a valid address, used to determine if speculative accesses
+   should access the DL1 data cache */
+#define MD_VALID_ADDR(ADDR)						\
+  (((ADDR) >= ld_text_base && (ADDR) < (ld_text_base + ld_text_size))	\
+   || ((ADDR) >= ld_data_base && (ADDR) < ld_brk_point)			\
+   || ((ADDR) >= (ld_stack_base - 16*1024*1024) && (ADDR) < ld_stack_base))
+
+/*
+ * configure branch predictors
+ */
+
+/* shift used to ignore branch address least significant bits, usually
+   log2(sizeof(md_inst_t)) */
+#define MD_BR_SHIFT		2	/* log2(4) */
+
+
+/*
+ * target-dependent routines
+ */
+
+/* intialize the inst decoder, this function builds the ISA decode tables */
+void md_init_decoder(void);
+
+/* ARM UOP definition */
+#define MD_MAX_FLOWLEN		64
+struct md_uop_t {
+  enum md_opcode op;		/* decoded opcode of the UOP */
+  md_inst_t inst;		/* instruction bits of UOP */
+};
+
+/* UOP flow generator, returns a small non-cyclic program implementing OP,
+   returns length of flow returned */
+int
+md_get_flow(enum md_opcode op, md_inst_t inst,
+            struct md_uop_t flow[MD_MAX_FLOWLEN]);
+
+/* disassemble a SimpleScalar instruction */
+void
+md_print_insn(md_inst_t inst,		/* instruction to disassemble */
+	      md_addr_t pc,		/* addr of inst, used for PC-rels */
+	      FILE *stream);		/* output stream */
+
+/* disassemble an Alpha instruction */
+void
+md_print_uop(enum md_opcode op,
+	     md_inst_t inst,		/* instruction to disassemble */
+	     md_addr_t pc,		/* addr of inst, used for PC-rels */
+	     FILE *stream);		/* output stream */
+
+#endif /* ARM_H */
diff --git a/sim-outorder.c b/sim-outorder.c
index 6a3a6b7..31da985 100644
--- a/sim-outorder.c
+++ b/sim-outorder.c
@@ -187,6 +187,7 @@
  *
  */
 
+/*#define JACK_DEBUGGING*/
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
@@ -507,7 +508,18 @@ static counter_t sim_num_branches = 0;
 static counter_t sim_total_branches = 0;
 
 /* cycle counter */
-static tick_t sim_cycle = 0;
+tick_t sim_cycle = 0;
+tick_t timer_next_interrupt_at = 0;
+tick_t timer_period = 0;
+int timer_return_from_interrupt_address = 0;
+int timer_do_return_from_interrupt = 0;
+enum { PENDING_FLUSH , 
+    HANDLING , NORMAL } timer_int_state ;
+
+static void do_return_from_interrupt ( bool_t swap_regs ) ;
+static void do_msr ( int reg , int pc , int new_value , md_inst_t inst ) ;
+static int get_mode_shift ( void ) ;
+static int get_current_spsr ( void ) ;
 
 /* occupancy counters */
 static counter_t IFQ_count;		/* cumulative IFQ occupancy */
@@ -3786,15 +3798,22 @@ ruu_install_odep(struct RUU_station *rs,	/* creating RUU station */
 /* general purpose register accessors, NOTE: speculative copy on write storage
    provided for fast recovery during wrong path execute (see tracer_recover()
    for details on this process */
-#define GPR(N)                  (BITMAP_SET_P(use_spec_R, R_BMAP_SZ, (N))\
-				 ? spec_regs_R[N]                       \
-				 : regs.regs_R[N])
+#define MODESHIFT(N)    \
+            ((( (N) == 14 ) || ( (N) == 13 )) ? \
+                ( (N) + get_mode_shift () ) : (N) )
+#define GPR(N)  (BITMAP_SET_P(use_spec_R, R_BMAP_SZ, (N))\
+				 ? spec_regs_R[MODESHIFT(N)]                       \
+				 : regs.regs_R[MODESHIFT(N)])
 #define SET_GPR(N,EXPR)         ((void)(((N) == 15) ? setPC++ : 0),	\
 				 spec_mode				\
-				 ? ((spec_regs_R[N] = (EXPR)),		\
+				 ? ((spec_regs_R[MODESHIFT(N)] = (EXPR)),		\
 				    BITMAP_SET(use_spec_R, R_BMAP_SZ, (N)),\
-				    spec_regs_R[N])			\
-				 : (regs.regs_R[N] = (EXPR)))
+				    spec_regs_R[MODESHIFT(N)])			\
+				 : (regs.regs_R[MODESHIFT(N)] = (EXPR)))
+#define SET_GPR_RI(N,EXPR) \
+        if ((N)==15) { SET_GPR((N),(EXPR)) ; do_return_from_interrupt(TRUE); } \
+        else { SET_GPR((N),(EXPR)) ; } 
+        
 
 #if defined(TARGET_PISA)
 
@@ -3914,6 +3933,14 @@ ruu_install_odep(struct RUU_station *rs,	/* creating RUU station */
 				   BITMAP_SET(use_spec_C,C_BMAP_SZ,/*cpsr*/0),\
 				    spec_regs_C.cpsr)			\
 				 : (regs.regs_C.cpsr = (EXPR)))
+#define SPSR    (BITMAP_SET_P(use_spec_C, C_BMAP_SZ,/*spsr*/3)\
+				 ? spec_regs_C.spsr	[get_current_spsr()]		\
+				 : regs.regs_C.spsr [get_current_spsr()])
+#define SET_SPSR(EXPR)		(spec_mode				\
+				 ? ((spec_regs_C.spsr[get_current_spsr()] = (EXPR)),	\
+				   BITMAP_SET(use_spec_C,C_BMAP_SZ,/*spsr*/3),\
+				    spec_regs_C.spsr[get_current_spsr()])			\
+				 : (regs.regs_C.spsr[get_current_spsr()] = (EXPR)))
 
 #define PSR_N			(BITMAP_SET_P(use_spec_C, C_BMAP_SZ,/*cpsr*/0)\
 				 ? _PSR_N(spec_regs_C.cpsr)		\
@@ -4791,9 +4818,10 @@ ruu_fetch(void)
       /* fetch an instruction at the next predicted fetch address */
       fetch_regs_PC = fetch_pred_PC;
 
+
       /* is this a bogus text address? (can happen on mis-spec path) */
-      if (ld_text_base <= fetch_regs_PC
-	  && fetch_regs_PC < (ld_text_base+ld_text_size)
+      if ( /* ld_text_base <= fetch_regs_PC &&  -- Interrupt vector table */
+	  fetch_regs_PC < (ld_text_base+ld_text_size)
 	  && !(fetch_regs_PC & (sizeof(md_inst_t)-1)))
 	{
 	  /* read instruction from memory */
@@ -5096,6 +5124,112 @@ int i,j;
    }
 } /* end profiling option */
 
+static void stack_info ( void )
+{
+#ifdef JACK_DEBUGGING
+    md_gpr_t r ;
+    
+    memcpy ( r , ( spec_mode ? ( spec_regs_R ) : ( regs.regs_R )) ,
+            sizeof ( md_gpr_t ) ) ;
+
+    fprintf ( stderr , "R13_usr = %x  R13_svc = %x  R13_abort = %x  "
+            "R13_undef = %x  R13_irq = %x  R13_fiq = %x\n" ,
+            r [ 13 ] , r [ MD_R13_SVC ] , r [ MD_R13_ABORT ] ,
+            r [ MD_R13_UNDEF ] , r [ MD_R13_IRQ ] , r [ MD_R13_FIQ ] ) ;
+#endif
+}
+
+static int get_mode_shift ( void )
+{
+    switch ( (PSR) & 0x1f )
+    {
+        case 0x1f :                             /* SYS mode and */
+        case 0x10 : return 0 ;                  /* user mode share registers */
+        case 0x13 : return ( MD_R13_SVC - 13 ) ;/* SVC mode */
+        case 0x12 : return ( MD_R13_IRQ - 13 ) ;/* IRQ mode */
+        case 0x11 : return ( MD_R13_FIQ - 13 ) ;/* FIQ mode */
+        case 0x17 : return ( MD_R13_ABORT - 13 ) ;/* ABORT mode */
+        default :   if ( ! spec_mode )
+                    {
+                        fprintf ( stderr , "Unknown mode %x (cpsr: %x) %d\n" , 
+                            (PSR) & 0x1f , (PSR) , spec_mode ) ;
+                    }
+                    assert ( spec_mode ) ;
+                    return ( MD_R13_UNDEF - 13 ) ;
+    }
+}
+
+static int get_current_spsr ( void )
+{
+    switch ( (PSR) & 0x1f )
+    {
+        case 0x13 : return MD_SPSR_SVC ;
+        case 0x12 : return MD_SPSR_IRQ ;
+        case 0x11 : return MD_SPSR_FIQ ;
+        case 0x17 : return MD_SPSR_ABORT ;
+        default :   return MD_SPSR_UNDEF ;
+    }
+}
+
+static void do_return_from_interrupt ( bool_t swap_regs )
+{
+#ifdef JACK_DEBUGGING
+        fprintf ( stderr , "%sreturn from int (%sswap regs), "
+                "pc = %x, lr = %x, cpsr = %x, spsr = %x, %s\n" ,
+            spec_mode ? "speculative " : "" , swap_regs ? "" : "don't " ,
+            GPR(15), GPR(14) , PSR , SPSR ,
+            ( timer_int_state == HANDLING ) ? "" : "NOT HANDLING!" ) ;
+        verbose = 1 ; 
+#endif
+        SET_PSR ( SPSR ) ; /* this macro is spec mode aware */
+        if ( ! spec_mode )
+        {
+            timer_int_state = NORMAL ;
+        }
+        stack_info () ;
+}
+
+static void do_msr ( int reg , int pc , int new_value , md_inst_t inst )
+{
+    unsigned mask = 0 ;
+    int use_spsr = ( inst & 0x400000 ) ;
+
+    mask |= ( inst & 0x10000 ) ? 0x000000ff : 0 ;
+    mask |= ( inst & 0x20000 ) ? 0x0000ff00 : 0 ;
+    mask |= ( inst & 0x40000 ) ? 0x00ff0000 : 0 ;
+    mask |= ( inst & 0x80000 ) ? 0xff000000L : 0 ;
+
+        
+    if ( use_spsr )
+    {
+        /* move to SPSR */
+#ifdef JACK_DEBUGGING
+        const char * mode ;
+
+        switch ( PSR & 0x1f )
+        {
+            case 0x11 :     mode = "fiq" ; break ;
+            case 0x12 :     mode = "irq" ; break ;
+            case 0x13 :     mode = "svc" ; break ;
+            case 0x17 :     mode = "abort" ; break ;
+            default :       mode = "undef" ; break ;
+        }
+        fprintf ( stderr , "at %x, mode %x: "
+            "SPSR_%s <-- r%d %x (inst: %x, mask: %x)\n" , 
+                pc , ( PSR & 0x1f ) , mode , reg , new_value , inst , mask ) ;
+#endif
+        SET_SPSR ( ( SPSR & ~mask ) | ( new_value & mask )) ;
+    } else { /* CPSR */
+#ifdef JACK_DEBUGGING
+        fprintf ( stderr , "at %x, mode %x: "
+            "CPSR <-- r%d %x (inst: %x, mask: %x)\n" , 
+                pc , ( PSR & 0x1f ) , reg , new_value , inst , mask ) ;
+#endif
+        SET_PSR ( ( PSR & ~mask ) | ( new_value & mask ) ) ;
+    }
+    stack_info () ;
+}
+
 /* start simulation, program loaded, processor precise state initialized */
 void
 sim_main(void)
@@ -5109,6 +5243,9 @@ sim_main(void)
   /* set up program entry state */
   regs.regs_PC = ld_prog_entry;
   regs.regs_NPC = regs.regs_PC + sizeof(md_inst_t);
+regs . regs_C . cpsr = 0xd3 ; /* supervisor mode, interrupts disabled */
+regs . regs_C . spsr [ MD_SPSR_SVC ] = regs . regs_C . cpsr ; 
+timer_int_state = NORMAL ;
 
    /* make a database for the pipetrace statistics */
   ptrace_sdb = stat_new();
@@ -5234,6 +5371,11 @@ sim_main(void)
      to eliminate this/next state synchronization and relaxation problems */
   for (;;)
     {
+        bool_t allow_dispatch ;
+
+        allow_dispatch = ( timer_int_state != PENDING_FLUSH )
+                    || in_flow ;
+
       /* RUU/LSQ sanity checks */
 #if 0
       myfprintf(stderr, "%n: RUU_num: %d, LSQ_num: %d..\n",
@@ -5280,9 +5422,14 @@ sim_main(void)
 	  ruu_issue();
 	}
 
+
+
       /* decode and dispatch new operations */
       /* ==> insert ops w/ no deps or all regs ready --> reg deps resolved */
-      ruu_dispatch();
+      if ( allow_dispatch )
+      {
+          ruu_dispatch();
+      }
 
       if (bugcompat_mode)
 	{
@@ -5295,13 +5442,90 @@ sim_main(void)
 	  ruu_issue();
 	}
 
+        if ( timer_int_state == PENDING_FLUSH )
+        {
+#ifdef JACK_DEBUGGING
+            fprintf ( stderr , "  Intt pending: " ) ;
+#endif
+            if ( RUU_num > 0 )
+            {
+#ifdef JACK_DEBUGGING
+                fprintf ( stderr , " RUU still not empty: %d\n" , RUU_num ) ;
+#endif
+            } else if ( in_flow )
+            {
+#ifdef JACK_DEBUGGING
+                fprintf ( stderr , " still in microcode flow\n" ) ;
+#endif
+            } else {
+#ifdef JACK_DEBUGGING
+                fprintf ( stderr , " RUU empty: switch register banks\n" ) ;
+
+                fprintf ( stderr , "Pred PC was 0x%x, %d, "
+                    "real PC was 0x%x, %d, next PC was 0x%x, %d\n" ,
+                    fetch_pred_PC , fetch_pred_PC ,
+                    regs . regs_PC , regs . regs_PC ,
+                    regs . regs_NPC , regs . regs_NPC ) ;
+#endif
+                {
+#ifdef JACK_DEBUGGING
+			{
+				md_inst_t j ;
+
+				MD_FETCH_INST(j, mem, 0x38);
+				fprintf ( stderr , 
+					"Int vector to addr %x.\n" , j ) ;
+			}
+#endif
+                    if ( fetch_num > 0 )
+                    {
+                        regs.regs_PC = fetch_data[fetch_head].regs_PC;
+#ifdef JACK_DEBUGGING
+                        fprintf ( stderr , "Stored PC for next: 0x%x\n" ,
+                            regs . regs_PC ) ;
+#endif
+                    } else {
+                        /* Ok... so... what's the next PC then? */
+                        regs.regs_PC = fetch_pred_PC ;
+#ifdef JACK_DEBUGGING
+                        fprintf ( stderr , "WARNING! fetch_num == 0\n" ) ;
+#endif
+                    }
+
+                    
+                    timer_int_state = HANDLING ;
+                    /* set up R14_irq - next instruction to be executed + 4 */
+                    regs . regs_R [ MD_R13_IRQ + 1 ] = regs . regs_PC + 4 ;
+                    /* set PC for interrupt */
+                    regs . regs_PC = 0x18 ;
+                    regs . regs_NPC = regs . regs_PC + 4 ;
+                    /* set up SPSR */
+                    regs . regs_C . spsr [ MD_SPSR_IRQ ] = PSR ;
+                    /* set up CPSR */
+                    SET_PSR (( PSR & ~0xff ) | 0xd2 ) ; /* interrupt mode */
+                } 
+                /* zap fetch queue too */
+                fetch_num = fetch_tail = fetch_head = 0 ;
+
+                fetch_regs_PC = regs.regs_PC; 
+                fetch_pred_PC = regs.regs_PC;
+#ifdef JACK_DEBUGGING
+                fprintf ( stderr , "PC becomes 0x%x, %d\n" ,
+                    fetch_pred_PC , fetch_pred_PC ) ;
+#endif
+            }
+        }
+
       /* call instruction fetch unit if it is not blocked */
       if (!ruu_fetch_issue_delay)
 	ruu_fetch();
       else if (ruu_fetch_issue_delay == 9999)
 	{
 	  ruu_fetch();
-	  ruu_dispatch();
+      if ( allow_dispatch )
+      {
+      ruu_dispatch();
+    }
 	  ruu_fetch();
 	  ruu_fetch_issue_delay = 0;
 	}
@@ -5328,6 +5552,30 @@ sim_main(void)
       /* go to next cycle */
       sim_cycle++;
 
+    switch ( timer_int_state )
+    {
+        case NORMAL :
+                if (( timer_next_interrupt_at > 0 )
+                && (( PSR & 0x80 ) == 0 ) 
+                                /* interrupts enabled */
+                && ( sim_cycle >= timer_next_interrupt_at ))
+                {
+                    double seconds = (( (double) ((long long) sim_cycle )) /
+                        ( (double) MD_CLOCK_CYCLES_PER_MICROSECOND *
+                            1000000.0 )) ;
+                    timer_int_state = PENDING_FLUSH ;
+                    timer_do_return_from_interrupt = 0 ;
+                    timer_next_interrupt_at = sim_cycle + timer_period ;
+                    fprintf ( stderr , "tick - %lld - %1.4f seconds\n" , 
+                            ((long long) sim_cycle ) , seconds ) ;
+		    /* verbose = 1 ; */
+                }
+                break ;
+        default :
+                break ;
+    }
+
+
       /* finish early? */
       if (max_insts && sim_num_insn >= max_insts)
 	return;
diff --git a/syscall.c b/syscall.c
deleted file mode 120000
index e13a0ee..fb4a908
--- a/syscall.c
+++ /dev/null
@@ -1 +0,0 @@
-target-arm/syscall.c
\ No newline at end of file
diff --git a/syscall.c b/syscall.c
new file mode 100644
index e13a0ee..fb4a908
--- /dev/null
+++ b/syscall.c
@@ -0,0 +1,4231 @@
+/*
+ * syscall.c - proxy system call handler routines
+ *
+ * This file is a part of the SimpleScalar tool suite written by
+ * Todd M. Austin as a part of the Multiscalar Research Project.
+ *  
+ * The tool suite is currently maintained by Doug Burger and Todd M. Austin.
+ * 
+ * Copyright (C) 1994, 1995, 1996, 1997 by Todd M. Austin
+ *
+ * This source file is distributed "as is" in the hope that it will be
+ * useful.  The tool set comes with no warranty, and no author or
+ * distributor accepts any responsibility for the consequences of its
+ * use. 
+ * 
+ * Everyone is granted permission to copy, modify and redistribute
+ * this tool set under the following conditions:
+ * 
+ *    This source code is distributed for non-commercial use only. 
+ *    Please contact the maintainer for restrictions applying to 
+ *    commercial use.
+ *
+ *    Permission is granted to anyone to make or distribute copies
+ *    of this source code, either as received or modified, in any
+ *    medium, provided that all copyright notices, permission and
+ *    nonwarranty notices are preserved, and that the distributor
+ *    grants the recipient permission for further redistribution as
+ *    permitted by this document.
+ *
+ *    Permission is granted to distribute this file in compiled
+ *    or executable form under the same conditions that apply for
+ *    source code, provided that either:
+ *
+ *    A. it is accompanied by the corresponding machine-readable
+ *       source code,
+ *    B. it is accompanied by a written offer, with no time limit,
+ *       to give anyone a machine-readable copy of the corresponding
+ *       source code in return for reimbursement of the cost of
+ *       distribution.  This written offer must permit verbatim
+ *       duplication by anyone, or
+ *    C. it is distributed by someone who received only the
+ *       executable form, and is accompanied by a copy of the
+ *       written offer of source code that they received concurrently.
+ *
+ * In other words, you are welcome to use, share and improve this
+ * source file.  You are forbidden to forbid anyone else to use, share
+ * and improve what you give them.
+ *
+ * INTERNET: dburger@cs.wisc.edu
+ * US Mail:  1210 W. Dayton Street, Madison, WI 53706
+ *
+ * $Id: syscall.c,v 1.1.1.1 2000/11/29 14:53:54 cu-cs Exp $
+ *
+ * $Log: syscall.c,v $
+ * Revision 1.1.1.1  2000/11/29 14:53:54  cu-cs
+ * Grand unification of arm sources.
+ *
+ *
+ * Revision 1.1.2.11  2000/11/08 20:30:23  kimns
+ * Files necessary to compile Wattch Model ....
+ * SimpleScalar/ARM
+ *
+ * Revision 1.1.2.10  2000/09/11 18:30:24  chriswea
+ * finished CODING sockets for arm linux.. now debug
+ *
+ * Revision 1.1.2.9  2000/09/11 01:13:42  chriswea
+ * added code for socket,bind and connect and stubs for other socket
+ * functions under socketcall
+ *
+ * Revision 1.1.2.8  2000/09/10 22:14:38  chriswea
+ * now compiles without the min_syscall_mode flag
+ * syscall not in arm linux are still present but
+ * an && 0 is added to allow it to compile all
+ * socket calls are now unsupported because they is
+ * actually only socketcall system call that in
+ * turn calls the correct socket function
+ *
+ * Revision 1.1.2.7  2000/08/31 03:34:56  taustin
+ * Fixed a bug in open() flag translation (messed up value for O_TRUNC).
+ *
+ * Revision 1.1.2.6  2000/08/29 14:18:28  taustin
+ * Fixed word and qword size fp register accesses.
+ * Addes time() and times() system call support (for Perl).
+ *
+ * Revision 1.1.2.5  2000/08/28 15:44:47  taustin
+ * Added O_ASYNC open() support.
+ *
+ * Revision 1.1.2.4  2000/08/25 18:40:16  taustin
+ * Started implementing funky PC semantics for ARM.
+ *
+ * Revision 1.1.2.3  2000/08/02 09:44:58  taustin
+ * Fixed stat system call emulation.
+ *
+ * Revision 1.1.1.1  2000/05/26 15:22:27  taustin
+ * SimpleScalar Tool Set
+ *
+ *
+ * Revision 1.6  1999/12/31 19:00:40  taustin
+ * quad_t naming conflicts removed
+ * cross-endian execution support added (w/ limited syscall support)
+ * extensive extensions to the Alpha OSF system call model
+ *
+ * Revision 1.5  1999/12/13 18:59:54  taustin
+ * cross endian execution support added
+ *
+ * Revision 1.4  1999/03/08 06:40:09  taustin
+ * added SVR4 host support
+ *
+ * Revision 1.3  1998/09/03 22:20:59  taustin
+ * iov_len field in osf_iov fixed (was qword_t changed to word_t)
+ * added portable padding to osf_iov type definition
+ * fixed sigprocmask implementation (from Klauser)
+ * usleep_thread() implementation added
+ *
+ * Revision 1.2  1998/08/31 17:19:44  taustin
+ * ported to MS VC++
+ * added FIONREAD ioctl() support
+ * added support for socket(), select(), writev(), readv(), setregid()
+ *     setreuid(), connect(), setsockopt(), getsockname(), getpeername(),
+ *     setgid(), setuid(), getpriority(), setpriority(), shutdown(), poll()
+ * change invalid system call from panic() to fatal()
+ *
+ * Revision 1.1  1998/08/27 16:54:53  taustin
+ * Initial revision
+ *
+ * Revision 1.1  1998/05/06  01:08:39  calder
+ * Initial revision
+ *
+ * Revision 1.5  1997/04/16  22:12:17  taustin
+ * added Ultrix host support
+ *
+ * Revision 1.4  1997/03/11  01:37:37  taustin
+ * updated copyright
+ * long/int tweaks made for ALPHA target support
+ * syscall structures are now more portable across platforms
+ * various target supports added
+ *
+ * Revision 1.3  1996/12/27  15:56:09  taustin
+ * updated comments
+ * removed system prototypes
+ *
+ * Revision 1.1  1996/12/05  18:52:32  taustin
+ * Initial revision
+ *
+ *
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+
+/* only enable a minimal set of systen call proxies if on limited
+   hosts or if in cross endian live execution mode */
+#ifndef MIN_SYSCALL_MODE
+#if defined(_MSC_VER) || defined(__CYGWIN32__) || defined(MD_CROSS_ENDIAN)
+#define MIN_SYSCALL_MODE
+#endif
+#endif /* !MIN_SYSCALL_MODE */
+
+/* live execution only support on same-endian hosts... */
+#ifdef _MSC_VER
+#include <io.h>
+#else /* !_MSC_VER */
+#include <unistd.h>
+#endif
+#include <fcntl.h>
+#include <sys/types.h>
+#ifndef _MSC_VER
+#include <sys/param.h>
+#endif
+#include <errno.h>
+#include <time.h>
+#ifndef _MSC_VER
+#include <sys/time.h>
+#endif
+#ifndef _MSC_VER
+#include <sys/resource.h>
+#endif
+#include <signal.h>
+#ifndef _MSC_VER
+#include <sys/file.h>
+#endif
+#include <sys/stat.h>
+#ifndef _MSC_VER
+#include <sys/uio.h>
+#endif
+#include <setjmp.h>
+#ifndef _MSC_VER
+#include <sys/times.h>
+#endif
+#include <limits.h>
+#ifndef _MSC_VER
+#include <sys/ioctl.h>
+#endif
+#if defined(linux)
+#include <utime.h>
+#include <dirent.h>
+#include <sys/vfs.h>
+#endif
+#if defined(_AIX)
+#include <sys/statfs.h>
+#else /* !_AIX */
+#ifndef _MSC_VER
+#include <sys/mount.h>
+#endif
+#endif /* !_AIX */
+#if !defined(linux) && !defined(sparc) && !defined(hpux) && !defined(__hpux) && !defined(__CYGWIN32__) && !defined(ultrix)
+#ifndef _MSC_VER
+#include <sys/select.h>
+#endif
+#endif
+#ifdef linux
+#include <sgtty.h>
+#include <netinet/tcp.h>
+#include <netinet/udp.h>
+#include <netinet/in.h>
+#endif /* linux */
+
+#if defined(__svr4__)
+#include <sys/dirent.h>
+#include <sys/filio.h>
+#elif defined(__osf__)
+#include <dirent.h>
+/* -- For some weird reason, getdirentries() is not declared in any
+ * -- header file under /usr/include on the Alpha boxen that I tried
+ * -- SS-Alpha on. But the function exists in the libraries.
+ */
+int getdirentries(int fd, char *buf, int nbytes, long *basep);
+#endif
+
+#if defined(__svr4__) || defined(__osf__)
+#include <sys/statvfs.h>
+#define statfs statvfs
+#include <sys/time.h>
+#include <utime.h>
+#include <sgtty.h>
+#include <netinet/in.h>
+#include <netinet/tcp.h>
+#endif
+
+#if defined(sparc) && defined(__unix__)
+#if defined(__svr4__) || defined(__USLC__)
+#include <dirent.h>
+#else
+#include <sys/dir.h>
+#endif
+
+/* dorks */
+#undef NL0
+#undef NL1
+#undef CR0
+#undef CR1
+#undef CR2
+#undef CR3
+#undef TAB0
+#undef TAB1
+#undef TAB2
+#undef XTABS
+#undef BS0
+#undef BS1
+#undef FF0
+#undef FF1
+#undef ECHO
+#undef NOFLSH
+#undef TOSTOP
+#undef FLUSHO
+#undef PENDIN
+#endif
+
+#if defined(hpux) || defined(__hpux)
+#undef CR0
+#endif
+
+#ifdef __FreeBSD__
+#include <sys/ioctl_compat.h>
+#else
+#ifndef _MSC_VER
+#include <termio.h>
+#endif
+#endif
+
+#if defined(hpux) || defined(__hpux)
+/* et tu, dorks! */
+#undef HUPCL
+#undef ECHO
+#undef B50
+#undef B75
+#undef B110
+#undef B134
+#undef B150
+#undef B200
+#undef B300
+#undef B600
+#undef B1200
+#undef B1800
+#undef B2400
+#undef B4800
+#undef B9600
+#undef B19200
+#undef B38400
+#undef NL0
+#undef NL1
+#undef CR0
+#undef CR1
+#undef CR2
+#undef CR3
+#undef TAB0
+#undef TAB1
+#undef BS0
+#undef BS1
+#undef FF0
+#undef FF1
+#undef EXTA
+#undef EXTB
+#undef B900
+#undef B3600
+#undef B7200
+#undef XTABS
+#include <sgtty.h>
+#include <utime.h>
+#endif
+
+#ifdef __CYGWIN32__
+#include <sys/unistd.h>
+#include <sys/vfs.h>
+#endif
+
+#include <sys/socket.h>
+#include <sys/poll.h>
+
+#ifdef _MSC_VER
+#define access		_access
+#define chmod		_chmod
+#define chdir		_chdir
+#define unlink		_unlink
+#define open		_open
+#define creat		_creat
+#define pipe		_pipe
+#define dup		_dup
+#define dup2		_dup2
+#define stat		_stat
+#define fstat		_fstat
+#define lseek		_lseek
+#define read		_read
+#define write		_write
+#define close		_close
+#define getpid		_getpid
+#define utime		_utime
+#include <sys/utime.h>
+#endif /* _MSC_VER */
+
+#include "host.h"
+#include "misc.h"
+#include "machine.h"
+#include "regs.h"
+#include "memory.h"
+#include "loader.h"
+#include "sim.h"
+#include "endian.h"
+#include "eio.h"
+#include "syscall.h"
+
+/* Syscall numbers
+	Got these numbers from /kernel/arch/arm/kernel/calls.S 
+	Need to sync with kernel/include/asm-arm/unistd.h (Done!)
+	Some system calls seem to be out of kernel V2.4 */
+
+#define ARM_SYS_ni_syscall	0
+#define ARM_SYS_exit			1
+#define ARM_SYS_fork			2
+#define ARM_SYS_read			3
+#define ARM_SYS_write		4
+#define ARM_SYS_open			5
+#define ARM_SYS_close		6
+#define ARM_SYS_waitpid		7
+#define ARM_SYS_creat		8
+#define ARM_SYS_link			9
+#define ARM_SYS_unlink		10
+#define ARM_SYS_execve		11
+#define ARM_SYS_chdir		12
+#define ARM_SYS_time			13
+#define ARM_SYS_mknod		14
+#define ARM_SYS_chmod		15
+#define ARM_SYS_lchown16	16
+/* 17 and 18 not defined???  in Kernel v2.4 */
+#define ARM_SYS_break		17
+
+/*#define ARM_SYS_oldstat		18*/
+
+#define ARM_SYS_lseek		19
+#define ARM_SYS_getpid		20
+#define ARM_SYS_mount		21
+#define ARM_SYS_umount		22
+#define ARM_SYS_setuid		23
+#define ARM_SYS_getuid		24
+#define ARM_SYS_stime		25
+#define ARM_SYS_ptrace		26
+#define ARM_SYS_alarm		27
+
+#define ARM_SYS_pause		29
+#define ARM_SYS_utime		30
+#define ARM_SYS_stty			31
+#define ARM_SYS_gtty			32
+#define ARM_SYS_access		33
+#define ARM_SYS_nice			34
+#define ARM_SYS_ftime		35
+#define ARM_SYS_sync			36
+#define ARM_SYS_kill			37
+#define ARM_SYS_rename		38
+#define ARM_SYS_mkdir		39
+#define ARM_SYS_rmdir		40
+#define ARM_SYS_dup			41
+#define ARM_SYS_pipe			42
+#define ARM_SYS_times		43
+#define ARM_SYS_prof			44
+#define ARM_SYS_brk			45
+#define ARM_SYS_setgid		46
+#define ARM_SYS_getgid		47
+#define ARM_SYS_signal		48
+#define ARM_SYS_geteuid		49
+#define ARM_SYS_getegid		50
+#define ARM_SYS_acct			51
+#define ARM_SYS_umount2		52
+#define ARM_SYS_lock			53
+#define ARM_SYS_ioctl		54
+#define ARM_SYS_fcntl		55
+#define ARM_SYS_mpx			56
+#define ARM_SYS_setpgid		57
+#define ARM_SYS_ulimit		58
+
+#define ARM_SYS_umask		60
+#define ARM_SYS_chroot		61
+#define ARM_SYS_ustat		62
+#define ARM_SYS_dup2			63
+#define ARM_SYS_getppid		64
+#define ARM_SYS_getpgrp		65
+#define ARM_SYS_setsid		66
+#define ARM_SYS_sigaction	67
+#define ARM_SYS_sgetmask	68
+#define ARM_SYS_ssetmask	69
+#define ARM_SYS_setreuid	70
+#define ARM_SYS_setregid	71
+#define ARM_SYS_sigsuspend	72
+#define ARM_SYS_sigpending	73
+#define ARM_SYS_sethostname	74
+#define ARM_SYS_setrlimit	75
+#define ARM_SYS_getrlimit	76
+#define ARM_SYS_getrusage	77
+#define ARM_SYS_gettimeofday	78
+#define ARM_SYS_settimeofday	79
+#define ARM_SYS_getgroups16	80
+#define ARM_SYS_setgroups16	81
+#define ARM_SYS_oldselect	82
+#define ARM_SYS_symlink		83
+
+#define ARM_SYS_readlink	85
+#define ARM_SYS_uselib		86
+#define ARM_SYS_swapon		87
+#define ARM_SYS_reboot		88
+#define ARM_SYS_readdir		89
+#define ARM_SYS_old_mmap	90
+#define ARM_SYS_munmap		91
+#define ARM_SYS_truncate	92
+#define ARM_SYS_ftruncate	93
+#define ARM_SYS_fchmod		94
+#define ARM_SYS_fchown16	95
+#define ARM_SYS_getpriority	96
+#define ARM_SYS_setpriority	97
+#define ARM_SYS_profil		98
+#define ARM_SYS_statfs		99
+#define ARM_SYS_fstatfs		100
+#define ARM_SYS_ioperm		101
+#define ARM_SYS_socketcall	102
+#define ARM_SYS_syslog		103
+#define ARM_SYS_setitimer	104
+#define ARM_SYS_getitimer	105
+#define ARM_SYS_newstat		106
+#define ARM_SYS_newlstat	107
+#define ARM_SYS_newfstat	108
+
+
+#define ARM_SYS_vhangup		111
+#define ARM_SYS_idle			112
+#define ARM_SYS_syscall		113
+#define ARM_SYS_wait4		114
+#define ARM_SYS_swapoff		115
+#define ARM_SYS_sysinfo		116
+#define ARM_SYS_ipc			117
+#define ARM_SYS_fsync		118
+#define ARM_SYS_sigreturn	119
+#define ARM_SYS_clone		120
+#define ARM_SYS_setdomainname	121
+#define ARM_SYS_newuname	122
+#define ARM_SYS_adjtimex	124
+#define ARM_SYS_mprotect	125
+#define ARM_SYS_sigprocmask	126
+#define ARM_SYS_create_module	127
+#define ARM_SYS_init_module	128
+#define ARM_SYS_delete_module	129
+#define ARM_SYS_get_kernel_syms	130
+#define ARM_SYS_quotactl	131
+#define ARM_SYS_getpgid		132
+#define ARM_SYS_fchdir		133
+#define ARM_SYS_bdflush		134
+#define ARM_SYS_sysfs		135
+#define ARM_SYS_personality	136
+#define ARM_SYS_afs_syscall	137
+#define ARM_SYS_setfsuid	138
+#define ARM_SYS_setfsgid	139
+#define ARM_SYS_llseek		140
+#define ARM_SYS_getdents	141
+#define ARM_SYS_select		142
+#define ARM_SYS_flock		143
+#define ARM_SYS_msync		144
+#define ARM_SYS_readv		145
+#define ARM_SYS_writev		146
+#define ARM_SYS_getsid		147
+#define ARM_SYS_fdatasync	148
+#define ARM_SYS_sysctl		149
+#define ARM_SYS_mlock		150
+#define ARM_SYS_munlock		151
+#define ARM_SYS_mlockall	152
+#define ARM_SYS_munlockall	153
+#define ARM_SYS_sched_setparam	154
+#define ARM_SYS_sched_getparam	155
+#define ARM_SYS_sched_setscheduler	156
+#define ARM_SYS_sched_getscheduler	157
+#define ARM_SYS_sched_yield	158
+#define ARM_SYS_sched_get_priority_max	159
+#define ARM_SYS_sched_get_priority_min	160
+#define ARM_SYS_sched_rr_get_interval	161
+#define ARM_SYS_nanosleep	162
+#define ARM_SYS_mremap		163
+#define ARM_SYS_setresuid16	164
+#define ARM_SYS_getresuid16	165
+#define ARM_SYS_vm86				166
+#define ARM_SYS_query_module	167
+#define ARM_SYS_poll			168
+#define ARM_SYS_nfsservctl	169
+#define ARM_SYS_setresgid16	170
+#define ARM_SYS_getresgid16	171
+#define ARM_SYS_prctl		172
+#define ARM_SYS_rt_sigreturn	173
+#define ARM_SYS_rt_sigaction	174
+#define ARM_SYS_rt_sigprocmask	175
+#define ARM_SYS_rt_sigpending	176
+#define ARM_SYS_rt_sigtimedwait	177
+#define ARM_SYS_rt_sigqueueinfo	178
+#define ARM_SYS_rt_sigsuspend	179
+#define ARM_SYS_pread		180
+#define ARM_SYS_pwrite		181
+#define ARM_SYS_chown16		182
+#define ARM_SYS_getcwd		183
+#define ARM_SYS_capget		184
+#define ARM_SYS_capset		185
+#define ARM_SYS_sigaltstack	186
+#define ARM_SYS_sendfile	187
+
+
+#define ARM_SYS_vfork		190
+/* #define ARM_SYS_getrlimit	191 */
+#define ARM_SYS_mmap2		192
+#define ARM_SYS_truncate64	193
+#define ARM_SYS_ftruncate64	194
+#define ARM_SYS_stat64		195
+#define ARM_SYS_lstat64		196
+#define ARM_SYS_fstat64		197
+#define ARM_SYS_lchown32	198
+#define ARM_SYS_getuid32	199
+#define ARM_SYS_getgid32	200
+#define ARM_SYS_geteuid32	201
+#define ARM_SYS_getegid32	202
+#define ARM_SYS_setreuid32	203
+#define ARM_SYS_setregid32	204
+#define ARM_SYS_getgroups32	205
+#define ARM_SYS_setgroups32	206
+#define ARM_SYS_fchown32	207
+#define ARM_SYS_setresuid32	208
+#define ARM_SYS_getresuid32	209
+#define ARM_SYS_setresgid32	210
+#define ARM_SYS_getresgid32	211
+#define ARM_SYS_chown32		212
+#define ARM_SYS_setuid32	213
+#define ARM_SYS_setgid32	214
+#define ARM_SYS_setfsuid32	215
+#define ARM_SYS_setfsgid32	216
+
+
+/* These are the numbers for the socket function on a socketcall */
+/* these were defined at /usr/include/sys/socketcall.h */
+#define ARM_SYS_SOCKET      1
+#define ARM_SYS_BIND        2
+#define ARM_SYS_CONNECT     3
+#define ARM_SYS_LISTEN      4
+#define ARM_SYS_ACCEPT      5
+#define ARM_SYS_GETSOCKNAME 6
+#define ARM_SYS_GETPEERNAME 7
+#define ARM_SYS_SOCKETPAIR  8
+#define ARM_SYS_SEND        9
+#define ARM_SYS_RECV        10
+#define ARM_SYS_SENDTO      11
+#define ARM_SYS_RECVFROM    12
+#define ARM_SYS_SHUTDOWN    13
+#define ARM_SYS_SETSOCKOPT  14
+#define ARM_SYS_GETSOCKOPT  15
+#define ARM_SYS_SENDMSG     16
+#define ARM_SYS_RECVMSG     17
+
+/* translate system call arguments */
+struct xlate_table_t
+{
+  int target_val;
+  int host_val;
+};
+
+int
+xlate_arg(int target_val, struct xlate_table_t *map, int map_sz, char *name)
+{
+  int i;
+
+  for (i=0; i < map_sz; i++)
+    {
+      if (target_val == map[i].target_val)
+	return map[i].host_val;
+    }
+
+  /* not found, issue warning and return target_val */
+  warn("could not translate argument for `%s': %d", name, target_val);
+  return target_val;
+}
+
+/* internal system call buffer size, used primarily for file name arguments,
+   argument larger than this will be truncated */
+#define MAXBUFSIZE 		1024
+
+/* total bytes to copy from a valid pointer argument for ioctl() calls,
+   syscall.c does not decode ioctl() calls to determine the size of the
+   arguments that reside in memory, instead, the ioctl() proxy simply copies
+   NUM_IOCTL_BYTES bytes from the pointer argument to host memory */
+#define NUM_IOCTL_BYTES		128
+
+/* OSF ioctl() requests */
+#define OSF_TIOCGETP		0x40067408
+#define OSF_FIONREAD		0x4004667f
+
+/* target stat() buffer definition, the host stat buffer format is
+   automagically mapped to/from this format in syscall.c */
+struct  linux_statbuf
+{
+  half_t linux_st_dev;
+  half_t pad0;			/* to match Linux padding... */
+  word_t linux_st_ino;
+  half_t linux_st_mode;
+  half_t linux_st_nlink;
+  half_t linux_st_uid;
+  half_t linux_st_gid;
+  half_t linux_st_rdev;
+  half_t pad1;
+  word_t linux_st_size;
+  word_t linux_st_blksize;
+  word_t linux_st_blocks;
+  word_t linux_st_atime;
+  word_t pad2;
+  word_t linux_st_mtime;
+  word_t pad3;
+  word_t linux_st_ctime;
+  word_t pad4;
+  word_t pad5;
+  word_t pad6;
+};
+
+struct osf_sgttyb {
+  byte_t sg_ispeed;	/* input speed */
+  byte_t sg_ospeed;	/* output speed */
+  byte_t sg_erase;	/* erase character */
+  byte_t sg_kill;	/* kill character */
+  shalf_t sg_flags;	/* mode flags */
+};
+
+#define OSF_NSIG		32
+
+#define OSF_SIG_BLOCK		1
+#define OSF_SIG_UNBLOCK		2
+#define OSF_SIG_SETMASK		3
+
+struct osf_sigcontext {
+  qword_t sc_onstack;              /* sigstack state to restore */
+  qword_t sc_mask;                 /* signal mask to restore */
+  qword_t sc_pc;                   /* pc at time of signal */
+  qword_t sc_ps;                   /* psl to retore */
+  qword_t sc_regs[32];             /* processor regs 0 to 31 */
+  qword_t sc_ownedfp;              /* fp has been used */
+  qword_t sc_fpregs[32];           /* fp regs 0 to 31 */
+  qword_t sc_fpcr;                 /* floating point control register */
+  qword_t sc_fp_control;           /* software fpcr */
+};
+
+struct osf_statfs {
+  shalf_t f_type;		/* type of filesystem (see below) */
+  shalf_t f_flags;		/* copy of mount flags */
+  word_t f_fsize;		/* fundamental filesystem block size */
+  word_t f_bsize;		/* optimal transfer block size */
+  word_t f_blocks;		/* total data blocks in file system, */
+  /* note: may not represent fs size. */
+  word_t f_bfree;		/* free blocks in fs */
+  word_t f_bavail;		/* free blocks avail to non-su */
+  word_t f_files;		/* total file nodes in file system */
+  word_t f_ffree;		/* free file nodes in fs */
+  qword_t f_fsid;		/* file system id */
+  word_t f_spare[9];		/* spare for later */
+};
+
+struct osf_timeval
+{
+  sword_t osf_tv_sec;		/* seconds */
+  sword_t osf_tv_usec;		/* microseconds */
+};
+
+struct osf_timezone
+{
+  sword_t osf_tz_minuteswest;	/* minutes west of Greenwich */
+  sword_t osf_tz_dsttime;	/* type of dst correction */
+};
+
+/* target getrusage() buffer definition, the host stat buffer format is
+   automagically mapped to/from this format in syscall.c */
+struct osf_rusage
+{
+  struct osf_timeval osf_ru_utime;
+  struct osf_timeval osf_ru_stime;
+  sword_t osf_ru_maxrss;
+  sword_t osf_ru_ixrss;
+  sword_t osf_ru_idrss;
+  sword_t osf_ru_isrss;
+  sword_t osf_ru_minflt;
+  sword_t osf_ru_majflt;
+  sword_t osf_ru_nswap;
+  sword_t osf_ru_inblock;
+  sword_t osf_ru_oublock;
+  sword_t osf_ru_msgsnd;
+  sword_t osf_ru_msgrcv;
+  sword_t osf_ru_nsignals;
+  sword_t osf_ru_nvcsw;
+  sword_t osf_ru_nivcsw;
+};
+
+struct osf_rlimit
+{
+  qword_t osf_rlim_cur;		/* current (soft) limit */
+  qword_t osf_rlim_max;		/* maximum value for rlim_cur */
+};
+
+struct osf_sockaddr
+{
+  half_t sa_family;		/* address family, AF_xxx */
+  byte_t sa_data[24];		/* 14 bytes of protocol address */
+};
+
+struct osf_iovec
+{
+  md_addr_t iov_base;		/* starting address */
+  word_t iov_len;		/* length in bytes */
+  word_t pad;
+};
+
+#if 0
+/* returns size of DIRENT structure */
+#define OSF_DIRENT_SZ(STR)						\
+  (sizeof(word_t) + 2*sizeof(half_t) + strlen(STR) + 1)
+#endif
+
+struct osf_dirent
+{
+  word_t d_ino;			/* file number of entry */
+  half_t d_reclen;		/* length of this record */
+  half_t d_namlen;		/* length of string in d_name */
+  char d_name[256];		/* DUMMY NAME LENGTH */
+				/* the real maximum length is */
+				/* returned by pathconf() */
+                                /* At this time, this MUST */
+                                /* be 256 -- the kernel */
+                                /* requires it */
+};
+
+/* open(2) flags for Alpha/AXP OSF target, syscall.c automagically maps
+   between these codes to/from host open(2) flags */
+#define LINUX_O_RDONLY		00
+#define LINUX_O_WRONLY		01
+#define LINUX_O_RDWR		02
+#define LINUX_O_CREAT		0100
+#define LINUX_O_EXCL		0200
+#define LINUX_O_NOCTTY		0400
+#define LINUX_O_TRUNC		01000
+#define LINUX_O_APPEND		02000
+#define LINUX_O_NONBLOCK	04000
+#define LINUX_O_SYNC		010000
+#define LINUX_O_ASYNC		020000
+
+/* open(2) flags translation table for SimpleScalar target */
+struct {
+  int linux_flag;
+  int local_flag;
+} linux_flag_table[] = {
+  /* target flag */	/* host flag */
+#ifdef _MSC_VER
+  { LINUX_O_RDONLY,	_O_RDONLY },
+  { LINUX_O_WRONLY,	_O_WRONLY },
+  { LINUX_O_RDWR,	_O_RDWR },
+  { LINUX_O_APPEND,	_O_APPEND },
+  { LINUX_O_CREAT,	_O_CREAT },
+  { LINUX_O_TRUNC,	_O_TRUNC },
+  { LINUX_O_EXCL,	_O_EXCL },
+#ifdef _O_NONBLOCK
+  { LINUX_O_NONBLOCK,	_O_NONBLOCK },
+#endif
+#ifdef _O_NOCTTY
+  { LINUX_O_NOCTTY,	_O_NOCTTY },
+#endif
+#ifdef _O_SYNC
+  { LINUX_O_SYNC,	_O_SYNC },
+#endif
+#else /* !_MSC_VER */
+  { LINUX_O_RDONLY,	O_RDONLY },
+  { LINUX_O_WRONLY,	O_WRONLY },
+  { LINUX_O_RDWR,	O_RDWR },
+  { LINUX_O_APPEND,	O_APPEND },
+  { LINUX_O_CREAT,	O_CREAT },
+  { LINUX_O_TRUNC,	O_TRUNC },
+  { LINUX_O_EXCL,	O_EXCL },
+  { LINUX_O_NONBLOCK,	O_NONBLOCK },
+  { LINUX_O_NOCTTY,	O_NOCTTY },
+#ifdef O_SYNC
+  { LINUX_O_SYNC,		O_SYNC },
+#endif
+#ifdef O_ASYNC
+  { LINUX_O_ASYNC,	O_ASYNC },
+#endif
+#endif /* _MSC_VER */
+};
+#define LINUX_NFLAGS	(sizeof(linux_flag_table)/sizeof(linux_flag_table[0]))
+
+qword_t sigmask = 0;
+
+qword_t sigaction_array[OSF_NSIG] =
+ {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
+
+/* setsockopt option names */
+#define OSF_SO_DEBUG		0x0001
+#define OSF_SO_ACCEPTCONN	0x0002
+#define OSF_SO_REUSEADDR	0x0004
+#define OSF_SO_KEEPALIVE	0x0008
+#define OSF_SO_DONTROUTE	0x0010
+#define OSF_SO_BROADCAST	0x0020
+#define OSF_SO_USELOOPBACK	0x0040
+#define OSF_SO_LINGER		0x0080
+#define OSF_SO_OOBINLINE	0x0100
+#define OSF_SO_REUSEPORT	0x0200
+
+struct xlate_table_t sockopt_map[] =
+{
+  { OSF_SO_DEBUG,	SO_DEBUG },
+#ifdef SO_ACCEPTCONN
+  { OSF_SO_ACCEPTCONN,	SO_ACCEPTCONN },
+#endif
+  { OSF_SO_REUSEADDR,	SO_REUSEADDR },
+  { OSF_SO_KEEPALIVE,	SO_KEEPALIVE },
+  { OSF_SO_DONTROUTE,	SO_DONTROUTE },
+  { OSF_SO_BROADCAST,	SO_BROADCAST },
+#ifdef SO_USELOOPBACK
+  { OSF_SO_USELOOPBACK,	SO_USELOOPBACK },
+#endif
+  { OSF_SO_LINGER,	SO_LINGER },
+  { OSF_SO_OOBINLINE,	SO_OOBINLINE },
+#ifdef SO_REUSEPORT
+  { OSF_SO_REUSEPORT,	SO_REUSEPORT }
+#endif
+};
+
+/* setsockopt TCP options */
+#define OSF_TCP_NODELAY		0x01 /* don't delay send to coalesce packets */
+#define OSF_TCP_MAXSEG		0x02 /* maximum segment size */
+#define OSF_TCP_RPTR2RXT	0x03 /* set repeat count for R2 RXT timer */
+#define OSF_TCP_KEEPIDLE	0x04 /* secs before initial keepalive probe */
+#define OSF_TCP_KEEPINTVL	0x05 /* seconds between keepalive probes */
+#define OSF_TCP_KEEPCNT		0x06 /* num of keepalive probes before drop */
+#define OSF_TCP_KEEPINIT	0x07 /* initial connect timeout (seconds) */
+#define OSF_TCP_PUSH		0x08 /* set push bit in outbnd data packets */
+#define OSF_TCP_NODELACK	0x09 /* don't delay send to coalesce packets */
+
+struct xlate_table_t tcpopt_map[] =
+{
+  { OSF_TCP_NODELAY,	TCP_NODELAY },
+  { OSF_TCP_MAXSEG,	TCP_MAXSEG },
+#ifdef TCP_RPTR2RXT
+  { OSF_TCP_RPTR2RXT,	TCP_RPTR2RXT },
+#endif
+#ifdef TCP_KEEPIDLE
+  { OSF_TCP_KEEPIDLE,	TCP_KEEPIDLE },
+#endif
+#ifdef TCP_KEEPINTVL
+  { OSF_TCP_KEEPINTVL,	TCP_KEEPINTVL },
+#endif
+#ifdef TCP_KEEPCNT
+  { OSF_TCP_KEEPCNT,	TCP_KEEPCNT },
+#endif
+#ifdef TCP_KEEPINIT
+  { OSF_TCP_KEEPINIT,	TCP_KEEPINIT },
+#endif
+#ifdef TCP_PUSH
+  { OSF_TCP_PUSH,	TCP_PUSH },
+#endif
+#ifdef TCP_NODELACK
+  { OSF_TCP_NODELACK,	TCP_NODELACK }
+#endif
+};
+
+/* setsockopt level names */
+#define OSF_SOL_SOCKET		0xffff	/* options for socket level */
+#define OSF_SOL_IP		0	/* dummy for IP */
+#define OSF_SOL_TCP		6	/* tcp */
+#define OSF_SOL_UDP		17	/* user datagram protocol */
+
+struct xlate_table_t socklevel_map[] =
+{
+#if defined(__svr4__) || defined(__osf__)
+  { OSF_SOL_SOCKET,	SOL_SOCKET },
+  { OSF_SOL_IP,		IPPROTO_IP },
+  { OSF_SOL_TCP,	IPPROTO_TCP },
+  { OSF_SOL_UDP,	IPPROTO_UDP }
+#else
+  { OSF_SOL_SOCKET,	SOL_SOCKET },
+  { OSF_SOL_IP,		SOL_IP },
+  { OSF_SOL_TCP,	SOL_TCP },
+  { OSF_SOL_UDP,	SOL_UDP }
+#endif
+};
+
+/* socket() address families */
+#define OSF_AF_UNSPEC		0
+#define OSF_AF_UNIX		1	/* Unix domain sockets */
+#define OSF_AF_INET		2	/* internet IP protocol */
+#define OSF_AF_IMPLINK		3	/* arpanet imp addresses */
+#define OSF_AF_PUP		4	/* pup protocols: e.g. BSP */
+#define OSF_AF_CHAOS		5	/* mit CHAOS protocols */
+#define OSF_AF_NS		6	/* XEROX NS protocols */
+#define OSF_AF_ISO		7	/* ISO protocols */
+
+struct xlate_table_t family_map[] =
+{
+  { OSF_AF_UNSPEC,	AF_UNSPEC },
+  { OSF_AF_UNIX,	AF_UNIX },
+  { OSF_AF_INET,	AF_INET },
+#ifdef AF_IMPLINK
+  { OSF_AF_IMPLINK,	AF_IMPLINK },
+#endif
+#ifdef AF_PUP
+  { OSF_AF_PUP,		AF_PUP },
+#endif
+#ifdef AF_CHAOS
+  { OSF_AF_CHAOS,	AF_CHAOS },
+#endif
+#ifdef AF_NS
+  { OSF_AF_NS,		AF_NS },
+#endif
+#ifdef AF_ISO
+  { OSF_AF_ISO,		AF_ISO }
+#endif
+};
+
+/* socket() socket types */
+#define OSF_SOCK_STREAM		1	/* stream (connection) socket */
+#define OSF_SOCK_DGRAM		2	/* datagram (conn.less) socket */
+#define OSF_SOCK_RAW		3	/* raw socket */
+#define OSF_SOCK_RDM		4	/* reliably-delivered message */
+#define OSF_SOCK_SEQPACKET	5	/* sequential packet socket */
+
+struct xlate_table_t socktype_map[] =
+{
+  { OSF_SOCK_STREAM,	SOCK_STREAM },
+  { OSF_SOCK_DGRAM,	SOCK_DGRAM },
+  { OSF_SOCK_RAW,	SOCK_RAW },
+  { OSF_SOCK_RDM,	SOCK_RDM },
+  { OSF_SOCK_SEQPACKET,	SOCK_SEQPACKET }
+};
+
+/* OSF table() call. Right now, we only support TBL_SYSINFO queries */
+#define OSF_TBL_SYSINFO		12
+struct osf_tbl_sysinfo 
+{
+  long si_user;		/* user time */
+  long si_nice;		/* nice time */
+  long si_sys;		/* system time */
+  long si_idle;		/* idle time */
+  long si_hz;
+  long si_phz;
+  long si_boottime;	/* boot time in seconds */
+  long wait;		/* wait time */
+};
+
+struct linux_tms
+{
+  word_t tms_utime;		/* user CPU time */
+  word_t tms_stime;		/* system CPU time */
+
+  word_t tms_cutime;		/* user CPU time of dead children */
+  word_t tms_cstime;		/* system CPU time of dead children */
+
+};
+
+extern tick_t timer_next_interrupt_at ;
+extern tick_t timer_period ;
+extern tick_t sim_cycle ;
+
+/* ARM SYSTEM CALL CONVENTIONS
+
+	System call conventions as taken from unistd.h of arm architecture
+	Depending on the call type r0, r1, r2, r3, r4 will contain the arguments
+	of the system call.
+	The actual system call number is found out using the link register after 
+	an swi call is made. How this is done is shown in 
+	kernel/arch/arm/kernel/entry-common.S file
+	We need to decode the instruction to find out the system call number.
+	
+	Return value is returned in register 0. If the return value is between -1
+	and -125 inclusive then there's an error.
+*/
+
+/* syscall proxy handler, architect registers and memory are assumed to be
+   precise when this function is called, register and memory are updated with
+   the results of the sustem call */
+
+void
+sys_syscall(struct regs_t *regs,	/* registers to access */
+	    mem_access_fn mem_fn,	/* generic memory accessor */
+	    struct mem_t *mem,		/* memory space to access */
+	    md_inst_t inst,		/* system call inst */
+	    int traceable)		/* traceable system call? */
+{
+  /* Figure out the system call number from the swi instruction
+	  Last 24 bits gives us this number */
+
+  qword_t syscode = inst & 0x000fffff;
+
+
+  /* first, check if an EIO trace is being consumed... */
+  /* Left from Alpha code should be the same in ARM though */
+
+  if (traceable && sim_eio_fd != NULL)
+    {
+      eio_read_trace(sim_eio_fd, sim_num_insn, regs, mem_fn, mem, inst);
+
+#if XXX
+      /* kludge fix for sigreturn(), it modifies all registers */
+      if (syscode == ARM_SYS_sigreturn)
+	{
+	  int i;
+	  struct osf_sigcontext sc;
+	  md_addr_t sc_addr = regs->regs_R[MD_REG_R0]; /* change the register name to r0 (first arg) */
+
+	  mem_bcopy(mem_fn, mem, Read, sc_addr, 
+		    &sc, sizeof(struct osf_sigcontext));
+	  regs->regs_NPC = sc.sc_pc;
+	  for (i=0; i < 32; ++i)
+	    regs->regs_R[i] = sc.sc_regs[i];
+	  for (i=0; i < 32; ++i)
+	    regs->regs_F.q[i] = sc.sc_fpregs[i];
+	  regs->regs_C.fpcr = sc.sc_fpcr;
+	}
+#endif
+
+      /* fini... */
+      return;
+    }
+
+  /* no, OK execute the live system call... */
+
+  switch (syscode)
+    {
+    case ARM_SYS_exit:
+      /* exit jumps to the target set in main() */
+      longjmp(sim_exit_buf,
+	      /* exitcode + fudge */(regs->regs_R[MD_REG_R0] & 0xff) + 1);
+      break;
+
+    case ARM_SYS_personality:
+      regs->regs_R[MD_REG_R0] = 0x1000000;
+      break;
+
+    case ARM_SYS_old_mmap:
+      {
+	static md_addr_t mmap_brk_point = 0xd0000000;
+
+	if (/* flags */regs->regs_R[MD_REG_R3] !=
+	    0x22 /* (MAP_PRIVATE|MAP_ANONYMOUS) */)
+	  fatal("non-anonymous MMAP's not yet implemented");
+
+	regs->regs_R[MD_REG_R0] = mmap_brk_point;
+	mmap_brk_point += regs->regs_R[MD_REG_R1];
+
+	if (verbose)
+	  fprintf(stderr, "MMAP: 0x%08x -> 0x%08x, %d bytes...\n",
+		  regs->regs_R[MD_REG_R0], mmap_brk_point,
+		  regs->regs_R[MD_REG_R1]);
+      }
+      break;
+
+    case ARM_SYS_read:
+      {
+	char *buf;
+	int error_return;
+
+	/* allocate same-sized input buffer in host memory */
+	if (!(buf =
+	      (char *)calloc(/*nbytes*/regs->regs_R[MD_REG_R2], sizeof(char))))
+	  fatal("out of memory in SYS_read");
+
+	/* read data from file */
+	do {
+	  /*nread*/error_return =
+	    read(/*fd*/regs->regs_R[MD_REG_R0], buf,
+	         /*nbytes*/regs->regs_R[MD_REG_R2]);
+	    if (error_return <= -1 && error_return >= -125)
+		 regs->regs_R[MD_REG_R0] = -errno;
+	    else
+		 regs->regs_R[MD_REG_R0] = error_return;
+	} while (/*nread*/error_return == -1
+	         && errno == EAGAIN);
+
+	/* check for error condition, is not necessary to do this but lets keep it for now 
+	   it is taken care of in the do-while loop */
+	
+	if (error_return != -1) {
+		regs->regs_R[MD_REG_R0] = error_return;
+	} /* no error */
+	else {
+	  	regs->regs_R[MD_REG_R0] = -(errno); /* negative of the error number is returned in r0 */
+	}
+
+	/* copy results back into host memory */
+	mem_bcopy(mem_fn, mem, Write,
+		  /*buf*/regs->regs_R[MD_REG_R1], buf, /*nread*/regs->regs_R[MD_REG_R2]);
+
+	/* done with input buffer */
+	free(buf);
+      }
+      break;
+
+    case ARM_SYS_write:
+      {
+	char *buf;
+	int error_return;
+
+	/* allocate same-sized output buffer in host memory */
+	if (!(buf =
+	      (char *)calloc(/*nbytes*/regs->regs_R[MD_REG_R2], sizeof(char))))
+	  fatal("out of memory in SYS_write");
+
+	/* copy inputs into host memory */
+	mem_bcopy(mem_fn, mem, Read, /*buf*/regs->regs_R[MD_REG_R1], buf,
+		  /*nbytes*/regs->regs_R[MD_REG_R2]);
+
+	/* write data to file */
+	if (sim_progfd && MD_OUTPUT_SYSCALL(regs))
+	  {
+	    /* redirect program output to file */
+
+	    /*nwritten*/error_return =
+	      fwrite(buf, 1, /*nbytes*/regs->regs_R[MD_REG_R2], sim_progfd);
+	  }
+	else
+	  {
+	    /* perform program output request */
+	    do {
+	      /*nwritten*/error_return =
+	        write(/*fd*/regs->regs_R[MD_REG_R0],
+		      buf, /*nbytes*/regs->regs_R[MD_REG_R2]);
+	    } while (/*nwritten*/error_return == -1 && errno == EAGAIN);
+	  }
+
+	/* check for an error condition */
+	if (error_return <= -1)
+	  regs->regs_R[MD_REG_R0] = -errno;
+	else
+	  regs->regs_R[MD_REG_R0] = error_return;
+
+	/* done with output buffer */
+	free(buf);
+      }
+      break;
+
+      /* I can't find this system call in linux ?? ctw */
+#if !defined(MIN_SYSCALL_MODE) && 0
+      /* ADDED BY CALDER 10/27/99 */
+    case ARM_SYS_getdomainname:
+      /* get program scheduling priority */
+      {
+	char *buf;
+	int error_return;
+
+	buf = malloc(/* len */(size_t)regs->regs_R[MD_REG_R1]);
+	if (!buf)
+	  fatal("out of virtual memory in gethostname()");
+
+	/* result */error_return =
+	  getdomainname(/* name */buf,
+		      /* len */(size_t)regs->regs_R[MD_REG_R1]);
+
+	/* copy string back to simulated memory */
+	mem_bcopy(mem_fn, mem, Write,
+		  /* name */regs->regs_R[MD_REG_R0],
+		  buf, /* len */regs->regs_R[MD_REG_R1]);
+      }
+
+	/* check for an error condition */
+	if (error_return != -1) {
+		regs->regs_R[MD_REG_R0] = error_return;
+	} /* no error */
+	else {
+	  	regs->regs_R[MD_REG_R0] = -(errno); /* negative of the error number is returned in r0 */
+	}
+
+	}
+      break;
+#endif
+
+#if !defined(MIN_SYSCALL_MODE)
+      /* ADDED BY CALDER 10/27/99 */
+    case ARM_SYS_flock:
+      /* get flock() information on the file */
+      {
+	int error_return;
+	
+	error_return =
+	  flock(/*fd*/(int)regs->regs_R[MD_REG_R0],
+		/*cmd*/(int)regs->regs_R[MD_REG_R1]);
+
+	/* check for an error condition */
+	if (error_return != -1) {
+		regs->regs_R[MD_REG_R0] = error_return;
+	} /* no error */
+	else {
+	  	regs->regs_R[MD_REG_R0] = -(errno); /* negative of the error number is returned in r0 */
+	}
+	}
+      
+      break;
+#endif
+
+      /*-------------------------------Is there a bind in arm-linux??----------------------*/
+#if !defined(MIN_SYSCALL_MODE) && 0
+      /* ADDED BY CALDER 10/27/99 */
+    case OSF_SYS_bind:
+      {
+	const struct sockaddr a_sock;
+
+	mem_bcopy(mem_fn, mem, Read, /* serv_addr */regs->regs_R[MD_REG_A1],
+		  &a_sock, /* addrlen */(int)regs->regs_R[MD_REG_A2]);
+
+      regs->regs_R[MD_REG_V0] =
+	bind((int) regs->regs_R[MD_REG_A0],
+	     &a_sock,(int) regs->regs_R[MD_REG_A2]);
+
+      /* check for an error condition */
+      if (regs->regs_R[MD_REG_V0] != (qword_t)-1)
+	regs->regs_R[MD_REG_A3] = 0;
+      else /* got an error, return details */
+	{
+	  regs->regs_R[MD_REG_A3] = -1;
+	  regs->regs_R[MD_REG_V0] = errno;
+	}
+      }
+      break;
+#endif
+      /*----------------------------------------------------------------------------------------*/
+
+      /*-------------------------------Is there a sendto in arm-linux??----------------------*/
+#if !defined(MIN_SYSCALL_MODE) && 0
+      /* ADDED BY CALDER 10/27/99 */
+    case OSF_SYS_sendto:
+      {
+	char *buf = NULL;
+	struct sockaddr d_sock;
+	int buf_len = 0;
+
+	buf_len = regs->regs_R[MD_REG_A2];
+
+	if (buf_len > 0)
+	  buf = (char *) malloc(buf_len*sizeof(char));
+
+	mem_bcopy(mem_fn, mem, Read, /* serv_addr */regs->regs_R[MD_REG_A1],
+		  buf, /* addrlen */(int)regs->regs_R[MD_REG_A2]);
+
+	if (regs->regs_R[MD_REG_A5] > 0) 
+	  mem_bcopy(mem_fn, mem, Read, regs->regs_R[MD_REG_A4],
+		    &d_sock, (int)regs->regs_R[MD_REG_A5]);
+
+	regs->regs_R[MD_REG_V0] =
+	  sendto((int) regs->regs_R[MD_REG_A0],
+		 buf,(int) regs->regs_R[MD_REG_A2],
+		 (int) regs->regs_R[MD_REG_A3],
+		 &d_sock,(int) regs->regs_R[MD_REG_A5]);
+
+	mem_bcopy(mem_fn, mem, Write, /* serv_addr */regs->regs_R[MD_REG_A1],
+		  buf, /* addrlen */(int)regs->regs_R[MD_REG_A2]);
+
+	/* maybe copy back whole size of sockaddr */
+	if (regs->regs_R[MD_REG_A5] > 0)
+	  mem_bcopy(mem_fn, mem, Write, regs->regs_R[MD_REG_A4],
+		    &d_sock, (int)regs->regs_R[MD_REG_A5]);
+
+	/* check for an error condition */
+	if (regs->regs_R[MD_REG_V0] != (qword_t)-1)
+	  regs->regs_R[MD_REG_A3] = 0;
+	else /* got an error, return details */
+	  {
+	    regs->regs_R[MD_REG_A3] = -1;
+	    regs->regs_R[MD_REG_V0] = errno;
+	  }
+
+	if (buf != NULL) 
+	  free(buf);
+      }
+      break;
+#endif
+      /*----------------------------------------------------------------------------------------*/
+
+      /*-------------------------------Is there a recvfrom in arm-linux??----------------------*/
+#if !defined(MIN_SYSCALL_MODE) && 0
+      /* ADDED BY CALDER 10/27/99 */
+    case OSF_SYS_old_recvfrom:
+    case OSF_SYS_recvfrom:
+      {
+	int addr_len;
+	char *buf;
+	struct sockaddr *a_sock;
+      
+	buf = (char *) malloc(sizeof(char)*regs->regs_R[MD_REG_A2]);
+
+	mem_bcopy(mem_fn, mem, Read, /* serv_addr */regs->regs_R[MD_REG_A1],
+		  buf, /* addrlen */(int)regs->regs_R[MD_REG_A2]);
+
+	mem_bcopy(mem_fn, mem, Read, /* serv_addr */regs->regs_R[MD_REG_A5],
+		  &addr_len, sizeof(int));
+
+	a_sock = (struct sockaddr *)malloc(addr_len);
+
+	mem_bcopy(mem_fn, mem, Read, regs->regs_R[MD_REG_A4],
+		  a_sock, addr_len);
+
+	regs->regs_R[MD_REG_V0] =
+	  recvfrom((int) regs->regs_R[MD_REG_A0],
+		   buf,(int) regs->regs_R[MD_REG_A2],
+		   (int) regs->regs_R[MD_REG_A3], a_sock,&addr_len);
+
+	mem_bcopy(mem_fn, mem, Write, regs->regs_R[MD_REG_A1],
+		  buf, (int) regs->regs_R[MD_REG_V0]);
+
+	mem_bcopy(mem_fn, mem, Write, /* serv_addr */regs->regs_R[MD_REG_A5],
+		  &addr_len, sizeof(int));
+
+	mem_bcopy(mem_fn, mem, Write, regs->regs_R[MD_REG_A4],
+		  a_sock, addr_len);
+
+	/* check for an error condition */
+	if (regs->regs_R[MD_REG_V0] != (qword_t)-1)
+	  regs->regs_R[MD_REG_A3] = 0;
+	else /* got an error, return details */
+	  {
+	    regs->regs_R[MD_REG_A3] = -1;
+	    regs->regs_R[MD_REG_V0] = errno;
+	  }
+	if (buf != NULL)
+	  free(buf);
+      }
+      break;
+#endif
+      /*----------------------------------------------------------------------------------------*/
+
+    case ARM_SYS_open:
+      {
+	char buf[MAXBUFSIZE];
+	unsigned int i;
+	int error_return;
+	int linux_flags = regs->regs_R[MD_REG_R1], local_flags = 0;
+
+	/* Need to make sure if these flags are the same in ARM */
+	/* translate open(2) flags */
+	for (i=0; i < LINUX_NFLAGS; i++)
+	  {
+	    if (linux_flags & linux_flag_table[i].linux_flag)
+	      {
+		linux_flags &= ~linux_flag_table[i].linux_flag;
+		local_flags |= linux_flag_table[i].local_flag;
+	      }
+	  }
+	/* any target flags left? */
+	if (linux_flags != 0)
+	  fatal("syscall: open: cannot decode flags: 0x%08x", linux_flags);
+
+	/* copy filename to host memory */
+	mem_strcpy(mem_fn, mem, Read, /*fname*/regs->regs_R[MD_REG_R0], buf);
+
+	/* open the file */
+#ifdef __CYGWIN32__
+	/*fd*/error_return =
+	  open(buf, local_flags|O_BINARY, /*mode*/regs->regs_R[MD_REG_R2]);
+#else /* !__CYGWIN32__ */
+	/*fd*/error_return =
+	  open(buf, local_flags, /*mode*/regs->regs_R[MD_REG_R2]);
+#endif /* __CYGWIN32__ */
+	
+	/* check for an error condition */
+	if (error_return != -1) {
+		regs->regs_R[MD_REG_R0] = error_return;
+	  } /* no error */
+	else {
+	  	regs->regs_R[MD_REG_R0] = -(errno); /* negative of the error number is returned in r0 */
+	  }
+      }
+      break;
+
+    case ARM_SYS_close:
+	{
+	int error_return;
+      /* don't close stdin, stdout, or stderr as this messes up sim logs */
+      if (/*fd*/regs->regs_R[MD_REG_R0] == 0
+	  || /*fd*/regs->regs_R[MD_REG_R0] == 1
+	  || /*fd*/regs->regs_R[MD_REG_R0] == 2)
+	{
+	  regs->regs_R[MD_REG_R0] = 0;
+	  break;
+	}
+
+      /* close the file */
+      error_return = close(/*fd*/regs->regs_R[MD_REG_R0]);
+
+      /* check for an error condition */
+      if (error_return != -1) {
+		regs->regs_R[MD_REG_R0] = error_return;
+	} /* no error */
+	else {
+	  	regs->regs_R[MD_REG_R0] = -(errno); /* negative of the error number is returned in r0 */
+	}
+	}
+      break;
+
+#if 0
+    case ARM_SYS_creat:
+      {
+	char buf[MAXBUFSIZE];
+	int error_return;
+
+	/* copy filename to host memory */
+	mem_strcpy(mem_fn, Read, /*fname*/regs->regs_R[MD_REG_R0], buf);
+
+	/* create the file */
+	/*fd*/error_return =
+	  creat(buf, /*mode*/regs->regs_R[MD_REG_R1]);
+
+	/* check for an error condition */
+	if (error_return != -1) {
+		regs->regs_R[MD_REG_R0] = error_return;
+	  } /* no error */
+	else {
+	  	regs->regs_R[MD_REG_R0] = -(errno); /* negative of the error number is returned in r0 */
+	  }
+      }
+      break;
+#endif
+
+    case ARM_SYS_unlink:
+      {
+	char buf[MAXBUFSIZE];
+	int error_return;
+
+	/* copy filename to host memory */
+	mem_strcpy(mem_fn, mem, Read, /*fname*/regs->regs_R[MD_REG_R0], buf);
+
+	/* delete the file */
+	/*result*/error_return = unlink(buf);
+
+	/* check for an error condition */
+	if (error_return != -1) {
+		regs->regs_R[MD_REG_R0] = error_return;
+	  } /* no error */
+	else {
+	  	regs->regs_R[MD_REG_R0] = -(errno); /* negative of the error number is returned in r0 */
+	  }
+      }
+      break;
+
+    case ARM_SYS_chdir:
+      {
+	char buf[MAXBUFSIZE];
+	int error_return;
+
+	/* copy filename to host memory */
+	mem_strcpy(mem_fn, mem, Read, /*fname*/regs->regs_R[MD_REG_R0], buf);
+
+	/* change the working directory */
+	/*result*/error_return = chdir(buf);
+
+	/* check for an error condition */
+	if (error_return != -1) {
+		regs->regs_R[MD_REG_R0] = error_return; /* normal return value */
+	  } /* no error */
+	else {
+	  	regs->regs_R[MD_REG_R0] = -(errno); /* negative of the error number is returned in r0 */
+	  }
+      }
+      break;
+
+    case ARM_SYS_time:
+      {
+	time_t intime = regs->regs_R[MD_REG_R0];
+	word_t tval = (word_t)time(&intime);
+	fprintf(stderr, "time(%d) = %d\n", (int)intime, tval);
+
+	/* check for an error condition */
+	if (tval != (word_t)-1)
+	  regs->regs_R[MD_REG_R0] = tval; /* normal return value */
+	else
+	  regs->regs_R[MD_REG_R0] = -(errno); /* negative of the errnum */
+      }
+      break;
+
+    case ARM_SYS_chmod:
+      {
+	char buf[MAXBUFSIZE];
+
+	/* copy filename to host memory */
+	mem_strcpy(mem_fn, mem, Read, /*fname*/regs->regs_R[MD_REG_R0], buf);
+
+	/* chmod the file */
+	/*result*/regs->regs_R[MD_REG_R0] =
+	  chmod(buf, /*mode*/regs->regs_R[MD_REG_A1]);
+
+	/* check for an error condition */
+	if (regs->regs_R[MD_REG_R0] == (qword_t)-1)
+	  /* got an error, return details */
+	    regs->regs_R[MD_REG_R0] = -errno;
+	  
+      }
+      break;
+
+#if XXX
+    case ARM_SYS_chown:
+#ifdef _MSC_VER
+      warn("syscall chown() not yet implemented for MSC...");
+      regs->regs_R[MD_REG_R0] = 0;
+#else /* !_MSC_VER */
+      {
+	char buf[MAXBUFSIZE];
+
+	/* copy filename to host memory */
+	mem_strcpy(mem_fn, mem,Read, /*fname*/regs->regs_R[MD_REG_R0], buf);
+
+	/* chown the file */
+	/*result*/regs->regs_R[MD_REG_R0] =
+	  chown(buf, /*owner*/regs->regs_R[MD_REG_R1],
+		/*group*/regs->regs_R[MD_REG_R2]);
+
+	/* check for an error condition */
+	if (regs->regs_R[MD_REG_R0] == (qword_t)-1)
+	  /* got an error, return details */
+	    regs->regs_R[MD_REG_R0] = -errno;
+      }
+#endif /* _MSC_VER */
+      break;
+#endif
+
+    case ARM_SYS_brk:
+      {
+	md_addr_t addr = regs->regs_R[MD_REG_R0];
+
+	if (verbose)
+	  myfprintf(stderr, "SYS_sbrk: addr: 0x%08p\n", addr);
+
+	if (addr != 0)
+	  {
+	    ld_brk_point = addr;
+	    regs->regs_R[MD_REG_V0] = ld_brk_point;
+
+	    /* check whether heap area has merged with stack area */
+	    if (addr >= regs->regs_R[MD_REG_SP])
+	      {
+		/* out of address space, indicate error */
+		regs->regs_R[MD_REG_R0] = -ENOMEM;
+	      }
+	  }
+	else /* just return break point */
+	  regs->regs_R[MD_REG_V0] = ld_brk_point;
+
+	if (verbose)
+	  myfprintf(stderr, "ld_brk_point: 0x%08p\n", ld_brk_point);
+      }
+      break;
+
+      /*-------------------------------Is there a obreak in arm-linux??----------------------*/
+#if XXX
+    case OSF_SYS_obreak:
+      {
+        md_addr_t addr;
+
+        /* round the new heap pointer to the its page boundary */
+#if 0
+        addr = ROUND_UP(/*base*/regs->regs_R[MD_REG_A0], MD_PAGE_SIZE);
+#endif
+        addr = /*base*/regs->regs_R[MD_REG_A0];
+
+	if (verbose)
+	  myfprintf(stderr, "SYS_obreak: addr: 0x%012p\n", addr);
+
+	ld_brk_point = addr;
+	regs->regs_R[MD_REG_V0] = ld_brk_point;
+	regs->regs_R[MD_REG_A3] = 0;
+
+	if (verbose)
+	  myfprintf(stderr, "ld_brk_point: 0x%012p\n", ld_brk_point);
+      }
+      break;
+      /*----------------------------------------------------------------------------------------*/
+#endif
+
+    case ARM_SYS_lseek:
+      /* seek into file */
+      regs->regs_R[MD_REG_R0] =
+	lseek(/*fd*/regs->regs_R[MD_REG_R0],
+	      /*off*/regs->regs_R[MD_REG_R1], /*dir*/regs->regs_R[MD_REG_R2]);
+
+      /* check for an error condition */
+      if (regs->regs_R[MD_REG_R0] == (qword_t)-1)
+	  /* got an error, return details */
+	    regs->regs_R[MD_REG_R0] = -errno;
+
+      break;
+
+    case ARM_SYS_getpid:
+      /* get the simulator process id */
+      /*result*/regs->regs_R[MD_REG_R0] = debugging ? 2500 : getpid();
+
+      /* check for an error condition */
+      if (regs->regs_R[MD_REG_R0] == (qword_t)-1)
+	  /* got an error, return details */
+	    regs->regs_R[MD_REG_R0] = -errno;
+
+      break;
+
+    case ARM_SYS_getuid:
+#ifdef _MSC_VER
+      warn("syscall getuid() not yet implemented for MSC...");
+      regs->regs_R[MD_REG_R0] = 0;
+#else /* !_MSC_VER */
+      /* get current user id */
+      /*first result*/regs->regs_R[MD_REG_R0] = getuid();
+
+      /* check for an error condition */
+      if (regs->regs_R[MD_REG_R0] == (qword_t)-1)
+	  /* got an error, return details */
+	    regs->regs_R[MD_REG_R0] = -errno;
+#endif /* _MSC_VER */
+      break;
+
+
+    case ARM_SYS_geteuid:
+#ifdef _MSC_VER
+      warn("syscall getuid() not yet implemented for MSC...");
+      regs->regs_R[MD_REG_R0] = 0;
+#else /* !_MSC_VER */
+      /* get current user id */
+      /*first result*/regs->regs_R[MD_REG_R0] = geteuid();
+
+      /* check for an error condition */
+      if (regs->regs_R[MD_REG_R0] == (qword_t)-1)
+	  /* got an error, return details */
+	    regs->regs_R[MD_REG_R0] = -errno;
+#endif /* _MSC_VER */
+      break;
+
+
+    case ARM_SYS_access:
+      {
+	char buf[MAXBUFSIZE];
+
+	/* copy filename to host memory */
+	mem_strcpy(mem_fn, mem, Read, /*fName*/regs->regs_R[MD_REG_R0], buf);
+
+	/* check access on the file */
+	/*result*/regs->regs_R[MD_REG_R0] =
+	  access(buf, /*mode*/regs->regs_R[MD_REG_R1]);
+
+	/* check for an error condition */
+	if (regs->regs_R[MD_REG_R0] == (qword_t)-1)
+	  /* got an error, return details */
+	    regs->regs_R[MD_REG_R0] = -errno;
+      }
+      break;
+
+    case ARM_SYS_newstat:
+    case ARM_SYS_newlstat:
+      {
+	char buf[MAXBUFSIZE];
+	struct linux_statbuf linux_sbuf;
+	struct stat sbuf;
+
+	/* copy filename to host memory */
+	mem_strcpy(mem_fn, mem, Read, /*fName*/regs->regs_R[MD_REG_R0], buf);
+
+	/* stat() the file */
+	if (syscode == ARM_SYS_newstat)
+	  /*result*/regs->regs_R[MD_REG_R0] = stat(buf, &sbuf);
+	else /* syscode == ARM_SYS_lstat */
+	  /*result*/regs->regs_R[MD_REG_R0] = lstat(buf, &sbuf);
+
+	/* check for an error condition */
+	if (regs->regs_R[MD_REG_R0] == (qword_t)-1)
+	  /* got an error, return details */
+	    regs->regs_R[MD_REG_R0] = -errno;
+
+	/* translate from host stat structure to target format */
+	linux_sbuf.linux_st_dev = MD_SWAPH(sbuf.st_dev);
+	linux_sbuf.linux_st_ino = MD_SWAPW(sbuf.st_ino);
+	linux_sbuf.linux_st_mode = MD_SWAPH(sbuf.st_mode);
+	linux_sbuf.linux_st_nlink = MD_SWAPH(sbuf.st_nlink);
+	linux_sbuf.linux_st_uid = MD_SWAPH(sbuf.st_uid);
+	linux_sbuf.linux_st_gid = MD_SWAPH(sbuf.st_gid);
+	linux_sbuf.linux_st_rdev = MD_SWAPH(sbuf.st_rdev);
+	linux_sbuf.linux_st_size = MD_SWAPW(sbuf.st_size);
+	linux_sbuf.linux_st_blksize = MD_SWAPW(sbuf.st_blksize);
+	linux_sbuf.linux_st_blocks = MD_SWAPW(sbuf.st_blocks);
+	linux_sbuf.linux_st_atime = MD_SWAPW(sbuf.st_atime);
+	linux_sbuf.linux_st_mtime = MD_SWAPW(sbuf.st_mtime);
+	linux_sbuf.linux_st_ctime = MD_SWAPW(sbuf.st_ctime);
+
+	/* copy stat() results to simulator memory */
+	mem_bcopy(mem_fn, mem, Write, /*sbuf*/regs->regs_R[MD_REG_R1],
+		  &linux_sbuf, sizeof(struct linux_statbuf));
+      }
+      break;
+
+#if XXX
+    case OSF_SYS_dup:
+      /* dup() the file descriptor */
+      /*fd*/regs->regs_R[MD_REG_R0] = dup(/*fd*/regs->regs_R[MD_REG_R0]);
+
+      /* check for an error condition */
+      if (regs->regs_R[MD_REG_R0] == (qword_t)-1)
+	  /* got an error, return details */
+	    regs->regs_R[MD_REG_R0] = -errno;
+
+      break;
+#endif
+
+#if 0
+    case ARM_SYS_pipe: /* Be careful with this one */
+      {
+	int fd[2];
+
+	/* copy pipe descriptors to host memory */;
+	mem_bcopy(mem_fn, mem, Read, /*fd's*/regs->regs_R[MD_REG_R0],
+		  fd, sizeof(fd));
+
+	/* create a pipe */
+	/*result*/regs->regs_R[MD_REG_R7] = pipe(fd);
+
+	/* copy descriptor results to result registers */
+	/*pipe1*/regs->regs_R[MD_REG_R0] = fd[0];
+	/*pipe 2*/regs->regs_R[MD_REG_R1] = fd[1];
+
+	/* check for an error condition */
+	 if (regs->regs_R[MD_REG_R7] == (qword_t)-1)
+	  /* got an error, return details */
+	    regs->regs_R[MD_REG_R0] = -errno;
+	  }
+      }
+      break;
+#endif
+
+    case ARM_SYS_times:
+      {
+	struct linux_tms tms;
+	struct tms ltms;
+	clock_t result;
+
+	result = times(&ltms);
+	tms.tms_utime = ltms.tms_utime;
+	tms.tms_stime = ltms.tms_stime;
+	tms.tms_cutime = ltms.tms_cutime;
+	tms.tms_cstime = ltms.tms_cstime;
+
+	mem_bcopy(mem_fn, mem, Write,
+		  /* buf */regs->regs_R[MD_REG_R0],
+		  &tms, sizeof(struct linux_tms));
+
+	if (result != (qword_t)-1)
+	  regs->regs_R[MD_REG_R0] = result;
+	else
+	  regs->regs_R[MD_REG_R0] = -errno; /* got an error, return details */
+      }
+      break;
+
+    case ARM_SYS_getgid:
+#ifdef _MSC_VER
+      warn("syscall getgid() not yet implemented for MSC...");
+      regs->regs_R[MD_REG_R0] = 0;
+#else /* !_MSC_VER */
+      /* get current group id */
+      /*first result*/regs->regs_R[MD_REG_R0] = getgid();
+
+      /* check for an error condition */
+      if (regs->regs_R[MD_REG_R0] == (qword_t)-1)
+	  /* got an error, return details */
+	    regs->regs_R[MD_REG_R0] = -errno;
+#endif /* _MSC_VER */
+      break;
+
+    case ARM_SYS_getegid:
+#ifdef _MSC_VER
+      warn("syscall getgid() not yet implemented for MSC...");
+      regs->regs_R[MD_REG_R0] = 0;
+#else /* !_MSC_VER */
+      /* get current group id */
+      /*first result*/regs->regs_R[MD_REG_R0] = getegid();
+
+      /* check for an error condition */
+      if (regs->regs_R[MD_REG_R0] == (qword_t)-1)
+	  /* got an error, return details */
+	    regs->regs_R[MD_REG_R0] = -errno;
+#endif /* _MSC_VER */
+      break;
+
+    case ARM_SYS_ioctl:
+      switch (/* req */regs->regs_R[MD_REG_R1])
+	{
+#if !defined(TIOCGETP) && defined(linux)
+	case OSF_TIOCGETP: /* <Out,TIOCGETP,6> */
+	  {
+	    struct termios lbuf;
+	    struct osf_sgttyb buf;
+
+	    /* result */regs->regs_R[MD_REG_R0] =
+			  tcgetattr(/* fd */(int)regs->regs_R[MD_REG_R0],
+				    &lbuf);
+
+	    /* translate results */
+	    buf.sg_ispeed = lbuf.c_ispeed;
+	    buf.sg_ospeed = lbuf.c_ospeed;
+	    buf.sg_erase = lbuf.c_cc[VERASE];
+	    buf.sg_kill = lbuf.c_cc[VKILL];
+	    buf.sg_flags = 0;	/* FIXME: this is wrong... */
+
+	    mem_bcopy(mem_fn, mem, Write,
+		      /* buf */regs->regs_R[MD_REG_R2], &buf,
+		      sizeof(struct osf_sgttyb));
+
+	    if (regs->regs_R[MD_REG_R0] == (qword_t)-1)
+	  /* got an error, return details */
+		    regs->regs_R[MD_REG_R0] = -errno;
+
+	  }
+	  break;
+#endif
+#ifdef TIOCGETP
+	case OSF_TIOCGETP: /* <Out,TIOCGETP,6> */
+	  {
+	    struct sgttyb lbuf;
+	    struct osf_sgttyb buf;
+
+	    /* result */regs->regs_R[MD_REG_R0] =
+	      ioctl(/* fd */(int)regs->regs_R[MD_REG_R0],
+		    /* req */TIOCGETP,
+		    &lbuf);
+
+	    /* translate results */
+	    buf.sg_ispeed = lbuf.sg_ispeed;
+	    buf.sg_ospeed = lbuf.sg_ospeed;
+	    buf.sg_erase = lbuf.sg_erase;
+	    buf.sg_kill = lbuf.sg_kill;
+	    buf.sg_flags = lbuf.sg_flags;
+	    mem_bcopy(mem_fn, mem, Write,
+		      /* buf */regs->regs_R[MD_REG_R2], &buf,
+		      sizeof(struct osf_sgttyb));
+
+	    if (regs->regs_R[MD_REG_R0] == (qword_t)-1)
+	  /* got an error, return details */
+	    regs->regs_R[MD_REG_R0] = -errno;
+	  }
+	  break;
+#endif
+#ifdef FIONREAD
+	case OSF_FIONREAD:
+	  {
+	    int nread;
+
+	    /* result */regs->regs_R[MD_REG_R0] =
+	      ioctl(/* fd */(int)regs->regs_R[MD_REG_R0],
+		    /* req */FIONREAD,
+		    /* arg */&nread);
+
+	    mem_bcopy(mem_fn, mem, Write,
+		      /* arg */regs->regs_R[MD_REG_R2],
+		      &nread, sizeof(nread));
+
+	    if (regs->regs_R[MD_REG_R0] == (qword_t)-1)
+	  /* got an error, return details */
+	    regs->regs_R[MD_REG_R0] = -errno;
+	  }
+	  break;
+#endif
+#ifdef FIONBIO
+	case /*FIXME*/FIONBIO:
+	  {
+	    int arg = 0;
+
+	    if (regs->regs_R[MD_REG_R2])
+	      mem_bcopy(mem_fn, mem, Read,
+		      /* arg */regs->regs_R[MD_REG_R2],
+		      &arg, sizeof(arg));
+
+#ifdef NOTNOW
+	    fprintf(stderr, "FIONBIO: %d, %d\n",
+		    (int)regs->regs_R[MD_REG_R0],
+		    arg);
+#endif
+	    /* result */regs->regs_R[MD_REG_R0] =
+	      ioctl(/* fd */(int)regs->regs_R[MD_REG_R0],
+		    /* req */FIONBIO,
+		    /* arg */&arg);
+
+	    if (regs->regs_R[MD_REG_R2])
+	      mem_bcopy(mem_fn, mem, Write,
+		      /* arg */regs->regs_R[MD_REG_R2],
+		      &arg, sizeof(arg));
+
+	    if (regs->regs_R[MD_REG_R0] == (qword_t)-1)
+	  /* got an error, return details */
+	    regs->regs_R[MD_REG_R0] = -errno;
+
+	  }
+	  break;
+#endif
+	default:
+	  warn("unsupported ioctl call: ioctl(%ld, ...)",
+	       regs->regs_R[MD_REG_R1]);
+	  regs->regs_R[MD_REG_R0] = 0;
+	  break;
+	}
+      break;
+
+#if 0
+      {
+	char buf[NUM_IOCTL_BYTES];
+	int local_req = 0;
+
+	/* convert target ioctl() request to host ioctl() request values */
+	switch (/*req*/regs->regs_R[MD_REG_R1]) {
+/* #if !defined(__CYGWIN32__) */
+	case SS_IOCTL_TIOCGETP:
+	  local_req = TIOCGETP;
+	  break;
+	case SS_IOCTL_TIOCSETP:
+	  local_req = TIOCSETP;
+	  break;
+	case SS_IOCTL_TCGETP:
+	  local_req = TIOCGETP;
+	  break;
+/* #endif */
+#ifdef TCGETA
+	case SS_IOCTL_TCGETA:
+	  local_req = TCGETA;
+	  break;
+#endif
+#ifdef TIOCGLTC
+	case SS_IOCTL_TIOCGLTC:
+	  local_req = TIOCGLTC;
+	  break;
+#endif
+#ifdef TIOCSLTC
+	case SS_IOCTL_TIOCSLTC:
+	  local_req = TIOCSLTC;
+	  break;
+#endif
+	case SS_IOCTL_TIOCGWINSZ:
+	  local_req = TIOCGWINSZ;
+	  break;
+#ifdef TCSETAW
+	case SS_IOCTL_TCSETAW:
+	  local_req = TCSETAW;
+	  break;
+#endif
+#ifdef TIOCGETC
+	case SS_IOCTL_TIOCGETC:
+	  local_req = TIOCGETC;
+	  break;
+#endif
+#ifdef TIOCSETC
+	case SS_IOCTL_TIOCSETC:
+	  local_req = TIOCSETC;
+	  break;
+#endif
+#ifdef TIOCLBIC
+	case SS_IOCTL_TIOCLBIC:
+	  local_req = TIOCLBIC;
+	  break;
+#endif
+#ifdef TIOCLBIS
+	case SS_IOCTL_TIOCLBIS:
+	  local_req = TIOCLBIS;
+	  break;
+#endif
+#ifdef TIOCLGET
+	case SS_IOCTL_TIOCLGET:
+	  local_req = TIOCLGET;
+	  break;
+#endif
+#ifdef TIOCLSET
+	case SS_IOCTL_TIOCLSET:
+	  local_req = TIOCLSET;
+	  break;
+#endif
+	}
+
+	if (!local_req)
+	  {
+	    /* FIXME: could not translate the ioctl() request, just warn user
+	       and ignore the request */
+	    warn("syscall: ioctl: ioctl code not supported d=%d, req=%d",
+		 regs->regs_R[MD_REG_R0], regs->regs_R[MD_REG_R1]);
+	    regs->regs_R[MD_REG_R0] = 0;
+	    /*regs->regs_R[7] = 0;*/
+	  }
+	else
+	  {
+	    /* ioctl() code was successfully translated to a host code */
+
+	    /* if arg ptr exists, copy NUM_IOCTL_BYTES bytes to host mem */
+	    if (/*argp*/regs->regs_R[MD_REG_R2] != 0)
+	      mem_bcopy(mem_fn, mem, Read, /*argp*/regs->regs_R[MD_REG_R2],
+			buf, NUM_IOCTL_BYTES);
+
+	    /* perform the ioctl() call */
+	    /*result*/regs->regs_R[MD_REG_R0] =
+	      ioctl(/*fd*/regs->regs_R[MD_REG_R0], local_req, buf);
+
+	    /* if arg ptr exists, copy NUM_IOCTL_BYTES bytes from host mem */
+	    if (/*argp*/regs->regs_R[MD_REG_R2] != 0)
+	      mem_bcopy(mem_fn, mem, Write, regs->regs_R[MD_REG_R2],
+			buf, NUM_IOCTL_BYTES);
+
+	    /* check for an error condition */
+	    if (regs->regs_R[MD_REG_R0] == (qword_t)-1)
+	  /* got an error, return details */
+	    regs->regs_R[MD_REG_R0] = -errno;
+	  }
+      }
+      break;
+#endif
+
+    case ARM_SYS_newfstat:
+      {
+	struct linux_statbuf linux_sbuf;
+	struct stat sbuf;
+
+	/* fstat() the file */
+	/*result*/regs->regs_R[MD_REG_R0] =
+	  fstat(/*fd*/regs->regs_R[MD_REG_R0], &sbuf);
+
+	/* check for an error condition */
+	if (regs->regs_R[MD_REG_R0] == (qword_t)-1)
+	  /* got an error, return details */
+	    regs->regs_R[MD_REG_R0] = -errno;
+
+	/* translate the stat structure to host format */
+	linux_sbuf.linux_st_dev = MD_SWAPH(sbuf.st_dev);
+	linux_sbuf.linux_st_ino = MD_SWAPW(sbuf.st_ino);
+	linux_sbuf.linux_st_mode = MD_SWAPH(sbuf.st_mode);
+	linux_sbuf.linux_st_nlink = MD_SWAPH(sbuf.st_nlink);
+	linux_sbuf.linux_st_uid = MD_SWAPH(sbuf.st_uid);
+	linux_sbuf.linux_st_gid = MD_SWAPH(sbuf.st_gid);
+	linux_sbuf.linux_st_rdev = MD_SWAPH(sbuf.st_rdev);
+	linux_sbuf.linux_st_size = MD_SWAPW(sbuf.st_size);
+	linux_sbuf.linux_st_blksize = MD_SWAPW(sbuf.st_blksize);
+	linux_sbuf.linux_st_blocks = MD_SWAPW(sbuf.st_blocks);
+	linux_sbuf.linux_st_atime = MD_SWAPW(sbuf.st_atime);
+	linux_sbuf.linux_st_mtime = MD_SWAPW(sbuf.st_mtime);
+	linux_sbuf.linux_st_ctime = MD_SWAPW(sbuf.st_ctime);
+
+	/* copy fstat() results to simulator memory */
+	mem_bcopy(mem_fn, mem, Write, /*sbuf*/regs->regs_R[MD_REG_R1],
+		  &linux_sbuf, sizeof(struct linux_statbuf));
+      }
+      break;
+
+        case 0x99990 :  /* set timer microseconds per tick */
+                        timer_period = MD_CLOCK_CYCLES_PER_MICROSECOND * 
+                                regs -> regs_R [ MD_REG_R0 ] ;
+                        timer_next_interrupt_at = sim_cycle + timer_period ;
+                        break ;
+
+
+#if XXX
+/*-------------------------------Is there a getpagesize in arm-linux??----------------------*/
+    case OSF_SYS_getpagesize:
+      /* get target pagesize */
+      regs->regs_R[MD_REG_V0] = /* was: getpagesize() */MD_PAGE_SIZE;
+
+      /* check for an error condition */
+      if (regs->regs_R[MD_REG_V0] != (qword_t)-1)
+	regs->regs_R[MD_REG_A3] = 0;
+      else /* got an error, return details */
+	{
+	  regs->regs_R[MD_REG_A3] = -1;
+	  regs->regs_R[MD_REG_V0] = errno;
+	}
+      break;
+/*----------------------------------------------------------------------------------------*/
+#endif
+
+    case ARM_SYS_setitimer:
+      /* FIXME: the sigvec system call is ignored */
+      warn("syscall: setitimer ignored");
+      regs->regs_R[MD_REG_R0] = 0;
+      break;
+
+#if XXX
+/*-------------------------------Is there a table in arm-linux??----------------------*/
+    case OSF_SYS_table:
+      {
+	qword_t table_id, table_index, buf_addr, num_elem, size_elem;
+	struct osf_tbl_sysinfo sysinfo;
+	
+	table_id = regs->regs_R[MD_REG_A1];
+	table_index = regs->regs_R[MD_REG_A2];
+	buf_addr = regs->regs_R[MD_REG_A3];
+	num_elem = regs->regs_R[MD_REG_A4];
+	size_elem = regs->regs_R[MD_REG_A5];
+	
+	switch(table_id)
+	{
+	case OSF_TBL_SYSINFO:
+	  if (table_index != 0)
+	    {
+	      panic("table: table id TBL_SYSINFO requires 0 index, got %08d",
+		    table_index );
+	    }
+	  else if (num_elem != 1)
+	    {
+	      panic("table: table id TBL_SYSINFO requires 1 elts, got %08d",
+		    num_elem );
+	    }
+	  else
+	    {
+	      struct rusage rusage_info;
+	      
+	      /* use getrusage() to determine user & system time */
+	      if (getrusage(RUSAGE_SELF, &rusage_info) < 0)
+		{
+		  /* abort the system call */
+		  regs->regs_R[MD_REG_A3] = -1;
+		  /* not kosher to pass off errno of getrusage() as errno
+		     of table(), but what the heck... */
+		  regs->regs_R[MD_REG_V0] = errno;
+		  break;
+		}
+	      
+	      /* use sysconf() to determine clock tick frequency */
+	      sysinfo.si_hz = sysconf(_SC_CLK_TCK);
+
+	      /* convert user and system time into clock ticks */
+	      sysinfo.si_user = rusage_info.ru_utime.tv_sec * sysinfo.si_hz + 
+		(rusage_info.ru_utime.tv_usec * sysinfo.si_hz) / 1000000UL;
+	      sysinfo.si_sys = rusage_info.ru_stime.tv_sec * sysinfo.si_hz + 
+		(rusage_info.ru_stime.tv_usec * sysinfo.si_hz) / 1000000UL;
+
+	      /* following can't be determined in a portable manner and
+		 are ignored */
+	      sysinfo.si_nice = 0;
+	      sysinfo.si_idle = 0;
+	      sysinfo.si_phz = 0;
+	      sysinfo.si_boottime = 0;
+	      sysinfo.wait = 0;
+
+	      /* copy structure into simulator memory */
+	      mem_bcopy(mem_fn, mem, Write, buf_addr,
+			&sysinfo, sizeof(struct osf_tbl_sysinfo));
+
+	      /* return success */
+	      regs->regs_R[MD_REG_A3] = 0;
+	    }
+	  break;
+
+	default:
+	  warn("table: unsupported table id %d requested, ignored", table_id);
+	  regs->regs_R[MD_REG_A3] = 0;
+	}
+      }
+      break;
+/*----------------------------------------------------------------------------------------*/
+#endif
+
+
+#if XXX
+/*-------------------------------Is there a getdtablesize in arm-linux??----------------------*/
+    case OSF_SYS_getdtablesize:
+#if defined(_AIX) || defined(__alpha)
+      /* get descriptor table size */
+      regs->regs_R[MD_REG_V0] = getdtablesize();
+
+      /* check for an error condition */
+      if (regs->regs_R[MD_REG_V0] != (qword_t)-1)
+	regs->regs_R[MD_REG_A3] = 0;
+      else /* got an error, return details */
+	{
+	  regs->regs_R[MD_REG_A3] = -1;
+	  regs->regs_R[MD_REG_V0] = errno;
+	}
+#elif defined(ultrix)
+      {
+	/* no comparable system call found, try some reasonable defaults */
+	warn("syscall: called getdtablesize\n");
+	regs->regs_R[MD_REG_V0] = 16;
+	regs->regs_R[MD_REG_A3] = 0;
+      }
+#elif defined(MIN_SYSCALL_MODE)
+      {
+	/* no comparable system call found, try some reasonable defaults */
+	warn("syscall: called getdtablesize\n");
+	regs->regs_R[MD_REG_V0] = 16;
+	regs->regs_R[MD_REG_A3] = 0;
+      }
+#else
+      {
+	struct rlimit rl;
+
+	/* get descriptor table size in rlimit structure */
+	if (getrlimit(RLIMIT_NOFILE, &rl) != (qword_t)-1)
+	  {
+	    regs->regs_R[MD_REG_V0] = rl.rlim_cur;
+	    regs->regs_R[MD_REG_A3] = 0;
+	  }
+	else /* got an error, return details */
+	  {
+	    regs->regs_R[MD_REG_A3] = -1;
+	    regs->regs_R[MD_REG_V0] = errno;
+	  }
+      }
+#endif
+      break;
+/*----------------------------------------------------------------------------------------*/
+#endif
+
+    case ARM_SYS_dup2:
+      /* dup2() the file descriptor */
+      regs->regs_R[MD_REG_R0] =
+	dup2(/*fd1*/regs->regs_R[MD_REG_R0], /*fd2*/regs->regs_R[MD_REG_R1]);
+
+      /* check for an error condition */
+      if (regs->regs_R[MD_REG_R0] == (qword_t)-1)
+	  /* got an error, return details */
+	    regs->regs_R[MD_REG_R0] = -errno;
+      break;
+
+    case ARM_SYS_fcntl:
+#ifdef _MSC_VER
+      warn("syscall fcntl() not yet implemented for MSC...");
+      regs->regs_R[MD_REG_R0] = 0;
+#else /* !_MSC_VER */
+      /* get fcntl() information on the file */
+      regs->regs_R[MD_REG_R0] =
+	fcntl(/*fd*/regs->regs_R[MD_REG_R0],
+	      /*cmd*/regs->regs_R[MD_REG_R1], /*arg*/regs->regs_R[MD_REG_R2]);
+
+      /* check for an error condition */
+      if (regs->regs_R[MD_REG_R0] == (qword_t)-1)
+	  /* got an error, return details */
+	    regs->regs_R[MD_REG_R0] = -errno;
+#endif /* _MSC_VER */
+      break;
+
+	    /*-------------------------------Out of ARM-------------------------------------*/
+#if 0
+    case OSF_SYS_sigvec:
+      /* FIXME: the sigvec system call is ignored */
+      warn("syscall: sigvec ignored");
+      regs->regs_R[MD_REG_A3] = 0;
+      break;
+#endif
+
+#if 0
+    case OSF_SYS_sigblock:
+      /* FIXME: the sigblock system call is ignored */
+      warn("syscall: sigblock ignored");
+      regs->regs_R[MD_REG_A3] = 0;
+      break;
+#endif
+
+#if 0
+    case OSF_SYS_sigsetmask:
+      /* FIXME: the sigsetmask system call is ignored */
+      warn("syscall: sigsetmask ignored");
+      regs->regs_R[MD_REG_A3] = 0;
+      break;
+#endif
+/*----------------------------------------------------------------------------------*/
+
+#if XXX
+    case OSF_SYS_gettimeofday:
+#ifdef _MSC_VER
+      warn("syscall gettimeofday() not yet implemented for MSC...");
+      regs->regs_R[MD_REG_R0] = 0;
+#else /* _MSC_VER */
+      {
+	struct osf_timeval osf_tv;
+	struct timeval tv, *tvp;
+	struct osf_timezone osf_tz;
+	struct timezone tz, *tzp;
+
+	if (/*timeval*/regs->regs_R[MD_REG_R0] != 0)
+	  {
+	    /* copy timeval into host memory */
+	    mem_bcopy(mem_fn, mem, Read, /*timeval*/regs->regs_R[MD_REG_R0],
+		      &osf_tv, sizeof(struct osf_timeval));
+
+	    /* convert target timeval structure to host format */
+	    tv.tv_sec = MD_SWAPW(osf_tv.osf_tv_sec);
+	    tv.tv_usec = MD_SWAPW(osf_tv.osf_tv_usec);
+	    tvp = &tv;
+	  }
+	else
+	  tvp = NULL;
+
+	if (/*timezone*/regs->regs_R[MD_REG_R1] != 0)
+	  {
+	    /* copy timezone into host memory */
+	    mem_bcopy(mem_fn, mem, Read, /*timezone*/regs->regs_R[MD_REG_R1],
+		      &osf_tz, sizeof(struct osf_timezone));
+
+	    /* convert target timezone structure to host format */
+	    tz.tz_minuteswest = MD_SWAPW(osf_tz.osf_tz_minuteswest);
+	    tz.tz_dsttime = MD_SWAPW(osf_tz.osf_tz_dsttime);
+	    tzp = &tz;
+	  }
+	else
+	  tzp = NULL;
+
+	/* get time of day */
+	/*result*/regs->regs_R[MD_REG_R0] = gettimeofday(tvp, tzp);
+
+	/* check for an error condition */
+	if (regs->regs_R[MD_REG_R0] == (qword_t)-1)
+	  /* got an error, return details */
+	    regs->regs_R[MD_REG_R0] = -errno;
+
+	if (/*timeval*/regs->regs_R[MD_REG_R0] != 0)
+	  {
+	    /* convert host timeval structure to target format */
+	    osf_tv.osf_tv_sec = MD_SWAPW(tv.tv_sec);
+	    osf_tv.osf_tv_usec = MD_SWAPW(tv.tv_usec);
+
+	    /* copy timeval to target memory */
+	    mem_bcopy(mem_fn, mem, Write, /*timeval*/regs->regs_R[MD_REG_R0],
+		      &osf_tv, sizeof(struct osf_timeval));
+	  }
+
+	if (/*timezone*/regs->regs_R[MD_REG_R1] != 0)
+	  {
+	    /* convert host timezone structure to target format */
+	    osf_tz.osf_tz_minuteswest = MD_SWAPW(tz.tz_minuteswest);
+	    osf_tz.osf_tz_dsttime = MD_SWAPW(tz.tz_dsttime);
+
+	    /* copy timezone to target memory */
+	    mem_bcopy(mem_fn, mem, Write, /*timezone*/regs->regs_R[MD_REG_R1],
+		      &osf_tz, sizeof(struct osf_timezone));
+	  }
+      }
+#endif /* !_MSC_VER */
+      break;
+#endif
+
+    case ARM_SYS_getrusage:
+#if defined(__svr4__) || defined(__USLC__) || defined(hpux) || defined(__hpux) || defined(_AIX)
+      {
+	struct tms tms_buf;
+	struct osf_rusage rusage;
+
+	/* get user and system times */
+	if (times(&tms_buf) != (qword_t)-1)
+	  {
+	    /* no error */
+	    regs->regs_R[MD_REG_R0] = 0;
+	  }
+	else /* got an error, indicate result */
+	  {
+	    regs->regs_R[MD_REG_R0] = -errno;
+	  }
+
+	/* initialize target rusage result structure */
+#if defined(__svr4__)
+	memset(&rusage, '\0', sizeof(struct osf_rusage));
+#else /* !defined(__svr4__) */
+	bzero(&rusage, sizeof(struct osf_rusage));
+#endif
+
+	/* convert from host rusage structure to target format */
+	rusage.osf_ru_utime.osf_tv_sec = MD_SWAPW(tms_buf.tms_utime/CLK_TCK);
+	rusage.osf_ru_utime.osf_tv_sec =
+	  MD_SWAPW(rusage.osf_ru_utime.osf_tv_sec);
+	rusage.osf_ru_utime.osf_tv_usec = 0;
+	rusage.osf_ru_stime.osf_tv_sec = MD_SWAPW(tms_buf.tms_stime/CLK_TCK);
+	rusage.osf_ru_stime.osf_tv_sec =
+	  MD_SWAPW(rusage.osf_ru_stime.osf_tv_sec);
+	rusage.osf_ru_stime.osf_tv_usec = 0;
+
+	/* copy rusage results into target memory */
+	mem_bcopy(mem_fn, mem, Write, /*rusage*/regs->regs_R[MD_REG_A1],
+		  &rusage, sizeof(struct osf_rusage));
+      }
+#elif defined(__unix__)
+      {
+	struct rusage local_rusage;
+	struct osf_rusage rusage;
+
+	/* get rusage information */
+	/*result*/regs->regs_R[MD_REG_R0] =
+	  getrusage(/*who*/regs->regs_R[MD_REG_R0], &local_rusage);
+
+	/* check for an error condition */
+	if (regs->regs_R[MD_REG_R0] == (qword_t)-1)
+	  /* got an error, return details */
+	    regs->regs_R[MD_REG_R0] = -errno;
+
+	/* convert from host rusage structure to target format */
+	rusage.osf_ru_utime.osf_tv_sec =
+	  MD_SWAPW(local_rusage.ru_utime.tv_sec);
+	rusage.osf_ru_utime.osf_tv_usec =
+	  MD_SWAPW(local_rusage.ru_utime.tv_usec);
+	rusage.osf_ru_utime.osf_tv_sec =
+	  MD_SWAPW(local_rusage.ru_utime.tv_sec);
+	rusage.osf_ru_utime.osf_tv_usec =
+	  MD_SWAPW(local_rusage.ru_utime.tv_usec);
+	rusage.osf_ru_stime.osf_tv_sec =
+	  MD_SWAPW(local_rusage.ru_stime.tv_sec);
+	rusage.osf_ru_stime.osf_tv_usec =
+	  MD_SWAPW(local_rusage.ru_stime.tv_usec);
+	rusage.osf_ru_stime.osf_tv_sec =
+	  MD_SWAPW(local_rusage.ru_stime.tv_sec);
+	rusage.osf_ru_stime.osf_tv_usec =
+	  MD_SWAPW(local_rusage.ru_stime.tv_usec);
+	rusage.osf_ru_maxrss = MD_SWAPW(local_rusage.ru_maxrss);
+	rusage.osf_ru_ixrss = MD_SWAPW(local_rusage.ru_ixrss);
+	rusage.osf_ru_idrss = MD_SWAPW(local_rusage.ru_idrss);
+	rusage.osf_ru_isrss = MD_SWAPW(local_rusage.ru_isrss);
+	rusage.osf_ru_minflt = MD_SWAPW(local_rusage.ru_minflt);
+	rusage.osf_ru_majflt = MD_SWAPW(local_rusage.ru_majflt);
+	rusage.osf_ru_nswap = MD_SWAPW(local_rusage.ru_nswap);
+	rusage.osf_ru_inblock = MD_SWAPW(local_rusage.ru_inblock);
+	rusage.osf_ru_oublock = MD_SWAPW(local_rusage.ru_oublock);
+	rusage.osf_ru_msgsnd = MD_SWAPW(local_rusage.ru_msgsnd);
+	rusage.osf_ru_msgrcv = MD_SWAPW(local_rusage.ru_msgrcv);
+	rusage.osf_ru_nsignals = MD_SWAPW(local_rusage.ru_nsignals);
+	rusage.osf_ru_nvcsw = MD_SWAPW(local_rusage.ru_nvcsw);
+	rusage.osf_ru_nivcsw = MD_SWAPW(local_rusage.ru_nivcsw);
+
+	/* copy rusage results into target memory */
+	mem_bcopy(mem_fn, mem, Write, /*rusage*/regs->regs_R[MD_REG_R1],
+		  &rusage, sizeof(struct osf_rusage));
+      }
+#elif defined(__CYGWIN32__) || defined(_MSC_VER)
+	    warn("syscall: called getrusage\n");
+            regs->regs_R[7] = 0;
+#else
+#error No getrusage() implementation!
+#endif
+      break;
+
+#if XXX
+/*-------------------------------Is there a utimes in arm-linux??----------------------*/
+    case OSF_SYS_utimes:
+      {
+	char buf[MAXBUFSIZE];
+
+	/* copy filename to host memory */
+	mem_strcpy(mem_fn, mem, Read, /*fname*/regs->regs_R[MD_REG_A0], buf);
+
+	if (/*timeval*/regs->regs_R[MD_REG_A1] == 0)
+	  {
+#if defined(hpux) || defined(__hpux) || defined(__i386__)
+	    /* no utimes() in hpux, use utime() instead */
+	    /*result*/regs->regs_R[MD_REG_V0] = utime(buf, NULL);
+#elif defined(_MSC_VER)
+            /* no utimes() in MSC, use utime() instead */
+	    /*result*/regs->regs_R[MD_REG_V0] = utime(buf, NULL);
+#elif defined(__svr4__) || defined(__USLC__) || defined(unix) || defined(_AIX) || defined(__alpha)
+	    /*result*/regs->regs_R[MD_REG_V0] = utimes(buf, NULL);
+#elif defined(__CYGWIN32__)
+	    warn("syscall: called utimes\n");
+#else
+#error No utimes() implementation!
+#endif
+	  }
+	else
+	  {
+	    struct osf_timeval osf_tval[2];
+#ifndef _MSC_VER
+	    struct timeval tval[2];
+#endif /* !_MSC_VER */
+
+	    /* copy timeval structure to host memory */
+	    mem_bcopy(mem_fn, mem, Read, /*timeout*/regs->regs_R[MD_REG_A1],
+		      osf_tval, 2*sizeof(struct osf_timeval));
+
+#ifndef _MSC_VER
+	    /* convert timeval structure to host format */
+	    tval[0].tv_sec = MD_SWAPW(osf_tval[0].osf_tv_sec);
+	    tval[0].tv_usec = MD_SWAPW(osf_tval[0].osf_tv_usec);
+	    tval[1].tv_sec = MD_SWAPW(osf_tval[1].osf_tv_sec);
+	    tval[1].tv_usec = MD_SWAPW(osf_tval[1].osf_tv_usec);
+#endif /* !_MSC_VER */
+
+#if defined(hpux) || defined(__hpux) || defined(__svr4__)
+	    /* no utimes() in hpux, use utime() instead */
+	    {
+	      struct utimbuf ubuf;
+
+	      ubuf.actime = MD_SWAPW(tval[0].tv_sec);
+	      ubuf.modtime = MD_SWAPW(tval[1].tv_sec);
+
+	      /* result */regs->regs_R[MD_REG_V0] = utime(buf, &ubuf);
+	    }
+#elif defined(_MSC_VER)
+            /* no utimes() in hpux, use utime() instead */
+            {
+              struct _utimbuf ubuf;
+
+              ubuf.actime = MD_SWAPW(osf_tval[0].osf_tv_sec);
+              ubuf.modtime = MD_SWAPW(osf_tval[1].osf_tv_sec);
+
+              /* result */regs->regs_R[MD_REG_V0] = utime(buf, &ubuf);
+            }
+#elif defined(__USLC__) || defined(unix) || defined(_AIX) || defined(__alpha)
+	    /* result */regs->regs_R[MD_REG_V0] = utimes(buf, tval);
+#elif defined(__CYGWIN32__)
+	    warn("syscall: called utimes\n");
+#else
+#error No utimes() implementation!
+#endif
+	  }
+
+	/* check for an error condition */
+	if (regs->regs_R[MD_REG_V0] != (qword_t)-1)
+	  regs->regs_R[MD_REG_A3] = 0;
+	else /* got an error, return details */
+	  {
+	    regs->regs_R[MD_REG_A3] = -1;
+	    regs->regs_R[MD_REG_V0] = errno;
+	  }
+      }
+      break;
+/*----------------------------------------------------------------------------------*/
+#endif
+
+#if XXX
+    case ARM_SYS_getrlimit:
+    case ARM_SYS_setrlimit:
+#ifdef _MSC_VER
+      warn("syscall get/setrlimit() not yet implemented for MSC...");
+      regs->regs_R[MD_REG_R0] = 0;
+#elif defined(__CYGWIN32__)
+      {
+	warn("syscall: called get/setrlimit\n");
+	regs->regs_R[MD_REG_R0] = 0;
+      }
+#else
+      {
+	struct osf_rlimit osf_rl;
+	struct rlimit rl;
+
+	/* copy rlimit structure to host memory */
+	mem_bcopy(mem_fn, mem, Read, /*rlimit*/regs->regs_R[MD_REG_R1],
+		  &osf_rl, sizeof(struct osf_rlimit));
+
+	/* convert rlimit structure to host format */
+	rl.rlim_cur = MD_SWAPQ(osf_rl.osf_rlim_cur);
+	rl.rlim_max = MD_SWAPQ(osf_rl.osf_rlim_max);
+
+	/* get rlimit information */
+	if (syscode == OSF_SYS_getrlimit)
+	  /*result*/regs->regs_R[MD_REG_R0] =
+	    getrlimit(regs->regs_R[MD_REG_R0], &rl);
+	else /* syscode == OSF_SYS_setrlimit */
+	  /*result*/regs->regs_R[MD_REG_R0] =
+	    setrlimit(regs->regs_R[MD_REG_R0], &rl);
+
+	/* check for an error condition */
+	if (regs->regs_R[MD_REG_R0] == (qword_t)-1)
+	  /* got an error, return details */
+	    regs->regs_R[MD_REG_R0] = -errno;
+
+	/* convert rlimit structure to target format */
+	osf_rl.osf_rlim_cur = MD_SWAPQ(rl.rlim_cur);
+	osf_rl.osf_rlim_max = MD_SWAPQ(rl.rlim_max);
+
+	/* copy rlimit structure to target memory */
+	mem_bcopy(mem_fn, mem, Write, /*rlimit*/regs->regs_R[MD_REG_R1],
+		  &osf_rl, sizeof(struct osf_rlimit));
+      }
+#endif
+      break;
+#endif
+
+    case ARM_SYS_sigprocmask:
+      {
+	static int first = TRUE;
+
+	if (first)
+	  {
+	    warn("partially supported sigprocmask() call...");
+	    first = FALSE;
+	  }
+
+	/* from klauser@cs.colorado.edu: there are a couple bugs in the
+	   sigprocmask implementation; here is a fix: the problem comes from an
+	   impedance mismatch between application/libc interface and
+	   libc/syscall interface, the former of which you read about in the
+	   manpage, the latter of which you actually intercept here.  The
+	   following is mostly correct, but does not capture some minor
+	   details, which you only get right if you really let the kernel
+	   handle it. (e.g. you can't really ever block sigkill etc.) */
+
+        /*regs->regs_R[MD_REG_V0] = sigmask;*/
+
+        switch (regs->regs_R[MD_REG_R0])
+	  {
+          case OSF_SIG_BLOCK:
+            sigmask |= regs->regs_R[MD_REG_R1];
+            break;
+          case OSF_SIG_UNBLOCK:
+            sigmask &= ~regs->regs_R[MD_REG_R1];
+            break;
+          case OSF_SIG_SETMASK:
+            sigmask = regs->regs_R[MD_REG_R1];
+            break;
+          default:
+            regs->regs_R[MD_REG_R0] = -EINVAL;
+
+	  }
+
+#if 0 /* FIXME: obsolete... */
+	if (regs->regs_R[MD_REG_R2] > /* FIXME: why? */0x10000000)
+	  mem_bcopy(mem_fn, mem, Write, regs->regs_R[MD_REG_R2],
+		    &sigmask, sizeof(sigmask));
+
+	if (regs->regs_R[MD_REG_R1] != 0)
+	  {
+	    switch (regs->regs_R[MD_REG_R0])
+	      {
+	      case OSF_SIG_BLOCK:
+		sigmask |= regs->regs_R[MD_REG_R1];
+		break;
+	      case OSF_SIG_UNBLOCK:
+		sigmask &= regs->regs_R[MD_REG_R1]; /* I think */
+	      break;
+	      case OSF_SIG_SETMASK:
+		sigmask = regs->regs_R[MD_REG_R1]; /* I think */
+		break;
+	      default:
+		panic("illegal how value to sigprocmask()");
+	      }
+	  }
+	regs->regs_R[MD_REG_R0] = 0;
+
+#endif
+      }
+      break;
+
+    case ARM_SYS_sigaction:
+      {
+	int signum;
+	static int first = TRUE;
+
+	if (first)
+	  {
+	    warn("partially supported sigaction() call...");
+	    first = FALSE;
+	  }
+
+	signum = regs->regs_R[MD_REG_R0];
+	if (regs->regs_R[MD_REG_R1] != 0)
+	  sigaction_array[signum] = regs->regs_R[MD_REG_R1];
+
+	if (regs->regs_R[MD_REG_R2])
+	  regs->regs_R[MD_REG_R2] = sigaction_array[signum];
+
+	regs->regs_R[MD_REG_R0] = 0;
+
+	/* for some reason, __sigaction expects A3 to have a 0 return value 
+	regs->regs_R[MD_REG_A3] = 0; */
+  
+	/* FIXME: still need to add code so that on a signal, the 
+	   correct action is actually taken. */
+
+	/* FIXME: still need to add support for returning the correct
+	   error messages (EFAULT, EINVAL) */
+      }
+      break;
+
+#if XXX
+    case OSF_SYS_sigstack:
+      warn("unsupported sigstack() call...");
+      regs->regs_R[MD_REG_R0] = 0;
+      break;
+#endif
+
+#if XXX
+    case ARM_SYS_sigreturn:
+      {
+	int i;
+	struct osf_sigcontext sc;
+	static int first = TRUE;
+
+	if (first)
+	  {
+	    warn("partially supported sigreturn() call...");
+	    first = FALSE;
+	  }
+
+	mem_bcopy(mem_fn, mem, Read, /* sc */regs->regs_R[MD_REG_R0],
+		  &sc, sizeof(struct osf_sigcontext));
+
+	sigmask = MD_SWAPQ(sc.sc_mask); /* was: prog_sigmask */
+	regs->regs_NPC = MD_SWAPQ(sc.sc_pc);
+
+	/* FIXME: should check for the branch delay bit */
+	/* FIXME: current->nextpc = current->pc + 4; not sure about this... */
+	for (i=0; i < 32; ++i)
+	  regs->regs_R[i] = sc.sc_regs[i];
+	for (i=0; i < 32; ++i)
+	  regs->regs_F.q[i] = sc.sc_fpregs[i];
+	regs->regs_C.fpcr = sc.sc_fpcr;
+      }
+      break;
+#endif
+
+#if XXX
+/*------------------------------------Out of ARM???? -------------------------------*/
+    case OSF_SYS_uswitch:
+      warn("unsupported uswitch() call...");
+      regs->regs_R[MD_REG_V0] = regs->regs_R[MD_REG_A1]; 
+      break;
+#endif
+
+#if XXX
+    case OSF_SYS_setsysinfo:
+      warn("unsupported setsysinfo() call...");
+      regs->regs_R[MD_REG_V0] = 0; 
+      break;
+#endif
+
+/* Is this in arm??? ----*/
+#if !defined(MIN_SYSCALL_MODE) && 0 
+    case OSF_SYS_getdirentries:
+      {
+	int i, cnt, osf_cnt;
+	struct dirent *p;
+	sword_t fd = regs->regs_R[MD_REG_A0];
+	md_addr_t osf_buf = regs->regs_R[MD_REG_A1];
+	char *buf;
+	sword_t osf_nbytes = regs->regs_R[MD_REG_A2];
+	md_addr_t osf_pbase = regs->regs_R[MD_REG_A3];
+	sqword_t osf_base;
+	long base = 0;
+
+	/* number of entries in simulated memory */
+	if (!osf_nbytes)
+	  warn("attempting to get 0 directory entries...");
+
+	/* allocate local memory, whatever fits */
+	buf = calloc(1, osf_nbytes);
+	if (!buf)
+	  fatal("out of virtual memory");
+
+	/* get directory entries */
+#if defined(__svr4__)
+	base = lseek ((int)fd, (off_t)0, SEEK_CUR);
+	regs->regs_R[MD_REG_V0] =
+	  getdents((int)fd, (struct dirent *)buf, (size_t)osf_nbytes);
+#else /* !__svr4__ */
+	regs->regs_R[MD_REG_V0] =
+	  getdirentries((int)fd, buf, (size_t)osf_nbytes, &base);
+#endif
+
+	/* check for an error condition */
+	if (regs->regs_R[MD_REG_V0] != (qword_t)-1)
+	  {
+	    regs->regs_R[MD_REG_A3] = 0;
+
+	    /* anything to copy back? */
+	    if (regs->regs_R[MD_REG_V0] > 0)
+	      {
+		/* copy all possible results to simulated space */
+		for (i=0, cnt=0, osf_cnt=0, p=(struct dirent *)buf;
+		     cnt < regs->regs_R[MD_REG_V0] && p->d_reclen > 0;
+		     i++, cnt += p->d_reclen, p=(struct dirent *)(buf+cnt))
+		  {
+		    struct osf_dirent osf_dirent;
+
+		    osf_dirent.d_ino = MD_SWAPW(p->d_ino);
+		    osf_dirent.d_namlen = MD_SWAPH(strlen(p->d_name));
+		    strcpy(osf_dirent.d_name, p->d_name);
+		    osf_dirent.d_reclen = MD_SWAPH(OSF_DIRENT_SZ(p->d_name));
+
+		    mem_bcopy(mem_fn, mem, Write,
+			      osf_buf + osf_cnt,
+			      &osf_dirent, OSF_DIRENT_SZ(p->d_name));
+		    osf_cnt += OSF_DIRENT_SZ(p->d_name);
+		  }
+
+		if (osf_pbase != 0)
+		  {
+		    osf_base = (sqword_t)base;
+		    mem_bcopy(mem_fn, mem, Write, osf_pbase,
+			      &osf_base, sizeof(osf_base));
+		  }
+
+		/* update V0 to indicate translated read length */
+		regs->regs_R[MD_REG_V0] = osf_cnt;
+	      }
+	  }
+	else /* got an error, return details */
+	  {
+	    regs->regs_R[MD_REG_A3] = -1;
+	    regs->regs_R[MD_REG_V0] = errno;
+	  }
+
+	free(buf);
+      }
+      break;
+#endif
+/*-----------------------------------------------------------------------------------------*/
+
+
+#if !defined(MIN_SYSCALL_MODE)
+    case ARM_SYS_truncate: /*find out what the 64 is for */
+      {
+	char buf[MAXBUFSIZE];
+
+	/* copy filename to host memory */
+	mem_strcpy(mem_fn, mem, Read, /*fname*/regs->regs_R[MD_REG_R0], buf);
+
+	/* truncate the file */
+	/*result*/regs->regs_R[MD_REG_R0] =
+	  truncate(buf, /* length */(size_t)regs->regs_R[MD_REG_R1]);
+
+	/* check for an error condition */
+	if (regs->regs_R[MD_REG_R0] == (qword_t)-1)
+	  /* got an error, return details */
+	    regs->regs_R[MD_REG_R0] = -errno;
+      }
+      break;
+#endif
+
+#if !defined(__CYGWIN32__) && !defined(_MSC_VER)
+    case ARM_SYS_ftruncate:
+      /* truncate the file */
+      /*result*/regs->regs_R[MD_REG_R0] =
+	ftruncate(/* fd */(int)regs->regs_R[MD_REG_R0],
+		 /* length */(size_t)regs->regs_R[MD_REG_R1]);
+
+      /* check for an error condition */
+      if (regs->regs_R[MD_REG_R0] == (qword_t)-1)
+	  /* got an error, return details */
+	    regs->regs_R[MD_REG_R0] = -errno;
+      break;
+#endif
+
+#if !defined(MIN_SYSCALL_MODE)
+    case ARM_SYS_statfs:
+      {
+	char buf[MAXBUFSIZE];
+	struct osf_statfs osf_sbuf;
+	struct statfs sbuf;
+
+	/* copy filename to host memory */
+	mem_strcpy(mem_fn, mem, Read, /*fName*/regs->regs_R[MD_REG_R0], buf);
+
+	/* statfs() the fs */
+	/*result*/regs->regs_R[MD_REG_R0] = statfs(buf, &sbuf);
+
+	/* check for an error condition */
+	if (regs->regs_R[MD_REG_R0] == (qword_t)-1)
+	  /* got an error, return details */
+	    regs->regs_R[MD_REG_R0] = -errno;
+
+	/* translate from host stat structure to target format */
+#if defined(__svr4__) || defined(__osf__)
+	osf_sbuf.f_type = MD_SWAPH(0x6969) /* NFS, whatever... */;
+#else /* !__svr4__ */
+	osf_sbuf.f_type = MD_SWAPH(sbuf.f_type);
+#endif
+	osf_sbuf.f_fsize = MD_SWAPW(sbuf.f_bsize);
+	osf_sbuf.f_blocks = MD_SWAPW(sbuf.f_blocks);
+	osf_sbuf.f_bfree = MD_SWAPW(sbuf.f_bfree);
+	osf_sbuf.f_bavail = MD_SWAPW(sbuf.f_bavail);
+	osf_sbuf.f_files = MD_SWAPW(sbuf.f_files);
+	osf_sbuf.f_ffree = MD_SWAPW(sbuf.f_ffree);
+	/* osf_sbuf.f_fsid = MD_SWAPW(sbuf.f_fsid); */
+      
+          
+	/* copy stat() results to simulator memory */
+
+	mem_bcopy(mem_fn, mem, Write, /*sbuf*/regs->regs_R[MD_REG_R1],		           &osf_sbuf, sizeof(struct osf_statfs)); 
+
+        /*changed osf_statbuf to osf_statfs for arm? */
+
+      }
+      break;
+#endif
+
+
+
+#if !defined(MIN_SYSCALL_MODE)
+    case ARM_SYS_setregid:
+      /* set real and effective group ID */
+
+      /*result*/regs->regs_R[MD_REG_R0] =
+	setregid(/* rgid */(gid_t)regs->regs_R[MD_REG_R0],
+		 /* egid */(gid_t)regs->regs_R[MD_REG_R1]);
+
+      fprintf(stderr,"Why??");
+      /* check for an error condition */
+      if (regs->regs_R[MD_REG_R0] == (qword_t)-1)
+	  /* got an error, return details */
+	    regs->regs_R[MD_REG_R0] = -errno;
+      break;
+#endif
+
+#if !defined(MIN_SYSCALL_MODE)
+	    //    case OSF_SYS_setreuid:
+    case ARM_SYS_setreuid:
+      /* set real and effective user ID */
+
+      /*result*/regs->regs_R[MD_REG_R0] =
+	setreuid(/* ruid */(uid_t)regs->regs_R[MD_REG_R0],
+		 /* euid */(uid_t)regs->regs_R[MD_REG_R1]);
+
+      /* check for an error condition */
+      if (regs->regs_R[MD_REG_R0] == (qword_t)-1)
+	  /* got an error, return details */
+	    regs->regs_R[MD_REG_R0] = -errno;
+      break;
+#endif
+
+	    /* this is a subclass of the socketcall in arm */
+#if !defined(MIN_SYSCALL_MODE) && 0
+    case ARM_SYS_socket:
+        int __domain,__type,__protocol;
+
+        /* grab the socket call arguments from simulated memory */
+        mem_bcopy(mem_fn, mem, Read, regs->regs_R[MD_REG_R1], &__domain,
+		  /*nbytes*/sizeof(int));
+        mem_bcopy(mem_fn, mem, Read, (regs->regs_R[MD_REG_R1]+sizeof(int)), &__type,
+		  /*nbytes*/sizeof(int));
+        mem_bcopy(mem_fn, mem, Read, (regs->regs_R[MD_REG_R1]+2*sizeof(int)), &__protocol,
+		  /*nbytes*/sizeof(int));
+
+      /* create an endpoint for communication */
+
+      /* result */regs->regs_R[MD_REG_R0] =
+	socket(/* domain */xlate_arg(__domain,
+				     family_map, N_ELT(family_map),
+				     "socket(family)"),
+	       /* type */xlate_arg(__type,
+				   socktype_map, N_ELT(socktype_map),
+				   "socket(type)"),
+	       /* protocol */xlate_arg(__protocol,
+				       family_map, N_ELT(family_map),
+				       "socket(proto)"));
+
+      /* check for an error condition */
+      if (regs->regs_R[MD_REG_R0] == (qword_t)-1)
+	  /* got an error, return details */
+	    regs->regs_R[MD_REG_R0] = -errno;
+      break;
+#endif
+	    /* This is a subclass of the socketcall in arm linux */
+#if !defined(MIN_SYSCALL_MODE) && 0
+    case ARM_SYS_connect:
+      {
+	struct osf_sockaddr osf_sa;
+
+	/* initiate a connection on a socket */
+
+	/* get the socket address */
+	if (regs->regs_R[MD_REG_R2] > sizeof(struct osf_sockaddr))
+	  {
+	    fatal("sockaddr size overflow: addrlen = %d",
+		  regs->regs_R[MD_REG_R2]);
+	  }
+	/* copy sockaddr structure to host memory */
+	mem_bcopy(mem_fn, mem, Read, /* serv_addr */regs->regs_R[MD_REG_R1],
+		  &osf_sa, /* addrlen */(int)regs->regs_R[MD_REG_R2]);
+#if 0
+	int i;
+	sa.sa_family = osf_sa.sa_family;
+	for (i=0; i < regs->regs_R[MD_REG_R2]; i++)
+	  sa.sa_data[i] = osf_sa.sa_data[i];
+#endif
+	/* result */regs->regs_R[MD_REG_R0] =
+	  connect(/* sockfd */(int)regs->regs_R[MD_REG_R0],
+		  (void *)&osf_sa, /* addrlen */(int)regs->regs_R[MD_REG_R2]);
+
+	/* check for an error condition */
+	if (regs->regs_R[MD_REG_R0] == (qword_t)-1)
+	  /* got an error, return details */
+	    regs->regs_R[MD_REG_R0] = -errno;
+      }
+      break;
+#endif
+
+/* Should olduname and oldolduname be supported ?? ctw*/
+#if !defined(MIN_SYSCALL_MODE)
+    case ARM_SYS_newuname:
+      /* get name and information about current kernel */
+
+      regs->regs_R[MD_REG_R0] = -EPERM;
+      break;
+#endif
+
+#if !defined(MIN_SYSCALL_MODE)
+    case ARM_SYS_writev:
+      {
+	int i;
+	int error_return;
+	char *buf;
+	struct iovec *iov;
+
+	/* allocate host side I/O vectors */
+	iov =
+	  (struct iovec *)malloc(/* iovcnt */regs->regs_R[MD_REG_R2]
+				 * sizeof(struct iovec));
+	if (!iov)
+	  fatal("out of virtual memory in SYS_writev");
+
+	/* copy target side I/O vector buffers to host memory */
+	for (i=0; i < /* iovcnt */regs->regs_R[MD_REG_R2]; i++)
+	  {
+	    struct osf_iovec osf_iov;
+
+	    /* copy target side pointer data into host side vector */
+	    mem_bcopy(mem_fn, mem, Read,
+		      (/*iov*/regs->regs_R[MD_REG_R1]
+		       + i*sizeof(struct osf_iovec)),
+		      &osf_iov, sizeof(struct osf_iovec));
+
+	    iov[i].iov_len = MD_SWAPW(osf_iov.iov_len);
+	    if (osf_iov.iov_base != 0 && osf_iov.iov_len != 0)
+	      {
+		buf = (char *)calloc(MD_SWAPW(osf_iov.iov_len), sizeof(char));
+		if (!buf)
+		  fatal("out of virtual memory in SYS_writev");
+		mem_bcopy(mem_fn, mem, Read, MD_SWAPQ(osf_iov.iov_base),
+			  buf, MD_SWAPW(osf_iov.iov_len));
+		iov[i].iov_base = buf;
+	      }
+	    else
+	      iov[i].iov_base = NULL;
+	  }
+
+	/* perform the vector'ed write */
+	do {
+	  /*result*/error_return =
+	    writev(/* fd */(int)regs->regs_R[MD_REG_R0], iov,
+		   /* iovcnt */(size_t)regs->regs_R[MD_REG_R2]);
+	} while (/*result*/error_return == -1
+	         && errno == EAGAIN);
+
+	/* check for an error condition */
+	if (error_return != -1) {
+		regs->regs_R[MD_REG_R0] = error_return;
+	  } /* no error */
+	else {
+	  	regs->regs_R[MD_REG_R0] = -(errno); /* negative of the error number is returned in r0 */
+	  }
+
+	/* free all the allocated memory */
+	for (i=0; i < /* iovcnt */regs->regs_R[MD_REG_R2]; i++)
+	  {
+	    if (iov[i].iov_base)
+	      {
+		free(iov[i].iov_base);
+		iov[i].iov_base = NULL;
+	      }
+	  }
+	free(iov);
+      }
+      break;
+#endif
+
+#if !defined(MIN_SYSCALL_MODE)
+    case ARM_SYS_readv:
+      {
+	int i;
+	char *buf = NULL;
+	struct osf_iovec *osf_iov;
+	struct iovec *iov;
+	int error_return;
+
+	/* allocate host side I/O vectors */
+	osf_iov =
+	  calloc(/* iovcnt */regs->regs_R[MD_REG_R2],
+		 sizeof(struct osf_iovec));
+	if (!osf_iov)
+	  fatal("out of virtual memory in SYS_readv");
+
+	iov =
+	  calloc(/* iovcnt */regs->regs_R[MD_REG_R2], sizeof(struct iovec));
+	if (!iov)
+	  fatal("out of virtual memory in SYS_readv");
+
+	/* copy host side I/O vector buffers */
+	for (i=0; i < /* iovcnt */regs->regs_R[MD_REG_R2]; i++)
+	  {
+	    /* copy target side pointer data into host side vector */
+	    mem_bcopy(mem_fn, mem, Read,
+		      (/*iov*/regs->regs_R[MD_REG_R1]
+		       + i*sizeof(struct osf_iovec)),
+		      &osf_iov[i], sizeof(struct osf_iovec));
+
+	    iov[i].iov_len = MD_SWAPW(osf_iov[i].iov_len);
+	    if (osf_iov[i].iov_base != 0 && osf_iov[i].iov_len != 0)
+	      {
+		buf =
+		  (char *)calloc(MD_SWAPW(osf_iov[i].iov_len), sizeof(char));
+		if (!buf)
+		  fatal("out of virtual memory in SYS_readv");
+		iov[i].iov_base = buf;
+	      }
+	    else
+	      iov[i].iov_base = NULL;
+	  }
+
+	/* perform the vector'ed read */
+	do {
+	  /*result*/error_return =
+	    readv(/* fd */(int)regs->regs_R[MD_REG_R0], iov,
+		  /* iovcnt */(size_t)regs->regs_R[MD_REG_R2]);
+	} while (/*result*/error_return == -1
+		 && errno == EAGAIN);
+
+	/* copy target side I/O vector buffers to host memory */
+	for (i=0; i < /* iovcnt */regs->regs_R[MD_REG_R2]; i++)
+	  {
+	    if (osf_iov[i].iov_base != 0)
+	      {
+		mem_bcopy(mem_fn, mem, Write, MD_SWAPQ(osf_iov[i].iov_base),
+			  iov[i].iov_base, MD_SWAPW(osf_iov[i].iov_len));
+	      }
+	  }
+
+	/* check for an error condition */
+	if (error_return != -1) {
+		regs->regs_R[MD_REG_R0] = error_return;
+	  } /* no error */
+	else {
+	  	regs->regs_R[MD_REG_R0] = -(errno); /* negative of the error number is returned in r0 */
+	  }
+
+	/* free all the allocated memory */
+	for (i=0; i < /* iovcnt */regs->regs_R[MD_REG_R2]; i++)
+	  {
+	    if (iov[i].iov_base)
+	      {
+		free(iov[i].iov_base);
+		iov[i].iov_base = NULL;
+	      }
+	  }
+
+	if (osf_iov)
+	  free(osf_iov);
+	if (iov)
+	  free(iov);
+      }
+      break;
+#endif
+
+/*------------Subcall of socketcall-------------------------------*/
+#if !defined(MIN_SYSCALL_MODE) && 0
+    case OSF_SYS_setsockopt:
+      {
+	char *buf;
+	struct xlate_table_t *map;
+	int nmap;
+
+ 	/* set options on sockets */
+
+	/* copy optval to host memory */
+	if (/* optval */regs->regs_R[MD_REG_A3] != 0
+	    && /* optlen */regs->regs_R[MD_REG_A4] != 0)
+	  {
+	    buf = calloc(1, /* optlen */(size_t)regs->regs_R[MD_REG_A4]);
+	    if (!buf)
+	      fatal("cannot allocate memory in OSF_SYS_setsockopt");
+	    
+	    /* copy target side pointer data into host side vector */
+	    mem_bcopy(mem_fn, mem, Read,
+		      /* optval */regs->regs_R[MD_REG_A3],
+		      buf, /* optlen */(int)regs->regs_R[MD_REG_A4]);
+	  }
+	else
+	  buf = NULL;
+
+	/* pick the correct translation table */
+	if ((int)regs->regs_R[MD_REG_A1] == OSF_SOL_SOCKET)
+	  {
+	    map = sockopt_map;
+	    nmap = N_ELT(sockopt_map);
+	  }
+	else if ((int)regs->regs_R[MD_REG_A1] == OSF_SOL_TCP)
+	  {
+	    map = tcpopt_map;
+	    nmap = N_ELT(tcpopt_map);
+	  }
+	else
+	  {
+	    warn("no translation map available for `setsockopt()': %d",
+		 (int)regs->regs_R[MD_REG_A1]);
+	    map = sockopt_map;
+	    nmap = N_ELT(sockopt_map);
+	  }
+
+	/* result */regs->regs_R[MD_REG_V0] =
+	  setsockopt(/* sock */(int)regs->regs_R[MD_REG_A0],
+		     /* level */xlate_arg((int)regs->regs_R[MD_REG_A1],
+					  socklevel_map, N_ELT(socklevel_map),
+					  "setsockopt(level)"),
+		     /* optname */xlate_arg((int)regs->regs_R[MD_REG_A2],
+					    map, nmap,
+					    "setsockopt(opt)"),
+		     /* optval */buf,
+		     /* optlen */regs->regs_R[MD_REG_A4]);
+
+	/* check for an error condition */
+	if (regs->regs_R[MD_REG_V0] != (qword_t)-1)
+	  regs->regs_R[MD_REG_A3] = 0;
+	else /* got an error, return details */
+	  {
+	    regs->regs_R[MD_REG_A3] = -1;
+	    regs->regs_R[MD_REG_V0] = errno;
+	  }
+
+	if (buf != NULL)
+	  free(buf);
+      }
+      break;
+#endif
+
+/* subcall of socketcall in arm linux */
+#if !defined(MIN_SYSCALL_MODE) && 0
+    case OSF_SYS_old_getsockname:
+      {
+	/* get socket name */
+	char *buf;
+	word_t osf_addrlen;
+	int addrlen;
+
+	/* get simulator memory parameters to host memory */
+	mem_bcopy(mem_fn, mem, Read,
+		  /* paddrlen */regs->regs_R[MD_REG_A2],
+		  &osf_addrlen, sizeof(osf_addrlen));
+	addrlen = (int)osf_addrlen;
+	if (addrlen != 0)
+	  {
+	    buf = calloc(1, addrlen);
+	    if (!buf)
+	      fatal("cannot allocate memory in OSF_SYS_old_getsockname");
+	  }
+	else
+	  buf = NULL;
+	
+	/* result */regs->regs_R[MD_REG_V0] =
+	  getsockname(/* sock */(int)regs->regs_R[MD_REG_A0],
+		      /* name */(struct sockaddr *)buf,
+		      /* namelen */&addrlen);
+
+	/* check for an error condition */
+	if (regs->regs_R[MD_REG_V0] != (qword_t)-1)
+	  regs->regs_R[MD_REG_A3] = 0;
+	else /* got an error, return details */
+	  {
+	    regs->regs_R[MD_REG_A3] = -1;
+	    regs->regs_R[MD_REG_V0] = errno;
+	  }
+
+	/* copy results to simulator memory */
+	if (addrlen != 0)
+	  mem_bcopy(mem_fn, mem, Write,
+		    /* addr */regs->regs_R[MD_REG_A1],
+		    buf, addrlen);
+	osf_addrlen = (qword_t)addrlen;
+	mem_bcopy(mem_fn, mem, Write,
+		  /* paddrlen */regs->regs_R[MD_REG_A2],
+		  &osf_addrlen, sizeof(osf_addrlen));
+
+	if (buf != NULL)
+	  free(buf);
+      }
+      break;
+#endif
+
+/* part socketcall in arm linux */
+#if !defined(MIN_SYSCALL_MODE) && 0
+    case OSF_SYS_old_getpeername:
+      {
+	/* get socket name */
+	char *buf;
+	word_t osf_addrlen;
+	int addrlen;
+
+	/* get simulator memory parameters to host memory */
+	mem_bcopy(mem_fn, mem, Read,
+		  /* paddrlen */regs->regs_R[MD_REG_A2],
+		  &osf_addrlen, sizeof(osf_addrlen));
+	addrlen = (int)osf_addrlen;
+	if (addrlen != 0)
+	  {
+	    buf = calloc(1, addrlen);
+	    if (!buf)
+	      fatal("cannot allocate memory in OSF_SYS_old_getsockname");
+	  }
+	else
+	  buf = NULL;
+	
+	/* result */regs->regs_R[MD_REG_V0] =
+	  getpeername(/* sock */(int)regs->regs_R[MD_REG_A0],
+		      /* name */(struct sockaddr *)buf,
+		      /* namelen */&addrlen);
+
+	/* check for an error condition */
+	if (regs->regs_R[MD_REG_V0] != (qword_t)-1)
+	  regs->regs_R[MD_REG_A3] = 0;
+	else /* got an error, return details */
+	  {
+	    regs->regs_R[MD_REG_A3] = -1;
+	    regs->regs_R[MD_REG_V0] = errno;
+	  }
+
+	/* copy results to simulator memory */
+	if (addrlen != 0)
+	  mem_bcopy(mem_fn, mem, Write,
+		    /* addr */regs->regs_R[MD_REG_A1],
+		    buf, addrlen);
+	osf_addrlen = (qword_t)addrlen;
+	mem_bcopy(mem_fn, mem, Write,
+		  /* paddrlen */regs->regs_R[MD_REG_A2],
+		  &osf_addrlen, sizeof(osf_addrlen));
+
+	if (buf != NULL)
+	  free(buf);
+      }
+      break;
+#endif
+/*-----------------------------------------------------------------------------------*/
+
+#if !defined(MIN_SYSCALL_MODE)
+    case ARM_SYS_setgid:
+      /* set group ID */
+
+      /*result*/regs->regs_R[MD_REG_R0] =
+	setgid(/* gid */(gid_t)regs->regs_R[MD_REG_R0]);
+
+      /* check for an error condition */
+      if (regs->regs_R[MD_REG_R0] == (qword_t)-1)
+	  /* got an error, return details */
+	    regs->regs_R[MD_REG_R0] = -errno;
+      break;
+#endif
+
+#if !defined(MIN_SYSCALL_MODE)
+    case ARM_SYS_setuid:
+      /* set user ID */
+
+      /*result*/regs->regs_R[MD_REG_R0] =
+	setuid(/* uid */(uid_t)regs->regs_R[MD_REG_R0]);
+
+      /* check for an error condition */
+      if (regs->regs_R[MD_REG_R0] == (qword_t)-1)
+	  /* got an error, return details */
+	    regs->regs_R[MD_REG_R0] = -errno;
+      break;
+#endif
+
+#if !defined(MIN_SYSCALL_MODE)
+    case ARM_SYS_getpriority:
+      /* get program scheduling priority */
+
+      /*result*/regs->regs_R[MD_REG_R0] =
+	getpriority(/* which */(int)regs->regs_R[MD_REG_R0],
+		    /* who */(int)regs->regs_R[MD_REG_R1]);
+
+      /* check for an error condition */
+      if (regs->regs_R[MD_REG_R0] == (qword_t)-1)
+	  /* got an error, return details */
+	    regs->regs_R[MD_REG_R0] = -errno;
+      break;
+#endif
+
+#if !defined(MIN_SYSCALL_MODE)
+    case ARM_SYS_setpriority:
+      /* set program scheduling priority */
+
+      /*result*/regs->regs_R[MD_REG_R0] =
+	setpriority(/* which */(int)regs->regs_R[MD_REG_R0],
+		    /* who */(int)regs->regs_R[MD_REG_R1],
+		    /* prio */(int)regs->regs_R[MD_REG_R2]);
+
+      /* check for an error condition */
+      if (regs->regs_R[MD_REG_R0] == (qword_t)-1)
+	  /* got an error, return details */
+	    regs->regs_R[MD_REG_R0] = -errno;
+      break;
+#endif
+
+#if !defined(MIN_SYSCALL_MODE)
+    case ARM_SYS_select:
+      {
+	fd_set readfd, writefd, exceptfd;
+	fd_set *readfdp, *writefdp, *exceptfdp;
+	struct timeval timeout, *timeoutp;
+
+	/* copy read file descriptor set into host memory */
+	if (/* readfds */regs->regs_R[MD_REG_R1] != 0)
+	  {
+	    mem_bcopy(mem_fn, mem, Read,
+		      /* readfds */regs->regs_R[MD_REG_R1],
+		      &readfd, sizeof(fd_set));
+	    readfdp = &readfd;
+	  }
+	else
+	  readfdp = NULL;
+
+	/* copy write file descriptor set into host memory */
+	if (/* writefds */regs->regs_R[MD_REG_R2] != 0)
+	  {
+	    mem_bcopy(mem_fn, mem, Read,
+		      /* writefds */regs->regs_R[MD_REG_R2],
+		      &writefd, sizeof(fd_set));
+	    writefdp = &writefd;
+	  }
+	else
+	  writefdp = NULL;
+
+	/* copy exception file descriptor set into host memory */
+	if (/* exceptfds */regs->regs_R[MD_REG_R3] != 0)
+	  {
+	    mem_bcopy(mem_fn, mem, Read,
+		      /* exceptfds */regs->regs_R[MD_REG_R3],
+		      &exceptfd, sizeof(fd_set));
+	    exceptfdp = &exceptfd;
+	  }
+	else
+	  exceptfdp = NULL;
+
+	/* copy timeout value into host memory */
+	if (/* timeout */regs->regs_R[MD_REG_R4] != 0)
+	  {
+	    mem_bcopy(mem_fn, mem, Read,
+		      /* timeout */regs->regs_R[MD_REG_R4],
+		      &timeout, sizeof(struct timeval));
+	    timeoutp = &timeout;
+	  }
+	else
+	  timeoutp = NULL;
+
+#if defined(hpux) || defined(__hpux)
+	/* select() on the specified file descriptors */
+	/* result */regs->regs_R[MD_REG_R0] =
+	  select(/* nfds */regs->regs_R[MD_REG_R0],
+		 (int *)readfdp, (int *)writefdp, (int *)exceptfdp, timeoutp);
+#else
+	/* select() on the specified file descriptors */
+	/* result */regs->regs_R[MD_REG_R0] =
+	  select(/* nfds */regs->regs_R[MD_REG_R0],
+		 readfdp, writefdp, exceptfdp, timeoutp);
+#endif
+
+	/* check for an error condition */
+	if (regs->regs_R[MD_REG_R0] == (qword_t)-1)
+	  /* got an error, return details */
+	    regs->regs_R[MD_REG_R0] = -errno;
+
+	/* copy read file descriptor set to target memory */
+	if (/* readfds */regs->regs_R[MD_REG_R1] != 0)
+	  mem_bcopy(mem_fn, mem, Write,
+		    /* readfds */regs->regs_R[MD_REG_R1],
+		    &readfd, sizeof(fd_set));
+
+	/* copy write file descriptor set to target memory */
+	if (/* writefds */regs->regs_R[MD_REG_R2] != 0)
+	  mem_bcopy(mem_fn, mem, Write,
+		    /* writefds */regs->regs_R[MD_REG_R2],
+		    &writefd, sizeof(fd_set));
+
+	/* copy exception file descriptor set to target memory */
+	if (/* exceptfds */regs->regs_R[MD_REG_R3] != 0)
+	  mem_bcopy(mem_fn, mem, Write,
+		    /* exceptfds */regs->regs_R[MD_REG_R3],
+		    &exceptfd, sizeof(fd_set));
+
+	/* copy timeout value result to target memory */
+	if (/* timeout */regs->regs_R[MD_REG_R4] != 0)
+	  mem_bcopy(mem_fn, mem, Write,
+		    /* timeout */regs->regs_R[MD_REG_R4],
+		    &timeout, sizeof(struct timeval));
+      }
+      break;
+#endif
+
+/* part of socketcall in arm linux */
+#if !defined(MIN_SYSCALL_MODE) && 0
+    case ARM_SYS_shutdown:
+      /* shuts down socket send and receive operations */
+
+      /*result*/regs->regs_R[MD_REG_R0] =
+	shutdown(/* sock */(int)regs->regs_R[MD_REG_R0],
+		 /* how */(int)regs->regs_R[MD_REG_R1]);
+
+      /* check for an error condition */
+      if (regs->regs_R[MD_REG_R0] == (qword_t)-1)
+	  /* got an error, return details */
+	    regs->regs_R[MD_REG_R0] = -errno;
+      break;
+#endif
+
+#if !defined(MIN_SYSCALL_MODE)
+    case ARM_SYS_poll:
+      {
+	int i;
+	int error_return;
+	struct pollfd *fds;
+
+	/* allocate host side I/O vectors */
+	fds = calloc(/* nfds */regs->regs_R[MD_REG_R1], sizeof(struct pollfd));
+	if (!fds)
+	  fatal("out of virtual memory in SYS_poll");
+
+	/* copy target side I/O vector buffers to host memory */
+	for (i=0; i < /* nfds */regs->regs_R[MD_REG_R1]; i++)
+	  {
+	    /* copy target side pointer data into host side vector */
+	    mem_bcopy(mem_fn, mem, Read,
+		      (/* fds */regs->regs_R[MD_REG_R0]
+		       + i*sizeof(struct pollfd)),
+		      &fds[i], sizeof(struct pollfd));
+	  }
+
+	/* perform the vector'ed write */
+	/* result */error_return =
+	  poll(/* fds */fds,
+	       /* nfds */(unsigned long)regs->regs_R[MD_REG_R1],
+	       /* timeout */(int)regs->regs_R[MD_REG_R2]);
+
+	/* copy target side I/O vector buffers to host memory */
+	for (i=0; i < /* nfds */regs->regs_R[MD_REG_R1]; i++)
+	  {
+	    /* copy target side pointer data into host side vector */
+	    mem_bcopy(mem_fn, mem, Write,
+		      (/* fds */regs->regs_R[MD_REG_A0]
+		       + i*sizeof(struct pollfd)),
+		      &fds[i], sizeof(struct pollfd));
+	  }
+
+	/* check for an error condition */
+	if (error_return != -1) {
+		regs->regs_R[MD_REG_R0] = error_return;
+	} /* no error */
+	else {
+	  	regs->regs_R[MD_REG_R0] = -(errno); /* negative of the error number is returned in r0 */
+	}
+
+	
+
+	/* free all the allocated memory */
+	free(fds);
+      }
+      break;
+#endif
+
+#if XXX
+    case OSF_SYS_usleep_thread:
+#if 0
+      fprintf(stderr, "usleep(%d)\n", (unsigned int)regs->regs_R[MD_REG_A0]);
+#endif
+#ifdef alpha
+      regs->regs_R[MD_REG_V0] = usleep((unsigned int)regs->regs_R[MD_REG_A0]);
+#else
+      usleep((unsigned int)regs->regs_R[MD_REG_A0]);
+      regs->regs_R[MD_REG_V0] = 0;
+#endif
+      /* check for an error condition */
+      if (regs->regs_R[MD_REG_V0] != (qword_t)-1)
+        regs->regs_R[MD_REG_A3] = 0;
+      else /* got an error, return details */
+        {
+          regs->regs_R[MD_REG_A3] = -1;
+          regs->regs_R[MD_REG_V0] = errno;
+        }
+#if 0
+      warn("unsupported usleep_thread() call...");
+      regs->regs_R[MD_REG_V0] = 0; 
+#endif
+      break;
+#endif
+      
+/* part of socketcall in arm linux */
+#if !defined(MIN_SYSCALL_MODE) && 0
+    case OSF_SYS_gethostname:
+      /* get program scheduling priority */
+      {
+	char *buf;
+
+	buf = malloc(/* len */(size_t)regs->regs_R[MD_REG_A1]);
+	if (!buf)
+	  fatal("out of virtual memory in gethostname()");
+
+	/* result */regs->regs_R[MD_REG_V0] =
+	  gethostname(/* name */buf,
+		      /* len */(size_t)regs->regs_R[MD_REG_A1]);
+
+	/* check for an error condition */
+	if (regs->regs_R[MD_REG_V0] != (qword_t)-1)
+	  regs->regs_R[MD_REG_A3] = 0;
+	else /* got an error, return details */
+	  {
+	    regs->regs_R[MD_REG_A3] = -1;
+	    regs->regs_R[MD_REG_V0] = errno;
+	  }
+
+	/* copy string back to simulated memory */
+	mem_bcopy(mem_fn, mem, Write,
+		  /* name */regs->regs_R[MD_REG_A0],
+		  buf, /* len */regs->regs_R[MD_REG_A1]);
+      }
+      break;
+#endif
+
+#if XXX
+    case OSF_SYS_madvise:
+      warn("unsupported madvise() call ignored...");
+      regs->regs_R[MD_REG_V0] = 0;
+      break;
+#endif
+/* The entry into the sockets function calls!!! */
+#if !defined(MIN_SYSCALL_MODE)
+    case ARM_SYS_socketcall:
+    /* the first argument is the socket call function type */
+    switch((int)regs->regs_R[MD_REG_R0]){
+          case ARM_SYS_SOCKET:
+	  {
+          /* create an endpoint for communication */
+          int __domain,__type,__protocol;
+             /* grab the socket call arguments from simulated memory */
+             mem_bcopy(mem_fn, mem, Read, regs->regs_R[MD_REG_R1], &__domain,
+		  /*nbytes*/sizeof(int));
+             mem_bcopy(mem_fn, mem, Read, (regs->regs_R[MD_REG_R1]+sizeof(int)), &__type,
+		  /*nbytes*/sizeof(int));
+             mem_bcopy(mem_fn, mem, Read, (regs->regs_R[MD_REG_R1]+2*sizeof(int)), &__protocol,
+		  /*nbytes*/sizeof(int));
+
+ 
+           /* result */regs->regs_R[MD_REG_R0] =
+	   socket(/* domain */xlate_arg(__domain,
+				     family_map, N_ELT(family_map),
+				     "socket(family)"),
+	       /* type */xlate_arg(__type,
+				   socktype_map, N_ELT(socktype_map),
+				   "socket(type)"),
+	       /* protocol */xlate_arg(__protocol,
+				       family_map, N_ELT(family_map),
+				       "socket(proto)"));
+
+
+          /* check for an error condition */
+              if (regs->regs_R[MD_REG_R0] == (qword_t)-1)
+	  /* got an error, return details */
+	         regs->regs_R[MD_REG_R0] = -errno;
+          }
+          break;
+
+          case ARM_SYS_BIND:
+          {
+	     const struct sockaddr a_sock;
+             int __sockfd,__addrlen,__sim_a_sock;
+
+             /* grab the function call arguments from memory */
+             mem_bcopy(mem_fn, mem, Read,regs->regs_R[MD_REG_R0], 
+                    &__sockfd,sizeof(int));
+	     mem_bcopy(mem_fn, mem, Read,(regs->regs_R[MD_REG_R0]+sizeof(int)),
+		    &__sim_a_sock, sizeof(int));
+	     mem_bcopy(mem_fn, mem, Read,
+                    (regs->regs_R[MD_REG_R0]+2*sizeof(int)),
+		    &__addrlen, sizeof(int));
+
+             /* copy the sockadd to real memory */
+             mem_bcopy(mem_fn, mem, Read,__sim_a_sock,
+		    &a_sock, sizeof(struct sockaddr));
+             
+             regs->regs_R[MD_REG_R0] =
+	        bind(__sockfd, &a_sock,__addrlen);
+
+             /* check for an error condition */
+             
+             /*NOT sure if the commented code is done since it is a subcall?*/
+             //if (regs->regs_R[MD_REG_R0] != (qword_t)-1)
+	     //regs->regs_R[MD_REG_R3] = 0;
+             //else /* got an error, return details */
+	     //{
+	     //   regs->regs_R[MD_REG_R3] = -1;
+	     //   regs->regs_R[MD_REG_R0] = errno;
+	     //}
+          }
+          break;
+
+          case ARM_SYS_CONNECT:
+	  {
+ 	     struct osf_sockaddr osf_sa;
+             int __sockfd,__addrlen,__sim_addr;
+	  /* initiate a connection on a socket */
+
+	  /*copy the arguments from simulated memory */ 
+             mem_bcopy(mem_fn, mem, Read,regs->regs_R[MD_REG_R0], 
+                    &__sockfd,sizeof(int));
+	     mem_bcopy(mem_fn, mem, Read,(regs->regs_R[MD_REG_R0]+sizeof(int)),
+		    &__sim_addr, sizeof(int));
+	     mem_bcopy(mem_fn, mem, Read,(regs->regs_R[MD_REG_R0]+2*sizeof(int)),
+		    &__addrlen, sizeof(int));
+
+          
+	/* copy sockaddr structure to host memory */
+	mem_bcopy(mem_fn, mem, Read, /* serv_addr */__sim_addr,
+		  &osf_sa, sizeof(struct osf_sockaddr));
+
+#if 0
+	int i;
+	sa.sa_family = osf_sa.sa_family;
+	for (i=0; i < regs->regs_R[MD_REG_R2]; i++)
+	  sa.sa_data[i] = osf_sa.sa_data[i];
+#endif
+	/* result */regs->regs_R[MD_REG_R0] =
+	  connect(/* sockfd */__sockfd,
+		  (void *)&osf_sa, __addrlen);
+
+	  /* check for an error condition */
+	  if (regs->regs_R[MD_REG_R0] == (qword_t)-1)
+	     /* got an error, return details */
+	       regs->regs_R[MD_REG_R0] = -errno;
+          }
+          break;
+
+          
+          case ARM_SYS_LISTEN:
+          {
+             warn("invalid/unimplemented socket function, PC=0x%08p, winging it"
+                , regs->regs_PC);
+             abort();
+          }
+          break;
+          case ARM_SYS_ACCEPT:
+	  {
+            warn("invalid/unimplemented socket function, PC=0x%08p, winging it"
+                , regs->regs_PC);
+             abort();
+          }
+          break;
+          case ARM_SYS_GETSOCKNAME:
+          {
+	    /* get socket name */
+	    char *buf;
+	    word_t osf_addrlen;
+	    int addrlen;
+            int __s, __name, __namelen;
+	    /*copy the arguments from simulated memory */ 
+            mem_bcopy(mem_fn, mem, Read,regs->regs_R[MD_REG_R0], 
+                    &__s,sizeof(int));
+	    mem_bcopy(mem_fn, mem, Read,(regs->regs_R[MD_REG_R0]+sizeof(int)),
+		    &__name, sizeof(int));
+	    mem_bcopy(mem_fn, mem, Read,(regs->regs_R[MD_REG_R0]+2*sizeof(int)),
+		    &__namelen, sizeof(int));
+
+	    /* get simulator memory parameters to host memory */
+	    mem_bcopy(mem_fn, mem, Read,
+		      /* paddrlen */__namelen,
+		  &osf_addrlen, sizeof(osf_addrlen));
+	    addrlen = (int)osf_addrlen;
+	    if (addrlen != 0)
+	    {
+	      buf = calloc(1, addrlen);
+	      if (!buf)
+	        fatal("cannot allocate memory in OSF_SYS_old_getsockname");
+	    }
+	    else
+	      buf = NULL;
+
+            /* do the actual system call on the bative machine */	
+	    /* result */regs->regs_R[MD_REG_V0] =
+	    getsockname(/* sock */__s,
+		      /* name */(struct sockaddr *)buf,
+		      /* namelen */&addrlen);
+
+	    /* check for an error condition */
+	    if (regs->regs_R[MD_REG_R0] != (qword_t)-1)
+              ;
+	      //	      regs->regs_R[MD_REG_A3] = 0;
+	    else /* got an error, return details */
+	    {
+	      //regs->regs_R[MD_REG_A3] = -1;
+	      regs->regs_R[MD_REG_V0] = errno;
+	    }
+
+	    /* copy results to simulator memory */
+	    if (addrlen != 0)
+	       mem_bcopy(mem_fn, mem, Write,
+		    /* addr */regs->regs_R[MD_REG_A1],
+		    buf, addrlen);
+
+	    osf_addrlen = (qword_t)addrlen;
+	    mem_bcopy(mem_fn, mem, Write,
+		  /* paddrlen */__namelen,
+		  &osf_addrlen, sizeof(osf_addrlen));
+
+	    if (buf != NULL)
+	      free(buf);
+          }	  
+          break;
+
+          case ARM_SYS_GETPEERNAME:
+          {
+	    /* get socket name */
+	    char *buf;
+	    word_t osf_addrlen;
+	    int addrlen;
+            int __s, __name, __namelen;
+            /*grab the function call arguments from sim memory*/
+	    mem_bcopy(mem_fn, mem, Read,
+		  (regs->regs_R[MD_REG_R1]),
+		  &__s, sizeof(int));
+
+            mem_bcopy(mem_fn, mem, Read,
+		  (regs->regs_R[MD_REG_R1]+sizeof(int)),
+		  &__name, sizeof(int));
+
+            mem_bcopy(mem_fn, mem, Read,
+		  (regs->regs_R[MD_REG_R1]+2*sizeof(int)),
+		  &__namelen, sizeof(int));
+
+
+	    /* get simulator memory parameters to host memory */
+	    mem_bcopy(mem_fn, mem, Read,
+		  /* paddrlen */__namelen,
+		  &osf_addrlen, sizeof(osf_addrlen));
+	    addrlen = (int)osf_addrlen;
+
+            /* allocate host memory for system call result */
+	    if (addrlen != 0)
+	    {
+	      buf = calloc(1, addrlen);
+	      if (!buf)
+	        fatal("cannot allocate memory in OSF_SYS_old_getsockname");
+	    }
+	    else
+	      buf = NULL;
+	
+	  /* result */regs->regs_R[MD_REG_R0] =
+	    getpeername(/* sock */__s,
+		      /* name */(struct sockaddr *)buf,
+		      /* namelen */&addrlen);
+
+	  /* check for an error condition */
+	    /* NOT sure how to handle this yet ??
+               do we set memory?? in arm*/
+	    if (regs->regs_R[MD_REG_R0] != (qword_t)-1);
+	    //regs->regs_R[MD_REG_A3] = 0;
+	    else /* got an error, return details */
+	    //  {
+	    //    regs->regs_R[MD_REG_A3] = -1;
+	        regs->regs_R[MD_REG_R0] = errno;
+	    //  }
+
+	  /* copy results to simulator memory */
+	  if (addrlen != 0)
+	    mem_bcopy(mem_fn, mem, Write,
+		    /* addr */__name,
+		    buf, addrlen);
+
+	    osf_addrlen = (qword_t)addrlen;
+	    mem_bcopy(mem_fn, mem, Write,
+		  /* paddrlen */__namelen,
+		  &osf_addrlen, sizeof(osf_addrlen));
+
+	     if (buf != NULL)
+	      free(buf);
+          }
+          break;
+
+          case ARM_SYS_SOCKETPAIR:
+	  {
+            warn("invalid/unimplemented socket function, PC=0x%08p, winging it"
+                , regs->regs_PC);
+             abort();
+          }
+          break;          
+  
+          case ARM_SYS_SEND:
+	  {
+
+            warn("invalid/unimplemented socket function, PC=0x%08p, winging it"
+                , regs->regs_PC);
+             abort();
+          }
+          break;
+
+          case ARM_SYS_RECV:
+	  {
+            warn("invalid/unimplemented socket function, PC=0x%08p, winging it"
+                , regs->regs_PC);
+             abort();
+          }
+          break;
+ 
+          case ARM_SYS_SENDTO:
+          {
+	     char *buf = NULL;
+	     struct sockaddr d_sock;
+	     int buf_len = 0;
+             int __s, __msg, __len, __flags, __to, __tolen;
+            /*grab the function call arguments from sim memory*/
+	    mem_bcopy(mem_fn, mem, Read,
+		  (regs->regs_R[MD_REG_R1]),
+		  &__s, sizeof(int));
+
+            mem_bcopy(mem_fn, mem, Read,
+		  (regs->regs_R[MD_REG_R1]+sizeof(int)),
+		  &__msg, sizeof(int));
+
+            mem_bcopy(mem_fn, mem, Read,
+		  (regs->regs_R[MD_REG_R1]+2*sizeof(int)),
+		  &__len, sizeof(int));
+
+            mem_bcopy(mem_fn, mem, Read,
+		  (regs->regs_R[MD_REG_R1]+3*sizeof(int)),
+		  &__flags, sizeof(int));
+
+            mem_bcopy(mem_fn, mem, Read,
+		  (regs->regs_R[MD_REG_R1]+4*sizeof(int)),
+		  &__to, sizeof(int));
+
+            mem_bcopy(mem_fn, mem, Read,
+		  (regs->regs_R[MD_REG_R1]+5*sizeof(int)),
+		  &__tolen, sizeof(int));
+
+
+	     buf_len = __len;
+             /* make a buffer in host memory for system call */
+	     if (buf_len > 0)
+	       buf = (char *) malloc(buf_len*sizeof(char));
+
+	     /* copy the message from simualted memory to host memory */
+	      mem_bcopy(mem_fn, mem, Read, /* serv_addr */__msg,
+		  buf, /* addrlen */__len);
+
+	     if (__tolen > 0) 
+	       mem_bcopy(mem_fn, mem, Read, __to,
+		    &d_sock, __tolen);
+
+             /* make the actual system call */
+	     regs->regs_R[MD_REG_R0] =
+	     sendto(__s,buf,__len,__flags,&d_sock,__tolen);
+
+	     mem_bcopy(mem_fn, mem, Write, /* serv_addr*/__msg,
+		  buf, /* addrlen */__len);
+
+	   /* maybe copy back whole size of sockaddr */
+	   if (__tolen > 0)
+	      mem_bcopy(mem_fn, mem, Write, __to,
+		    &d_sock, __tolen);
+
+	   /* Not sure what to do with the error conditions yet */
+	    /* check for an error condition */
+	    if (regs->regs_R[MD_REG_R0] != (qword_t)-1)
+              ;
+             
+	      //  regs->regs_R[MD_REG_A3] = 0;
+	    else /* got an error, return details */
+	    {
+	      //regs->regs_R[MD_REG_A3] = -1;
+	      regs->regs_R[MD_REG_R0] = errno;
+	    }
+
+	    if (buf != NULL) 
+	      free(buf);
+          }	 
+          break;
+
+          case ARM_SYS_RECVFROM:
+          {
+	    int addr_len;
+	    char *buf;
+	    struct sockaddr *a_sock;
+            int __s, __buf, __len, __flags, __from, __fromlen;          
+             /*grab the function call arguments from sim memory*/
+	    mem_bcopy(mem_fn, mem, Read,
+		  (regs->regs_R[MD_REG_R1]),
+		  &__s, sizeof(int));
+
+            mem_bcopy(mem_fn, mem, Read,
+		  (regs->regs_R[MD_REG_R1]+sizeof(int)),
+		  &__buf, sizeof(int));
+
+            mem_bcopy(mem_fn, mem, Read,
+		  (regs->regs_R[MD_REG_R1]+2*sizeof(int)),
+		  &__len, sizeof(int));
+
+            mem_bcopy(mem_fn, mem, Read,
+		  (regs->regs_R[MD_REG_R1]+3*sizeof(int)),
+		  &__flags, sizeof(int));
+
+            mem_bcopy(mem_fn, mem, Read,
+		  (regs->regs_R[MD_REG_R1]+4*sizeof(int)),
+		  &__from, sizeof(int));
+
+            mem_bcopy(mem_fn, mem, Read,
+		  (regs->regs_R[MD_REG_R1]+5*sizeof(int)),
+		  &__fromlen, sizeof(int));
+
+	    buf = (char *) malloc((__len));
+
+	    mem_bcopy(mem_fn, mem, Read, /* serv_addr */__buf,
+		  buf, /* addrlen */__len);
+
+	    mem_bcopy(mem_fn, mem, Read, /* serv_addr */__fromlen,
+		  &addr_len, sizeof(int));
+
+            /* make a buffer in host memory for the socket address */
+	    a_sock = (struct sockaddr *)malloc(addr_len);
+
+	    mem_bcopy(mem_fn, mem, Read, __from,
+		  a_sock, addr_len);
+
+            /* make the actual system call */
+	    regs->regs_R[MD_REG_R0] =
+	    recvfrom(__s, buf,__len,__flags, a_sock,&addr_len);
+
+	    mem_bcopy(mem_fn, mem, Write, __buf,
+		  buf, (int) regs->regs_R[MD_REG_R0]);
+
+	    mem_bcopy(mem_fn, mem, Write, /* serv_addr */__fromlen,
+		  &addr_len, sizeof(int));
+
+	    mem_bcopy(mem_fn, mem, Write, __from,
+		  a_sock, addr_len);
+
+	    /* check for an error condition */
+	    if (regs->regs_R[MD_REG_R0] != (qword_t)-1)
+               ;
+	    //regs->regs_R[MD_REG_A3] = 0;
+	    else /* got an error, return details */
+	       {
+		 // regs->regs_R[MD_REG_A3] = -1;
+	       regs->regs_R[MD_REG_V0] = errno;
+	       }
+	    if (buf != NULL)
+	      free(buf);
+          }
+          break;
+
+          case ARM_SYS_SHUTDOWN:
+	  {
+            /* can't find docs on this winging it!! */
+            int __arg1, __arg2;
+	    mem_bcopy(mem_fn, mem, Read,
+		  (regs->regs_R[MD_REG_R1]),
+		  &__arg1, sizeof(int));
+
+            mem_bcopy(mem_fn, mem, Read,
+		  (regs->regs_R[MD_REG_R1]+sizeof(int)),
+		  &__arg2, sizeof(int));
+            /* shuts down socket send and receive operations */
+
+            /*result*/regs->regs_R[MD_REG_R0] =
+	    shutdown(/* sock */__arg1,
+		   /* how */__arg2);
+
+            /* check for an error condition */
+            if (regs->regs_R[MD_REG_R0] == (qword_t)-1)
+	    /* got an error, return details */
+	       regs->regs_R[MD_REG_R0] = -errno;
+          }
+          break;
+
+          case ARM_SYS_SETSOCKOPT:
+          {
+	    char *buf;
+	    struct xlate_table_t *map;
+	    int nmap;
+            int __s, __level, __optname, __optval, __optlen;
+	    mem_bcopy(mem_fn, mem, Read,
+		  (regs->regs_R[MD_REG_R1]),
+		  &__s, sizeof(int));
+
+            mem_bcopy(mem_fn, mem, Read,
+		  (regs->regs_R[MD_REG_R1]+sizeof(int)),
+		  &__level, sizeof(int));
+
+            mem_bcopy(mem_fn, mem, Read,
+		  (regs->regs_R[MD_REG_R1]+2*sizeof(int)),
+		  &__optname, sizeof(int));
+
+            mem_bcopy(mem_fn, mem, Read,
+		  (regs->regs_R[MD_REG_R1]+3*sizeof(int)),
+		  &__optval, sizeof(int));
+
+            mem_bcopy(mem_fn, mem, Read,
+		  (regs->regs_R[MD_REG_R1]+4*sizeof(int)),
+		  &__optlen, sizeof(int));
+
+
+ 	    /* set options on sockets */
+
+	    /* copy optval to host memory */
+	    if (/* optval */__optval != 0
+	       && /* optlen */__optlen != 0)
+	    {
+	      buf = calloc(1, /* optlen */(size_t)__optlen);
+	      if (!buf)
+	        fatal("cannot allocate memory in OSF_SYS_setsockopt");
+	    
+	      /* copy target side pointer data into host side vector */
+	      mem_bcopy(mem_fn, mem, Read,
+		      /* optval */__optval,
+		      buf, /* optlen */__optlen);
+	    }
+	    else
+	      buf = NULL;
+
+	    /* pick the correct translation table */
+	    if (__level == OSF_SOL_SOCKET)
+	    {
+	      map = sockopt_map;
+	      nmap = N_ELT(sockopt_map);
+	    }
+	    else if (__level == OSF_SOL_TCP)
+	    {
+	      map = tcpopt_map;
+	      nmap = N_ELT(tcpopt_map);
+	    }
+	    else
+	    {
+	      warn("no translation map available for `setsockopt()': %d",
+		 __level);
+	      map = sockopt_map;
+	      nmap = N_ELT(sockopt_map);
+	    }
+
+	    /* result */regs->regs_R[MD_REG_R0] =
+	    setsockopt(/* sock */__s,
+		     /* level */xlate_arg(__level,
+					  socklevel_map, N_ELT(socklevel_map),
+					  "setsockopt(level)"),
+		     /* optname */xlate_arg(__optname,
+					    map, nmap,
+					    "setsockopt(opt)"),
+		     /* optval */buf,
+		     /* optlen */__optlen);
+
+            /*not sure how to handle errors yet */        
+	    /* check for an error condition */
+	    if (regs->regs_R[MD_REG_R0] != (qword_t)-1)
+              ;
+	      //  regs->regs_R[MD_REG_A3] = 0;
+	    else /* got an error, return details */
+	    {
+	      //  regs->regs_R[MD_REG_A3] = -1;
+	      regs->regs_R[MD_REG_R0] = errno;
+	    }
+
+	    if (buf != NULL)
+	      free(buf);
+          }	 
+          break;
+
+          case ARM_SYS_GETSOCKOPT:
+	  {
+            warn("invalid/unimplemented socket function, PC=0x%08p, winging it"
+                , regs->regs_PC);
+             abort();
+          }
+          break;          
+
+          case ARM_SYS_SENDMSG:
+	  {
+            warn("invalid/unimplemented socket function, PC=0x%08p, winging it"
+                , regs->regs_PC);
+             abort();
+          }
+          break;
+
+          case ARM_SYS_RECVMSG:
+	  {
+            warn("invalid/unimplemented socket function, PC=0x%08p, winging it"
+                , regs->regs_PC);
+             abort();
+          }
+          break;
+          default:
+             warn("invalid/unimplemented socket function, PC=0x%08p, winging it"
+                , regs->regs_PC);
+             abort();
+     }
+     break;
+#endif
+
+
+    default:
+      warn("invalid/unimplemented syscall %d, PC=0x%08p, winging it",
+	   (int)syscode, regs->regs_PC);
+      /* declare an error condition */
+      regs->regs_R[MD_REG_R0] = -EINVAL;
+    }
+
+  if (verbose)
+    fprintf(stderr, "syscall(%d): returned 0x%08x(%d)...\n",
+      (int)syscode, regs->regs_R[MD_REG_R0], regs->regs_R[MD_REG_R0]);
+}
-- 
1.6.0.4

